<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>LlamaFactory参数详解 | 廾匸</title><meta name="author" content="Dummy"><meta name="copyright" content="Dummy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="LlamaFactory参数详解Link LlamaFactory是一个简单易上手的大模型训练工具 微调的概念微调是指在一个已经预训练的模型基础上进行进一步的训练。预训练模型通常是在大规模数据集(如imageNet或大型文本语料库)上训练的，因此已经捕获了丰富的特征和知识。微调的目标是利用预训练模型的知识，在较小的数据集砂锅进行特定任务的优化。 主要特点1.预训练模型：基于已经训练好的模型进行 2">
<meta property="og:type" content="article">
<meta property="og:title" content="LlamaFactory参数详解">
<meta property="og:url" content="https://dummyv07.github.io/2024/12/10/LlamaFactory%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="廾匸">
<meta property="og:description" content="LlamaFactory参数详解Link LlamaFactory是一个简单易上手的大模型训练工具 微调的概念微调是指在一个已经预训练的模型基础上进行进一步的训练。预训练模型通常是在大规模数据集(如imageNet或大型文本语料库)上训练的，因此已经捕获了丰富的特征和知识。微调的目标是利用预训练模型的知识，在较小的数据集砂锅进行特定任务的优化。 主要特点1.预训练模型：基于已经训练好的模型进行 2">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://dummyv07.github.io/img/eyes.jpg">
<meta property="article:published_time" content="2024-12-10T06:00:00.000Z">
<meta property="article:modified_time" content="2024-12-12T08:49:03.833Z">
<meta property="article:author" content="Dummy">
<meta property="article:tag" content="LLM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dummyv07.github.io/img/eyes.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "LlamaFactory参数详解",
  "url": "https://dummyv07.github.io/2024/12/10/LlamaFactory%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/",
  "image": "https://dummyv07.github.io/img/eyes.jpg",
  "datePublished": "2024-12-10T06:00:00.000Z",
  "dateModified": "2024-12-12T08:49:03.833Z",
  "author": [
    {
      "@type": "Person",
      "name": "Dummy",
      "url": "https://dummyv07.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://dummyv07.github.io/2024/12/10/LlamaFactory%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'LlamaFactory参数详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/eyes.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/bg2.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">廾匸</span></a><a class="nav-page-title" href="/"><span class="site-name">LlamaFactory参数详解</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">LlamaFactory参数详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-10T06:00:00.000Z" title="发表于 2024-12-10 14:00:00">2024-12-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-12T08:49:03.833Z" title="更新于 2024-12-12 16:49:03">2024-12-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="LlamaFactory参数详解"><a href="#LlamaFactory参数详解" class="headerlink" title="LlamaFactory参数详解"></a>LlamaFactory参数详解</h1><p><a target="_blank" rel="noopener" href="https://ezool.net/blog/LLAMA_FACTORYKuangJiaGeCanShuZhengLi/24.html">Link</a></p>
<p>LlamaFactory是一个简单易上手的大模型训练工具</p>
<h3 id="微调的概念"><a href="#微调的概念" class="headerlink" title="微调的概念"></a>微调的概念</h3><p>微调是指在一个已经预训练的模型基础上进行进一步的训练。预训练模型通常是在大规模数据集(如imageNet或大型文本语料库)上训练的，因此已经捕获了丰富的特征和知识。微调的目标是利用预训练模型的知识，在较小的数据集砂锅进行特定任务的优化。</p>
<h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><p>1.预训练模型：基于已经训练好的模型进行</p>
<p>2.较少数据：通常只需要较小的数据集</p>
<p>3.较短时间：训练时间相对较短，因为模型已经有了良好的初始化</p>
<p>4.目标：适应特定任务或领域，优化模型性能</p>
<h2 id="1-微调方法"><a href="#1-微调方法" class="headerlink" title="1.微调方法"></a>1.微调方法</h2><h3 id="LORA"><a href="#LORA" class="headerlink" title="LORA"></a>LORA</h3><p>LoRA(低秩微调，Low-Rank Adaption)是一种通过低秩近似方法来减少模型参数数量和计算量的技术。它的主要目标是通过将原始的高纬参数矩阵分解成两个低秩矩阵的乘积(W ≈ A · B)，从而实现模型的参数压缩和计算加速。</p>
<p>其中：</p>
<ul>
<li>W 是原始的高维参数矩阵。</li>
<li>A 和 B 是低秩矩阵，其秩（rank）远小于 W 的维度。</li>
<li>A的维度为 m x r 。</li>
<li>B的维度为 r x n 。</li>
<li>通过这种分解，我们可以将参数数量从 m x n 减少到 m x r + r x n。</li>
</ul>
<p>优点</p>
<ul>
<li>参数压缩：通过低秩分解，可以将模型的参数数量显著减少，从而减少模型的存储需求</li>
<li>计算加速：低秩分解后的计算复杂度较低，可以加速模型的推理和训练过程。</li>
<li>保持模型性能：在大多数情况下，LoRA能够在减少参数数量的同时，保持模型的性能不显著下降</li>
</ul>
<p>应用场景</p>
<ul>
<li>模型压缩：LoRA可以用于压缩大型深度学习模型，如BERT、GPT等，从而在资源受限的设备上运行</li>
<li>模型加速：通过减少计算量，LoRA可以加速模型的推理速度，适用于实时应用场景</li>
<li>迁移学习：在迁移学习中LoRA可以用于微调预训练模型，从而适应新的任务</li>
</ul>
<p>实现LoRA的步骤</p>
<p>1.选择合适的低秩：根据实际需求，选择合适的低秩r</p>
<p>2.矩阵分解：将原始参数矩阵W分解成两个低秩矩阵A和B</p>
<p>3.训练和优化：使用标准的优化算法(如梯度下降)对低秩矩阵A和B进行训练和优化</p>
<h3 id="Full"><a href="#Full" class="headerlink" title="Full"></a>Full</h3><p>全参数微调(Full Fine-Tuning)是指在微调过程中，预训练模型的所有参数都参与训练。这意味着模型的每一个层、每一个参数都会根据新的任务数据进行更新和调整。它具有高灵活性和良好的效果，但同时也需要较多的计算资源和数据量。适用于数据量充足、计算资源充裕且需要高精度的任务场景。</p>
<p>优点</p>
<ul>
<li>灵活性好：可以充分利用预训练模型的全部能力，适应新任务的各种特性。</li>
<li>效果好：在大多数情况下，能够获得较好的微调效果，因为所有参数都参与了训练和调整。</li>
</ul>
<p>缺点</p>
<ul>
<li>计算资源消耗大：需要较多大计算资源和时间，尤其是在处理大型模型时。</li>
<li>过拟合风险：在数据量较小的情况下，容易导致过拟合，因为所有参数都可能被过度调整。</li>
</ul>
<p>适用场景</p>
<ul>
<li>数据量充足：当新任务的数据量充足时，全参数微调能够充分利用这些数据进行训练。</li>
<li>计算资源充足：当计算资源(如GPU、TPU等)充足时，全参数微调能够在合理时间内完成训练。</li>
<li>需要高精度：当新任务对模型精度要求较高时，全参数微调能够提供最佳的模型性能。</li>
</ul>
<h3 id="Freeze"><a href="#Freeze" class="headerlink" title="Freeze"></a>Freeze</h3><p>冻结参数微调（Freeze Fine-Tuning）** 是指在微调过程中，冻结预训练模型的大部分参数，只训练和更新模型的部分参数（通常是最后几层或新增的任务特定层）。它具有计算资源需求低、减少过拟合风险和快速收敛的优点，适用于数据量较小、计算资源有限或需要快速迭代的场景。然而，由于大部分参数被冻结，模型的灵活性和性能可能会受到一定限制。</p>
<p>优点</p>
<ul>
<li><strong>计算资源需求低</strong>：由于只更新部分参数，计算资源和时间需求较低。</li>
<li><strong>减少过拟合风险</strong>：冻结大部分参数可以减少过拟合的风险，特别是在数据量较小的情况下。</li>
<li><strong>快速收敛</strong>：由于参数更新较少，模型训练通常收敛更快。</li>
</ul>
<p>缺点</p>
<ul>
<li><strong>灵活性较低</strong>：由于大部分参数被冻结，模型的适应能力有限，可能无法充分利用预训练模型的全部能力。</li>
<li><strong>性能可能受限</strong>：在一些复杂任务中，性能可能不如全参数微调，因为模型无法进行全面的调整。</li>
</ul>
<p>适用场景</p>
<ul>
<li><strong>数据量较小</strong>：当新任务的数据量较小时，冻结参数微调可以有效减少过拟合风险。</li>
<li><strong>计算资源有限</strong>：当计算资源（如GPU、TPU等）有限时，冻结参数微调是一种高效的微调方法。</li>
<li><strong>快速迭代</strong>：当需要快速进行模型迭代和验证时，冻结参数微调可以加快训练速度。</li>
</ul>
<h2 id="2-训练方式"><a href="#2-训练方式" class="headerlink" title="2.训练方式"></a>2.训练方式</h2><h3 id="Pre-Training"><a href="#Pre-Training" class="headerlink" title="Pre-Training"></a>Pre-Training</h3><p><strong>预训练（ Pre-Training，简写pt）</strong> 是指在大规模无标签或弱标签数据上对模型进行初步训练，使其学习通用的特征表示。预训练的目标是为模型提供一个良好的初始状态，从而在后续的特定任务中通过微调（Fine-Tuning）达到更好的性能。</p>
<p>主要步骤</p>
<ol>
<li><strong>选择模型架构</strong>：选择适合的模型架构，如Transformer、CNN、RNN等。</li>
<li><strong>准备数据</strong>：收集大规模的无标签或弱标签数据集，如文本、图像或其他形式的数据。</li>
<li><strong>设计预训练任务</strong>：设计适合的预训练任务，如语言模型任务（如掩码语言模型、下一个句子预测）、自监督学习任务（如对比学习、自动编码器）等。</li>
<li><strong>设置优化器和损失函数</strong>：选择合适的优化器（如Adam、SGD等）和损失函数（如交叉熵损失、均方误差等）。</li>
<li><strong>进行预训练</strong>：在大规模数据上训练模型，使其学习通用的特征表示。</li>
<li><strong>保存预训练模型</strong>：将训练好的模型参数保存下来，以便后续的微调使用。</li>
</ol>
<p>优点</p>
<ul>
<li><strong>通用性强</strong>：通过在大规模数据上进行训练，模型可以学习到通用的特征表示，适用于多种下游任务。</li>
<li><strong>减少训练时间</strong>：预训练模型可以作为微调的基础，大大减少了从头训练模型所需的时间和计算资源</li>
<li><strong>提高性能</strong>：预训练模型通常在下游任务上表现更好，因为它们已经学习到了丰富的特征表示。</li>
</ul>
<p>缺点</p>
<ul>
<li><strong>计算资源需求高</strong>：预训练通常需要大规模的数据和计算资源，训练时间较长。</li>
<li><strong>数据依赖性强</strong>：预训练的效果依赖于数据的质量和规模，如果数据不足或不够多样化，预训练效果可能不理想。</li>
</ul>
<p>常见预训练任务</p>
<ul>
<li><strong>语言模型任务</strong>：<ul>
<li>掩码语言模型（Masked Language Model, MLM）：如BERT，通过掩盖输入文本中的部分词语，让模型预测这些被掩盖的词语。</li>
<li>自回归语言模型（Autoregressive Language Model）：如GPT，通过预测下一个词语来训练模型。</li>
<li>下一个句子预测（Next Sentence Prediction, NSP）：如BERT，通过预测两个句子是否相邻来训练模型。</li>
</ul>
</li>
<li><strong>自监督学习任务</strong>：<ul>
<li>对比学习（Contrastive Learning）：通过让模型区分相似和不相似的样本对来进行训练。</li>
<li>自动编码器（Autoencoder）：通过让模型重建输入数据来进行训练。</li>
</ul>
</li>
</ul>
<p>总结</p>
<p>预训练（Pre-Training）是深度学习中通过在大规模无标签或弱标签数据上进行初步训练，使模型学习通用特征表示的过程。预训练能够大幅提高模型在下游任务上的性能，减少训练时间和计算资源需求。常见的预训练任务包括语言模型任务和自监督学习任务。通过合理设计预训练任务和选择合适的模型架构，可以获得性能优异的预训练模型，为后续的微调打下坚实基础。</p>
<h3 id="Supervised-Fine-Tuning"><a href="#Supervised-Fine-Tuning" class="headerlink" title="Supervised Fine-Tuning"></a>Supervised Fine-Tuning</h3><p><strong>监督微调（Supervised Fine-Tuning，简写为sft）</strong> 是指在预训练模型的基础上，使用带标签的数据对模型进行进一步训练。通过这种方式，模型可以学习到特定任务的数据分布和特征，从而提高在该任务上的表现。<br><strong>监督微调（Supervised Fine-Tuning）</strong> 是一种在预训练模型的基础上，使用带标签的数据对模型进行进一步训练的方法。它能够高效利用预训练模型的知识，提高新任务的性能，适用于各种分类、回归、序列标注和生成任务。通过合理选择优化器、损失函数和训练策略，可以在较短时间内获得性能优异的微调模型。<br>优点</p>
<ul>
<li><strong>高效利用预训练模型</strong>：能够充分利用预训练模型在大规模数据上学到的知识，提高新任务的性能。</li>
<li><strong>适应新任务</strong>：通过在特定任务的数据上进行训练，使模型能够更好地适应新任务的需求。</li>
<li><strong>减少训练时间</strong>：相比从头训练一个模型，微调预训练模型所需的时间和资源更少。</li>
</ul>
<p>缺点</p>
<ul>
<li><strong>依赖预训练模型</strong>：性能依赖于预训练模型的质量和适用性，如果预训练模型与新任务差异较大，效果可能不理想。</li>
<li><strong>可能需要大量标注数据</strong>：对于一些复杂任务，可能需要大量标注数据来进行有效的微调。</li>
</ul>
<p>适用场景</p>
<ul>
<li><strong>分类任务</strong>：如文本分类、图像分类等。</li>
<li><strong>回归任务</strong>：如预测数值、评分等。</li>
<li><strong>序列标注任务</strong>：如命名实体识别、词性标注等。</li>
<li><strong>生成任务</strong>：如文本生成、图像生成等。</li>
</ul>
<h3 id="Reward-Modeing"><a href="#Reward-Modeing" class="headerlink" title="Reward Modeing"></a>Reward Modeing</h3><p><strong>奖励建模（Reward Modeing）</strong> 是指设计和构建一个奖励函数，该函数能够准确反映代理在特定任务中的表现。奖励函数的设计直接影响到代理的学习效率和最终性能。通过奖励建模，代理可以在环境中通过试错学习（trial-and-error learning）来优化其策略，以最大化累积奖励。</p>
<p>奖励函数设计原则</p>
<ul>
<li><strong>明确性</strong>：奖励函数应明确反映任务目标，避免模糊或不明确的奖励信号。</li>
<li><strong>可达性</strong>：奖励应是可达的，使代理能够通过合理的探索和利用策略获得奖励。</li>
<li><strong>平衡性</strong>：奖励函数应平衡短期和长期目标，避免代理过度关注短期奖励而忽视长期目标。</li>
<li><strong>可调性</strong>：奖励函数应具备可调性，能够根据任务需求进行调整和优化。</li>
</ul>
<p>优点</p>
<ul>
<li><strong>指导代理行为</strong>：通过奖励信号指导代理学习和优化策略，使其在任务中表现更好。</li>
<li><strong>灵活性强</strong>：奖励函数可以根据任务需求进行设计和调整，适应不同的任务和环境。</li>
<li><strong>自动化学习</strong>：代理通过与环境的交互自动学习，无需人工干预。</li>
</ul>
<p>缺点</p>
<ul>
<li><strong>设计复杂</strong>：设计合理的奖励函数可能较为复杂，尤其是在多目标任务中。</li>
<li><strong>探索问题</strong>：代理在探索过程中可能遇到奖励稀疏或延迟的问题，影响学习效率。</li>
<li><strong>可能引发不良行为</strong>：如果奖励函数设计不当，可能引发代理的“不良行为”，如过度优化某一特定奖励而忽视整体目标。</li>
</ul>
<p>适用场景</p>
<ul>
<li><strong>游戏AI</strong>：如AlphaGo、Atari游戏等。</li>
<li><strong>机器人控制</strong>：如机械臂控制、无人驾驶等。</li>
<li><strong>推荐系统</strong>：如个性化推荐、广告投放等。</li>
<li><strong>金融交易</strong>：如股票交易、期货交易等。</li>
</ul>
<p>总结</p>
<p>奖励建模（Reward Modeling）是通过设计和构建奖励函数来指导强化学习代理行为的过程。合理的奖励函数设计能够有效引导代理学习和优化策略，提高任务表现。奖励建模在游戏AI、机器人控制、推荐系统和金融交易等领域有广泛应用。通过明确任务目标、设计合理的奖励函数和使用合适的强化学习算法，可以实现高效的奖励建模和代理训练。</p>
<h3 id="PPO"><a href="#PPO" class="headerlink" title="PPO"></a>PPO</h3><p>Proximal Policy Optimization (PPO) 是一种广泛使用的强化学习算法，因其在策略优化中的稳定性和高效性而受到欢迎。以下是关于 PPO 的主要知识点总结：</p>
<p>PPO 概述</p>
<p>PPO 是由 OpenAI 提出的策略优化算法，属于策略梯度方法的一种。它通过限制策略更新的幅度来保持策略优化的稳定性，避免了策略更新过大导致的性能波动。</p>
<p>核心思想</p>
<p>PPO 的核心思想是通过限制新旧策略之间的变化幅度，确保策略更新在一个较小的范围内，从而提高训练的稳定性和效率。具体来说，PPO 通过引入一个剪切（clip）操作，限制策略比率的变化。</p>
<p>主要特点</p>
<ol>
<li><strong>限制策略更新幅度</strong>：PPO 通过限制新旧策略比率（ratio）的变化，避免策略更新过大导致的不稳定。</li>
<li><strong>简单易实现</strong>：相比于其他复杂的策略优化方法，PPO 的实现相对简单，易于在实际应用中使用。</li>
<li><strong>高效性</strong>：PPO 在许多任务上表现出色，具有较高的样本效率和稳定性。</li>
</ol>
<h4 id="算法细节"><a href="#算法细节" class="headerlink" title="算法细节"></a>算法细节</h4><p>PPO 主要有两种变体：PPO-Clip 和 PPO-Penalty。</p>
<ol>
<li>PPO-Clip</li>
</ol>
<p>PPO-Clip 通过直接对策略比率进行剪切操作，限制策略更新的幅度。其目标函数如下：<br>LCLIP(θ)&#x3D;E^t[min⁡(rt(θ)A^t,clip(rt(θ),1−ϵ,1+ϵ)A^t)]<em>L<strong>C</strong>L<strong>I</strong>P</em>(<em>θ</em>)&#x3D;E^<em>t</em>​[min(<em>r**t</em>​(<em>θ</em>)<em>A</em>^<em>t</em>​,clip(<em>r**t</em>​(<em>θ</em>),1−<em>ϵ</em>,1+<em>ϵ</em>)<em>A</em>^<em>t</em>​)]</p>
<p>其中：</p>
<ul>
<li>rt(θ)<em>r**t</em>(<em>θ</em>) 是新旧策略的比率：rt(θ)&#x3D;πθ(at∣st)πθold(at∣st)<em>r**t</em>(<em>θ</em>)&#x3D;<em>π**θ</em>old(<em>a**t</em>∣<em>s**t</em>)<em>π**θ</em>(<em>a**t</em>∣<em>s**t</em>)</li>
<li>A^t<em>A</em>^<em>t</em> 是优势函数估计。</li>
<li>ϵ<em>ϵ</em> 是剪切范围的超参数，通常取 0.1 或 0.2。</li>
</ul>
<ol>
<li>PPO-Penalty</li>
</ol>
<p>PPO-Penalty 通过在目标函数中加入 KL 散度惩罚项，限制新旧策略之间的差异。其目标函数如下：<br>LKL(θ)&#x3D;E^t[rt(θ)A^t−βKL[πθold(⋅∣st)∣∣πθ(⋅∣st)]]<em>L<strong>K</strong>L</em>(<em>θ</em>)&#x3D;E^<em>t</em>​[<em>r**t</em>​(<em>θ</em>)<em>A</em>^<em>t</em>​−<em>β</em>KL[<em>π**θ</em>old​​(⋅∣<em>s**t</em>​)∣∣<em>π**θ</em>​(⋅∣<em>s**t</em>​)]]</p>
<p>其中：</p>
<ul>
<li>β<em>β</em> 是 KL 惩罚项的系数，控制新旧策略之间的差异。</li>
</ul>
<p>训练过程</p>
<p>PPO 的训练过程包括以下几个步骤：</p>
<ol>
<li><strong>收集样本</strong>：使用当前策略在环境中进行采样，收集状态、动作、奖励等数据。</li>
<li><strong>计算优势函数</strong>：使用时间差分（TD）方法或广义优势估计（GAE）计算优势函数。</li>
<li><strong>更新策略</strong>：使用 PPO 的目标函数（PPO-Clip 或 PPO-Penalty）进行策略更新，通常采用小批量梯度下降（SGD）或 Adam 优化器。</li>
<li><strong>重复以上步骤</strong>：不断重复以上步骤，直到策略收敛或达到预定的训练轮数。</li>
</ol>
<p>优势与劣势</p>
<p>优势</p>
<ul>
<li><strong>稳定性高</strong>：通过限制策略更新幅度，PPO 提高了训练的稳定性。</li>
<li><strong>实现简单</strong>：相比于其他复杂的策略优化方法，PPO 的实现相对简单，易于在实际应用中使用。</li>
<li><strong>性能优异</strong>：PPO 在许多任务上表现出色，具有较高的样本效率和稳定性。</li>
</ul>
<p>劣势</p>
<ul>
<li><strong>超参数敏感</strong>：PPO 的性能对超参数（如剪切范围、KL 惩罚系数等）较为敏感，需要进行仔细调参。</li>
<li><strong>计算开销大</strong>：由于需要频繁进行策略更新，PPO 的计算开销较大。</li>
</ul>
<p>总结</p>
<p>PPO 是一种高效、稳定的策略优化方法，通过限制策略更新幅度来提高训练的稳定性。其实现简单，适用于多种强化学习任务。在实际应用中，需要根据具体任务进行超参数调优，以获得最佳性能。</p>
<h3 id="DPO"><a href="#DPO" class="headerlink" title="DPO"></a>DPO</h3><p>Direct Preference Optimization (DPO) 是一种强化学习算法，主要用于直接优化策略以满足用户的偏好。与传统的强化学习算法不同，DPO 直接利用用户的偏好反馈来指导策略优化。以下是关于 DPO 的主要知识点总结：</p>
<p>DPO 概述</p>
<p>DPO 是一种基于偏好反馈的策略优化方法，通过直接利用用户的偏好信息来优化策略。与通过奖励信号进行间接优化的方法不同，DPO 可以更直接、更高效地调整策略以满足用户的偏好。</p>
<p>核心思想</p>
<p>DPO 的核心思想是通过比较不同策略在用户偏好上的表现，直接优化策略以最大化用户的满意度。具体来说，DPO 通过收集用户对不同策略的偏好反馈，构建偏好模型，并利用该模型指导策略优化。</p>
<p>主要特点</p>
<ol>
<li><strong>直接优化用户偏好</strong>：DPO 直接利用用户的偏好反馈进行策略优化，避免了间接奖励信号带来的不确定性。</li>
<li><strong>高效性</strong>：通过直接优化用户偏好，DPO 可以更高效地调整策略，减少了训练时间和样本需求。</li>
<li><strong>用户导向</strong>：DPO 以用户的偏好为导向，能够更好地满足用户需求，提高策略的实际应用价值。</li>
</ol>
<p>算法细节</p>
<p>DPO 的训练过程主要包括以下几个步骤：</p>
<ol>
<li><strong>收集偏好反馈</strong>：通过用户实验或模拟环境，收集用户对不同策略的偏好反馈。</li>
<li><strong>构建偏好模型</strong>：使用收集到的偏好反馈数据，构建一个偏好模型，该模型能够预测用户对不同策略的偏好程度。</li>
<li><strong>优化策略</strong>：利用偏好模型指导策略优化，选择能够最大化用户偏好的策略进行更新。</li>
<li><strong>迭代优化</strong>：不断重复以上步骤，逐步优化策略，直到达到预定的性能或用户满意度。</li>
</ol>
<p>具体实现</p>
<p>DPO 的具体实现可以分为以下几个部分：</p>
<ol>
<li>偏好反馈收集</li>
</ol>
<ul>
<li><strong>用户实验</strong>：通过实际用户实验，收集用户对不同策略的偏好反馈。</li>
<li><strong>模拟环境</strong>：在模拟环境中，使用预定义的偏好规则，模拟用户对不同策略的偏好反馈。</li>
</ul>
<ol>
<li>偏好模型构建</li>
</ol>
<ul>
<li><strong>模型选择</strong>：选择合适的模型（如线性模型、神经网络等）来构建偏好模型。</li>
<li><strong>模型训练</strong>：使用收集到的偏好反馈数据，训练偏好模型，使其能够准确预测用户的偏好。</li>
</ul>
<ol>
<li>策略优化</li>
</ol>
<ul>
<li><strong>优化目标</strong>：选择一个优化目标（如最大化用户满意度）来指导策略优化。</li>
<li><strong>优化方法</strong>：使用梯度下降、进化算法等优化方法，调整策略参数，使其能够最大化用户偏好。</li>
</ul>
<p>优势与劣势</p>
<p>优势</p>
<ul>
<li><strong>直接优化用户偏好</strong>：DPO 直接利用用户的偏好反馈进行策略优化，能够更好地满足用户需求。</li>
<li><strong>高效性</strong>：通过直接优化用户偏好，DPO 可以更高效地调整策略，减少了训练时间和样本需求。</li>
<li><strong>用户导向</strong>：DPO 以用户的偏好为导向，能够提高策略的实际应用价值。</li>
</ul>
<p>劣势</p>
<ul>
<li><strong>偏好反馈收集困难</strong>：收集用户的偏好反馈可能需要大量的用户实验或模拟环境，成本较高。</li>
<li><strong>模型复杂度高</strong>：构建准确的偏好模型可能需要复杂的模型和大量的数据，计算开销较大。</li>
<li><strong>偏好变化</strong>：用户的偏好可能随时间变化，需要不断更新偏好模型和策略。</li>
</ul>
<p>总结</p>
<p>DPO 是一种基于偏好反馈的策略优化方法，通过直接利用用户的偏好信息来优化策略。其主要优势在于能够更好地满足用户需求，提高策略的实际应用价值。然而，DPO 在偏好反馈收集和模型构建方面面临一定的挑战。</p>
<h3 id="KTO"><a href="#KTO" class="headerlink" title="KTO"></a>KTO</h3><p>KTO（Knowledge Transfer Optimization）是一种用于强化学习和机器学习领域的技术，旨在通过知识转移来优化模型的性能。以下是关于 KTO 的主要知识点总结：</p>
<p>KTO 概述</p>
<p>知识转移优化（KTO）是一种通过将已有模型或任务中的知识转移到新的模型或任务中，以提高学习效率和性能的方法。KTO 在多任务学习、迁移学习和元学习等领域中有广泛的应用。</p>
<p>核心思想</p>
<p>KTO 的核心思想是利用已有模型或任务中的知识，帮助新的模型或任务更快、更好地学习。通过共享和转移知识，可以减少训练时间，提高模型的泛化能力和性能。</p>
<p>主要特点</p>
<ol>
<li><strong>知识共享</strong>：通过知识转移，可以在不同模型或任务之间共享知识，避免重复学习。</li>
<li><strong>提高效率</strong>：利用已有知识，可以加速新模型或任务的学习过程，提高学习效率。</li>
<li><strong>增强泛化能力</strong>：通过知识转移，可以提高模型的泛化能力，使其在新任务中表现更好。</li>
</ol>
<h4 id="算法细节-1"><a href="#算法细节-1" class="headerlink" title="算法细节"></a>算法细节</h4><p>KTO 的实现通常包括以下几个步骤：</p>
<ol>
<li><strong>知识提取</strong>：从已有模型或任务中提取有用的知识。</li>
<li><strong>知识转移</strong>：将提取的知识转移到新的模型或任务中。</li>
<li><strong>知识整合</strong>：在新模型或任务中整合转移的知识，进行优化和调整。</li>
</ol>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>KTO 的具体实现可以分为以下几个部分：</p>
<ol>
<li>知识提取</li>
</ol>
<ul>
<li><strong>模型参数</strong>：从已有模型中提取参数（如权重、偏置等），作为知识转移的基础。</li>
<li><strong>特征表示</strong>：从已有任务中提取特征表示，作为新任务的初始表示。</li>
<li><strong>策略和价值函数</strong>：在强化学习中，从已有任务中提取策略和价值函数，作为新任务的初始策略和价值函数。</li>
</ul>
<ol>
<li>知识转移</li>
</ol>
<ul>
<li><strong>参数初始化</strong>：使用提取的模型参数初始化新模型的参数。</li>
<li><strong>特征共享</strong>：在多任务学习中，共享提取的特征表示，作为新任务的输入。</li>
<li><strong>策略融合</strong>：在强化学习中，融合提取的策略和价值函数，作为新任务的初始策略和价值函数。</li>
</ul>
<ol>
<li>知识整合</li>
</ol>
<ul>
<li><strong>微调</strong>：对新模型进行微调，以适应新任务的数据和目标。</li>
<li><strong>联合训练</strong>：在多任务学习中，进行联合训练，优化共享的特征表示和任务特定的参数。</li>
<li><strong>自适应调整</strong>：在迁移学习中，自适应调整转移的知识，以提高新任务的性能。</li>
</ul>
<p>优势与劣势</p>
<p>优势</p>
<ul>
<li><strong>提高学习效率</strong>：通过知识转移，可以加速新模型或任务的学习过程，提高学习效率。</li>
<li><strong>减少数据需求</strong>：利用已有知识，可以减少新任务对大量数据的需求。</li>
<li><strong>增强泛化能力</strong>：通过知识转移，可以提高模型的泛化能力，使其在新任务中表现更好。</li>
</ul>
<p>劣势</p>
<ul>
<li><strong>知识不兼容</strong>：不同任务之间的知识可能不完全兼容，导致知识转移的效果不理想。</li>
<li><strong>计算开销大</strong>：知识提取和转移过程可能需要大量的计算资源和时间。</li>
<li><strong>模型复杂度高</strong>：在多任务学习和迁移学习中，模型的复杂度可能较高，需要进行复杂的优化和调整。</li>
</ul>
<p>应用场景</p>
<ol>
<li><strong>多任务学习</strong>：在多个相关任务之间共享和转移知识，提高整体学习效率和性能。</li>
<li><strong>迁移学习</strong>：将已有任务中的知识转移到新的任务中，减少新任务的训练时间和数据需求。</li>
<li><strong>元学习</strong>：通过学习如何学习，利用已有知识加速新任务的学习过程。</li>
</ol>
<p>总结</p>
<p>KTO 是一种通过知识转移来优化模型性能的方法，具有提高学习效率、减少数据需求和增强泛化能力的优势。然而，KTO 在知识兼容性、计算开销和模型复杂度方面也面临一定的挑战。在实际应用中，需要根据具体任务和场景选择合适的知识转移方法，以获得最佳效果。</p>
<h2 id="微调参数"><a href="#微调参数" class="headerlink" title="微调参数"></a>微调参数</h2><h3 id="通用参数"><a href="#通用参数" class="headerlink" title="通用参数"></a>通用参数</h3><h4 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h4><p><strong>学习率（Learning Rate）</strong> 是梯度下降算法中的一个超参数，用于控制每次参数更新的步长大小。它决定了模型在每次迭代中更新参数的速度。</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul>
<li><strong>步长控制</strong>：学习率决定了每次参数更新的步长大小。步长太大可能导致训练不稳定，步长太小则可能导致收敛速度慢。</li>
<li><strong>收敛速度</strong>：适当的学习率可以加快模型的收敛速度，帮助模型更快达到最优解。</li>
</ul>
<h5 id="设置方法"><a href="#设置方法" class="headerlink" title="设置方法"></a>设置方法</h5><ul>
<li><strong>经验法则</strong>：通常从一个较小的值开始（如0.001），然后根据训练效果进行调整。</li>
<li><strong>学习率调度</strong>：使用学习率调度器（如StepLR、ExponentialLR等）动态调整学习率。</li>
<li><strong>网格搜索</strong>：通过网格搜索或随机搜索找到最优的学习率。</li>
</ul>
<h4 id="学习率调节器"><a href="#学习率调节器" class="headerlink" title="学习率调节器"></a>学习率调节器</h4><h5 id="cosine"><a href="#cosine" class="headerlink" title="cosine"></a>cosine</h5><p><strong>余弦退火（Cosine Annealing）</strong> 是一种动态学习率调度策略，它通过余弦函数来逐步减小学习率，使得学习率在训练过程中有一个平滑的下降过程。这种方法可以帮助模型在训练的后期更好地收敛，避免过大的学习率导致训练不稳定。</p>
<h6 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h6><p>余弦退火学习率的公式如下：ηt&#x3D;ηmin⁡+12(ηmax⁡−ηmin⁡)(1+cos⁡(TcurTmaxπ))<em>η**t</em>&#x3D;<em>η</em>min+21(<em>η</em>max−<em>η</em>min)(1+cos(<em>T<strong>ma</strong>x<strong>T</strong>c<strong>u</strong>r**π</em>))<br>其中：</p>
<ul>
<li>ηt<em>η**t</em> 是当前的学习率。</li>
<li>ηmin⁡<em>η</em>min 是最小学习率。</li>
<li>ηmax⁡<em>η</em>max 是初始学习率。</li>
<li>Tcur<em>T<strong>c</strong>u**r</em> 是当前的训练步数。</li>
<li>Tmax<em>T<strong>ma</strong>x</em> 是总的训练步数。</li>
</ul>
<h6 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h6><ol>
<li><strong>平滑下降</strong>：通过余弦函数平滑地减小学习率，避免了学习率骤降导致的训练不稳定。</li>
<li><strong>防止过拟合</strong>：在训练后期使用较小的学习率，有助于模型更好地收敛，减少过拟合的风险。</li>
<li><strong>适应性强</strong>：余弦退火可以适应不同的训练阶段，动态调整学习率，提高模型性能。</li>
</ol>
<h6 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h6><ol>
<li><strong>初始学习率和最小学习率的选择</strong>：初始学习率和最小学习率的选择需要根据具体任务和数据集进行调整。通常，初始学习率可以设置为一个较大的值（如0.01），最小学习率设置为一个较小的值（如0.001）。</li>
<li><strong>训练步数的设置</strong>：总的训练步数 Tmax<em>T<strong>ma</strong>x</em> 的设置需要根据训练数据集的大小和模型的复杂度进行调整。通常，可以设置为训练的总epoch数。</li>
</ol>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>余弦退火是一种有效的动态学习率调度策略，可以帮助模型在训练过程中更好地调整学习率，从而提高训练效果和模型性能。</p>
<h5 id="linear"><a href="#linear" class="headerlink" title="linear"></a>linear</h5><p><strong>线性学习率调节（Linear Learning Rate Schedule）</strong> 是一种简单且常用的学习率调度策略。它通过线性函数逐步减小学习率，使得学习率在训练过程中以线性的方式下降。这种方法在某些情况下可以帮助模型更稳定地收敛，特别是在训练的初期和中期。</p>
<h6 id="公式-1"><a href="#公式-1" class="headerlink" title="公式"></a>公式</h6><p>线性学习率调节的公式如下：ηt&#x3D;ηmax⁡−(TcurTmax)(ηmax⁡−ηmin⁡)<em>η**t</em>&#x3D;<em>η</em>max−(<em>T<strong>ma</strong>x<strong>T</strong>c<strong>u</strong>r</em>)(<em>η</em>max−<em>η</em>min)<br>其中：</p>
<ul>
<li>ηt<em>η**t</em> 是当前的学习率。</li>
<li>ηmin⁡<em>η</em>min 是最小学习率。</li>
<li>ηmax⁡<em>η</em>max 是初始学习率。</li>
<li>Tcur<em>T<strong>c</strong>u**r</em> 是当前的训练步数。</li>
<li>Tmax<em>T<strong>ma</strong>x</em> 是总的训练步数。</li>
</ul>
<h6 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h6><ol>
<li><strong>简单易用</strong>：线性学习率调节的实现简单，不需要复杂的函数计算。</li>
<li><strong>稳定性</strong>：线性下降的学习率可以使训练过程更加稳定，避免了学习率骤降或骤升带来的不稳定性。</li>
<li><strong>适应性</strong>：对于一些任务，线性调节可以提供足够的灵活性，使模型在训练过程中逐步收敛。</li>
</ol>
<h6 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h6><ol>
<li><strong>初始学习率和最小学习率的选择</strong>：初始学习率和最小学习率的选择需要根据具体任务和数据集进行调整。通常，初始学习率可以设置为一个较大的值（如0.01），最小学习率设置为一个较小的值（如0.001）。</li>
<li><strong>训练步数的设置</strong>：总的训练步数 Tmax<em>T<strong>ma</strong>x</em> 的设置需要根据训练数据集的大小和模型的复杂度进行调整。通常，可以设置为训练的总epoch数。</li>
<li><strong>线性下降的局限性</strong>：在某些情况下，线性下降的学习率可能不足以捕捉训练过程中的复杂变化，此时可以考虑其他更复杂的学习率调度策略，如余弦退火或指数衰减。</li>
</ol>
<h6 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h6><p>线性学习率调节是一种简单且有效的学习率调度策略，可以帮助模型在训练过程中逐步减小学习率，从而提高训练效果和模型性能。</p>
<h5 id="cosine-with-restarts"><a href="#cosine-with-restarts" class="headerlink" title="cosine_with_restarts"></a>cosine_with_restarts</h5><p><strong>余弦退火带重启（Cosine Annealing with Warm Restarts）</strong> 是一种改进的余弦退火学习率调度策略，它在余弦退火的基础上增加了周期性重启机制。每当学习率下降到一个较低的值时，它会重新上升到初始学习率，从而进行新的周期。这种方法可以帮助模型在训练过程中跳出局部最优解，进一步提高模型性能。</p>
<h6 id="公式-2"><a href="#公式-2" class="headerlink" title="公式"></a>公式</h6><p>余弦退火带重启的公式如下：ηt&#x3D;ηmin⁡+12(ηmax⁡−ηmin⁡)(1+cos⁡(TcurTiπ))<em>η**t</em>&#x3D;<em>η</em>min+21(<em>η</em>max−<em>η</em>min)(1+cos(<em>T<strong>i</strong>T<strong>c</strong>u<strong>r</strong>π</em>))<br>其中：</p>
<ul>
<li>ηt<em>η**t</em> 是当前的学习率。</li>
<li>ηmin⁡<em>η</em>min 是最小学习率。</li>
<li>ηmax⁡<em>η</em>max 是初始学习率。</li>
<li>Tcur<em>T<strong>c</strong>u**r</em> 是当前的训练步数。</li>
<li>Ti<em>T**i</em> 是当前周期的总步数。</li>
</ul>
<p>每当 Tcur<em>T<strong>c</strong>u**r</em> 达到 Ti<em>T**i</em> 时，学习率会重置，并开始新的周期。新的周期总步数 Ti+1<em>T**i</em>+1 通常会增加，例如： Ti+1&#x3D;Ti×factor<em>T**i</em>+1&#x3D;<em>T**i</em>×factor，其中 factorfactor 是一个大于1的常数。</p>
<h6 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a>优势</h6><ol>
<li><strong>跳出局部最优</strong>：重启机制可以帮助模型跳出局部最优解，探索新的解空间。</li>
<li><strong>提高性能</strong>：在某些任务中，周期性重启可以显著提高模型性能。</li>
<li><strong>灵活性</strong>：可以根据需要调整周期长度和重启频率，灵活适应不同的训练任务。</li>
</ol>
<h6 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h6><ol>
<li><strong>参数选择</strong>：需要根据具体任务和数据集选择合适的 <code>T_0</code> 和 <code>T_mult</code> 参数。通常可以从较小的值开始，然后根据训练效果进行调整。</li>
<li><strong>训练时间</strong>：重启机制可能会增加训练时间，因为每次重启后学习率又回到了较高的值，模型需要更多的时间进行收敛。</li>
</ol>
<h6 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h6><p>余弦退火带重启是一种有效的学习率调度策略，通过周期性重启学习率，可以帮助模型跳出局部最优解，提高训练效果和模型性能。</p>
<h5 id="polynomial"><a href="#polynomial" class="headerlink" title="polynomial"></a>polynomial</h5><p><strong>多项式学习率调节（Polynomial Learning Rate Schedule）</strong> 是一种灵活的学习率调度策略，它通过多项式函数逐步减小学习率，使得学习率在训练过程中以多项式的方式下降。这种方法可以根据具体的多项式阶数和衰减指数来调整学习率的下降速度，从而适应不同的训练需求。</p>
<h6 id="公式-3"><a href="#公式-3" class="headerlink" title="公式"></a>公式</h6><p>多项式学习率调节的公式如下：ηt&#x3D;ηmax⁡(1−TcurTmax)p<em>η**t</em>&#x3D;<em>η</em>max(1−<em>T<strong>ma</strong>x<strong>T</strong>c<strong>u</strong>r</em>)<em>p</em><br>其中：</p>
<ul>
<li>ηt<em>η**t</em> 是当前的学习率。</li>
<li>ηmax⁡<em>η</em>max 是初始学习率。</li>
<li>Tcur<em>T<strong>c</strong>u**r</em> 是当前的训练步数。</li>
<li>Tmax<em>T<strong>ma</strong>x</em> 是总的训练步数。</li>
<li>p<em>p</em> 是多项式的阶数（衰减指数），决定了学习率下降的速度。</li>
</ul>
<h6 id="优势-3"><a href="#优势-3" class="headerlink" title="优势"></a>优势</h6><ol>
<li><strong>灵活性</strong>：可以通过调整多项式的阶数（衰减指数）来控制学习率下降的速度，适应不同的训练任务。</li>
<li><strong>平滑下降</strong>：多项式函数可以提供平滑的学习率下降曲线，避免了学习率骤降带来的不稳定性。</li>
<li><strong>适应性强</strong>：适用于各种不同的训练任务和数据集。</li>
</ol>
<h6 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h6><ol>
<li><strong>参数选择</strong>：需要根据具体任务和数据集选择合适的初始学习率和多项式阶数。通常可以从较小的阶数开始，然后根据训练效果进行调整。</li>
<li><strong>训练步数的设置</strong>：总的训练步数 Tmax<em>T<strong>ma</strong>x</em> 的设置需要根据训练数据集的大小和模型的复杂度进行调整。通常，可以设置为训练的总epoch数。</li>
</ol>
<h6 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h6><p>多项式学习率调节是一种灵活且有效的学习率调度策略，可以通过调整多项式的阶数来控制学习率的下降速度，从而提高训练效果和模型性能。</p>
<h5 id="constant"><a href="#constant" class="headerlink" title="constant"></a>constant</h5><p><strong>常数学习率调节（Constant Learning Rate Schedule）</strong> 是一种最简单的学习率调度策略。在这种策略中，学习率在整个训练过程中保持不变。这种方法适用于一些简单的任务或当你确定一个固定的学习率已经足够有效时。</p>
<h6 id="公式-4"><a href="#公式-4" class="headerlink" title="公式"></a>公式</h6><p>常数学习率调节的公式非常简单：ηt&#x3D;ηconstant<em>η**t</em>&#x3D;<em>η</em>constant<br>其中：</p>
<ul>
<li>ηt<em>η**t</em> 是当前的学习率。</li>
<li>ηconstant<em>η</em>constant 是一个固定的学习率。</li>
</ul>
<h6 id="优势-4"><a href="#优势-4" class="headerlink" title="优势"></a>优势</h6><ol>
<li><strong>简单易用</strong>：实现和使用非常简单，不需要额外的学习率调度器。</li>
<li><strong>稳定性</strong>：对于一些简单任务或小规模数据集，固定学习率可能已经足够有效，且训练过程稳定。</li>
<li><strong>一致性</strong>：在整个训练过程中，学习率保持一致，有助于理解和调试模型。</li>
</ol>
<h6 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h6><ol>
<li><strong>适用范围有限</strong>：常数学习率调节适用于一些简单任务或小规模数据集，对于复杂任务或大规模数据集，可能需要更复杂的学习率调度策略。</li>
<li><strong>学习率选择</strong>：选择合适的固定学习率非常重要。学习率过大会导致训练不稳定，学习率过小则可能导致训练收敛速度慢或无法收敛。</li>
</ol>
<h6 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h6><p>常数学习率调节是一种最简单的学习率调度策略，适用于一些简单任务或当你确定一个固定的学习率已经足够有效时。</p>
<h5 id="constant-with-warmup"><a href="#constant-with-warmup" class="headerlink" title="constant_with_warmup"></a>constant_with_warmup</h5><p><strong>常数学习率带预热（Constant Learning Rate with Warmup）</strong> 是一种结合了常数学习率和预热（warmup）阶段的学习率调度策略。在这种策略中，学习率在训练初期逐步增加，达到预热阶段结束时的目标学习率，然后在整个训练过程中保持不变。这种方法可以帮助模型在训练初期稳定收敛，避免大步长的学习率导致的不稳定性。</p>
<h6 id="公式-5"><a href="#公式-5" class="headerlink" title="公式"></a>公式</h6><p>常数学习率带预热的公式可以分为两个阶段：</p>
<ol>
<li><strong>预热阶段</strong>：学习率从零逐步增加到目标学习率。</li>
<li><strong>常数阶段</strong>：学习率保持在目标学习率不变。</li>
</ol>
<p>预热阶段的学习率公式通常为线性增长：ηt&#x3D;ηmax⁡⋅tTwarmup<em>η**t</em>&#x3D;<em>η</em>max⋅<em>T</em>warmup<em>t</em><br>其中：</p>
<ul>
<li>ηt<em>η**t</em> 是当前的学习率。</li>
<li>ηmax⁡<em>η</em>max 是预热结束时的目标学习率。</li>
<li>t<em>t</em> 是当前的训练步数。</li>
<li>Twarmup<em>T</em>warmup 是预热阶段的总步数。</li>
</ul>
<p>预热阶段结束后的学习率公式为：ηt&#x3D;ηmax⁡<em>η**t</em>&#x3D;<em>η</em>max</p>
<h6 id="优势-5"><a href="#优势-5" class="headerlink" title="优势"></a>优势</h6><ol>
<li><strong>稳定收敛</strong>：预热阶段可以帮助模型在训练初期稳定收敛，避免大步长的学习率导致的不稳定性。</li>
<li><strong>简单易用</strong>：实现和使用较为简单，适用于各种不同的训练任务。</li>
<li><strong>适应性强</strong>：适用于各种不同的训练任务和数据集，特别是在训练初期需要稳定的收敛过程时。</li>
</ol>
<h6 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h6><ol>
<li><strong>预热阶段的设置</strong>：需要根据具体任务和数据集选择合适的预热阶段总步数 Twarmup<em>T</em>warmup。通常可以从较小的值开始，然后根据训练效果进行调整。</li>
<li><strong>目标学习率的选择</strong>：选择合适的目标学习率非常重要。学习率过大会导致训练不稳定，学习率过小则可能导致训练收敛速度慢或无法收敛。</li>
</ol>
<h6 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h6><p>常数学习率带预热是一种结合了常数学习率和预热阶段的学习率调度策略，通过预热阶段的逐步增加学习率，可以帮助模型在训练初期稳定收敛。</p>
<h5 id="inverse-sqrt"><a href="#inverse-sqrt" class="headerlink" title="inverse_sqrt"></a>inverse_sqrt</h5><p><strong>逆平方根学习率调节（Inverse Square Root Learning Rate Schedule）</strong> 学习率调节策略是一种基于逆平方根函数的学习率调度方法。这种方法在训练初期使用较高的学习率，然后随着训练步数的增加，学习率按照逆平方根函数逐步减小。这种策略可以帮助模型在训练初期快速收敛，同时在后期保持稳定的训练过程。</p>
<h6 id="公式-6"><a href="#公式-6" class="headerlink" title="公式"></a>公式</h6><p>逆平方根学习率调节的公式如下：ηt&#x3D;ηmaxt<em>η**t</em>&#x3D;<em>t**η</em>max<br>其中：</p>
<ul>
<li>ηt<em>η**t</em> 是当前的学习率。</li>
<li>ηmax<em>η</em>max 是初始学习率。</li>
<li>t<em>t</em> 是当前的训练步数。</li>
</ul>
<p>为了避免在训练初期学习率过大，通常会在公式中加入一个平滑项：ηt&#x3D;ηmax1+t&#x2F;Twarmup<em>η**t</em>&#x3D;1+<em>t</em>&#x2F;<em>T</em>warmup<em>η</em>max<br>其中：</p>
<ul>
<li>Twarmup<em>T</em>warmup 是预热阶段的总步数。</li>
</ul>
<h6 id="优势-6"><a href="#优势-6" class="headerlink" title="优势"></a>优势</h6><ol>
<li><strong>快速收敛</strong>：在训练初期使用较高的学习率，可以帮助模型快速收敛。</li>
<li><strong>稳定性</strong>：随着训练步数的增加，学习率逐步减小，保持训练过程的稳定性。</li>
<li><strong>适应性强</strong>：适用于各种不同的训练任务和数据集，特别是在训练初期需要快速收敛的情况下。</li>
</ol>
<h6 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a>注意事项</h6><ol>
<li><strong>预热阶段的设置</strong>：需要根据具体任务和数据集选择合适的预热阶段总步数 Twarmup<em>T</em>warmup 。通常可以从较小的值开始，然后根据训练效果进行调整。</li>
<li><strong>初始学习率的选择</strong>：选择合适的初始学习率非常重要。学习率过大会导致训练不稳定，学习率过小则可能导致训练收敛速度慢或无法收敛。</li>
</ol>
<h6 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h6><p>逆平方根学习率调节是一种基于逆平方根函数的学习率调度策略，通过在训练初期使用较高的学习率，然后逐步减小学习率，可以帮助模型快速收敛并保持训练过程的稳定性。</p>
<h5 id="reduce-lr-on-plateau"><a href="#reduce-lr-on-plateau" class="headerlink" title="reduce_lr_on_plateau"></a>reduce_lr_on_plateau</h5><p><strong>基于性能指标的学习率减少（Reduce Learning Rate on Plateau）</strong> 是一种基于模型性能指标（如验证损失或准确率）动态调整学习率的策略。当模型在一段时间内性能没有显著提升时，学习率会自动减少。这种方法可以帮助模型在训练过程中更好地适应不同阶段的学习需求，避免陷入局部最优解。</p>
<h6 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h6><p><code>reduce_lr_on_plateau</code> 的机制如下：</p>
<ol>
<li><strong>监控指标</strong>：选择一个需要监控的性能指标（如验证损失或准确率）。</li>
<li><strong>耐心期</strong>：设置一个耐心期（patience），即在多少个周期内如果性能指标没有显著改善，则减少学习率。</li>
<li><strong>减少因子</strong>：设置一个减少因子（factor），即每次减少学习率时，学习率乘以这个因子。</li>
<li><strong>最小学习率</strong>：设置一个最小学习率（min_lr），即学习率不能低于这个值。</li>
</ol>
<h6 id="优势-7"><a href="#优势-7" class="headerlink" title="优势"></a>优势</h6><ol>
<li><strong>自动调整</strong>：无需手动调整学习率，模型可以根据性能指标自动调整学习率。</li>
<li><strong>适应性强</strong>：适用于各种不同的训练任务和数据集，特别是在训练过程中性能指标波动较大的情况下。</li>
<li><strong>提高稳定性</strong>：在性能指标没有显著改善时减少学习率，可以帮助模型跳出局部最优解，提高训练的稳定性和效果。</li>
</ol>
<h6 id="注意事项-7"><a href="#注意事项-7" class="headerlink" title="注意事项"></a>注意事项</h6><ol>
<li><strong>监控指标的选择</strong>：选择合适的监控指标非常重要，通常选择验证损失或验证准确率。</li>
<li><strong>耐心期的设置</strong>：耐心期（patience）应该根据具体任务和数据集进行调整，过短可能导致频繁调整学习率，过长则可能延迟优化过程。</li>
<li><strong>减少因子的选择</strong>：减少因子（factor）通常设置为一个小于1的值，如0.1，表示每次减少学习率时，学习率乘以0.1。</li>
</ol>
<h6 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h6><p><code>reduce_lr_on_plateau</code> 是一种基于模型性能指标动态调整学习率的策略，通过在性能指标没有显著改善时减少学习率，可以帮助模型更好地适应不同阶段的学习需求，提高训练效果。</p>
<h5 id="cosine-with-min-lr"><a href="#cosine-with-min-lr" class="headerlink" title="cosine_with_min_lr"></a>cosine_with_min_lr</h5><p><strong>余弦退火学习率调节（Cosine Annealing with Minimum Learning Rate）</strong> 是一种基于余弦函数的学习率调度策略，结合了余弦退火（Cosine Annealing）和最小学习率（Minimum Learning Rate）的概念。在这种策略中，学习率在训练过程中按照余弦函数的方式逐渐减小，并且不会低于设定的最小学习率。这种方法可以帮助模型在训练后期保持稳定的学习率，从而提高模型的泛化能力。</p>
<h6 id="公式-7"><a href="#公式-7" class="headerlink" title="公式"></a>公式</h6><p>余弦退火学习率调节的公式如下：ηt&#x3D;ηmin+12(ηmax−ηmin)(1+cos⁡(tTmaxπ))<em>η**t</em>&#x3D;<em>η</em>min+21(<em>η</em>max−<em>η</em>min)(1+cos(<em>T</em>max<em>t**π</em>))</p>
<p>其中：</p>
<ul>
<li>ηt<em>η**t</em> 是当前的学习率。</li>
<li>ηmax<em>η</em>max 是初始学习率。</li>
<li>ηmin<em>η</em>min 是最小学习率。</li>
<li>t<em>t</em> 是当前的训练步数。</li>
<li>Tmax<em>T</em>max 是总的训练步数。</li>
</ul>
<h6 id="优势-8"><a href="#优势-8" class="headerlink" title="优势"></a>优势</h6><ol>
<li><strong>平滑调整</strong>：学习率按照余弦函数平滑调整，避免了突变带来的不稳定性。</li>
<li><strong>防止过小</strong>：设定最小学习率，确保学习率不会降得过低，从而保持模型的学习能力。</li>
<li><strong>适应性强</strong>：适用于各种不同的训练任务和数据集，特别是在训练后期需要稳定学习率的情况下。</li>
</ol>
<h6 id="注意事项-8"><a href="#注意事项-8" class="headerlink" title="注意事项"></a>注意事项</h6><ol>
<li><strong>总步数的设置</strong>：总步数 Tmax<em>T</em>max 应该根据具体任务和数据集进行调整，通常设置为训练的总步数或一个周期的步数。</li>
<li><strong>初始和最小学习率的选择</strong>：选择合适的初始学习率和最小学习率非常重要。初始学习率过大会导致训练不稳定，过小则可能导致训练收敛速度慢或无法收敛。最小学习率过小可能导致模型停止学习，过大则可能影响模型的最终性能。</li>
</ol>
<h6 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h6><p><code>cosine_with_min_lr</code> 是一种结合了余弦退火和最小学习率的学习率调度策略，通过平滑调整学习率并设定最小学习率，可以帮助模型在训练后期保持稳定的学习率，提高模型的泛化能力</p>
<h5 id="warmup-stable-decay"><a href="#warmup-stable-decay" class="headerlink" title="warmup_stable_decay"></a>warmup_stable_decay</h5><p><strong>预热稳定衰减学习率调节（Warmup Stable Decay Learning Rate Schedule）</strong> 是一种学习率调度策略，结合了预热（Warmup）和稳定衰减（Stable Decay）的概念。在这种策略中，学习率在训练初期逐渐增加（预热阶段），达到一个峰值后再逐渐减小（衰减阶段），从而在训练过程中保持一个平滑的学习率变化。这种方法可以帮助模型在训练初期快速收敛，同时在后期保持稳定的学习率，避免过早陷入局部最优解。</p>
<h6 id="机制-1"><a href="#机制-1" class="headerlink" title="机制"></a>机制</h6><ol>
<li><strong>预热阶段</strong>：在训练初期，学习率从一个较小的值逐渐增加到设定的峰值。</li>
<li><strong>稳定衰减阶段</strong>：达到峰值后，学习率逐渐减小，通常按照某种衰减函数（如线性衰减、指数衰减等）进行衰减。</li>
</ol>
<h6 id="优势-9"><a href="#优势-9" class="headerlink" title="优势"></a>优势</h6><ol>
<li><strong>快速收敛</strong>：在训练初期使用逐渐增加的学习率，可以帮助模型快速收敛。</li>
<li><strong>平滑过渡</strong>：通过预热阶段和衰减阶段的平滑过渡，避免了学习率的突变，保持训练过程的稳定性。</li>
<li><strong>适应性强</strong>：适用于各种不同的训练任务和数据集，特别是在训练初期需要快速收敛和后期需要稳定学习率的情况下。</li>
</ol>
<h6 id="注意事项-9"><a href="#注意事项-9" class="headerlink" title="注意事项"></a>注意事项</h6><ol>
<li><strong>预热阶段的设置</strong>：需要根据具体任务和数据集选择合适的预热阶段总步数（warmup_steps）。通常可以从较小的值开始，然后根据训练效果进行调整。</li>
<li><strong>初始和最小学习率的选择</strong>：选择合适的初始学习率和最小学习率非常重要。初始学习率过大会导致训练不稳定，过小则可能导致训练收敛速度慢或无法收敛。最小学习率过小可能导致模型停止学习，过大则可能影响模型的最终性能。</li>
<li><strong>总步数的设置</strong>：总步数（total_steps）应该根据具体任务和数据集进行调整，通常设置为训练的总步数或一个周期的步数。</li>
</ol>
<h6 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h6><p><code>warmup_stable_decay</code> 是一种结合了预热和稳定衰减的学习率调度策略，通过在训练初期逐渐增加学习率，然后逐渐减小学习率，可以帮助模型快速收敛并保持训练过程的稳定性。</p>
<h4 id="训练轮数（Epochs）"><a href="#训练轮数（Epochs）" class="headerlink" title="训练轮数（Epochs）"></a>训练轮数（Epochs）</h4><p>训练轮数是指整个训练数据集被完整地传递给模型进行训练的次数。</p>
<h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h5><ul>
<li><strong>模型训练程度</strong>：更多的训练轮数通常可以使模型更充分地学习数据特征，但过多的训练轮数可能导致过拟合。</li>
<li><strong>训练时间</strong>：训练轮数直接影响训练时间，更多的训练轮数需要更多的计算资源和时间。</li>
</ul>
<h5 id="设置方法-1"><a href="#设置方法-1" class="headerlink" title="设置方法"></a>设置方法</h5><ul>
<li><strong>经验法则</strong>：根据数据集大小和模型复杂度选择一个合理的初始值（如10、20等），然后根据训练效果进行调整。</li>
<li><strong>早停法</strong>：使用早停法（Early Stopping）在验证集上监控性能，当性能不再提升时提前停止训练。</li>
</ul>
<h4 id="最大梯度范数"><a href="#最大梯度范数" class="headerlink" title="最大梯度范数"></a>最大梯度范数</h4><p><strong>最大梯度范数（Max Gradient Norm）</strong> 是指在反向传播过程中，对梯度进行裁剪的最大范数值。它用于防止梯度爆炸。</p>
<h5 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h5><ul>
<li><strong>防止梯度爆炸</strong>：在深度神经网络中，梯度爆炸会导致训练不稳定，梯度裁剪可以有效防止这种情况。</li>
<li><strong>稳定训练</strong>：通过限制梯度的最大范数，可以使训练过程更加稳定，避免参数更新过大。</li>
</ul>
<h5 id="设置方法-2"><a href="#设置方法-2" class="headerlink" title="设置方法"></a>设置方法</h5><ul>
<li><strong>经验法则</strong>：通常选择一个较小的值（如1.0、5.0等），根据训练效果进行调整。</li>
<li><strong>动态调整</strong>：在训练过程中动态调整最大梯度范数，根据梯度变化情况进行裁剪。</li>
</ul>
<h4 id="最大样本数"><a href="#最大样本数" class="headerlink" title="最大样本数"></a>最大样本数</h4><p><strong>最大样本数（Max Samples）</strong> 是指在训练过程中，使用的最大训练样本数量。它用于控制训练数据的规模。</p>
<h5 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h5><ul>
<li><strong>控制训练规模</strong>：通过限制最大样本数，可以控制训练数据的规模，避免数据过多导致训练时间过长。</li>
<li><strong>提高训练效率</strong>：在数据量较大的情况下，使用部分数据进行训练可以提高训练效率，加快模型开发速度。</li>
</ul>
<h5 id="设置方法-3"><a href="#设置方法-3" class="headerlink" title="设置方法"></a>设置方法</h5><ul>
<li><strong>经验法则</strong>：根据数据集大小和计算资源选择一个合理的值（如10000、50000等），根据训练效果进行调整。</li>
<li><strong>分批训练</strong>：在大数据集上进行分批训练，每次使用部分数据进行训练，逐步优化模型。</li>
</ul>
<h4 id="计算类型"><a href="#计算类型" class="headerlink" title="计算类型"></a>计算类型</h4><ul>
<li>FP32（32-bit Floating Point）：FP32 是标准的 32 位浮点数表示方法，也是深度学习中最常用的精度类型。具有高精度和较大动态范围，适用于需要高精度计算的任务，但占用更多的内存和计算资源。</li>
<li>FP16（16-bit Floating Point）：FP16 是 16 位浮点数表示方法，通常用于加速深度学习模型的训练和推理。它占用更少的内存和计算资源，可以加速训练和推理过程，但精度和动态范围较低。</li>
<li>BF16（Brain Floating Point 16）：BF16 是一种 16 位浮点数表示方法，与 FP16 类似，但具有更大的动态范围。它在保持较大动态范围的同时减少了精度，适用于需要较大动态范围但对精度要求不高的任务。</li>
<li>Pure BF16（Pure Brain Floating Point 16）：完全使用 BF16 进行计算，显著减少内存和计算资源占用，但需要硬件支持。</li>
</ul>
<h4 id="截断长度"><a href="#截断长度" class="headerlink" title="截断长度"></a>截断长度</h4><p>在深度学习模型的训练和推理过程中，尤其是处理自然语言处理（NLP）任务时，截断长度（Truncation Length）通常用于限制输入序列的最大长度。具体来说，截断长度定义了模型在处理输入数据时所能接受的最大令牌（token）数。</p>
<h5 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h5><ol>
<li><strong>控制输入长度</strong>：在处理变长序列（如文本数据）时，截断长度可以确保输入序列的长度不超过模型的最大处理能力。对于超过截断长度的序列，模型会截断超出的部分。</li>
<li><strong>提高计算效率</strong>：通过限制输入长度，可以减少计算资源的消耗，提高模型的训练和推理速度。</li>
<li><strong>避免内存溢出</strong>：在处理非常长的序列时，限制输入长度可以避免内存溢出问题，确保模型能够在有限的硬件资源下正常运行。</li>
</ol>
<h5 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h5><p>在预训练语言模型时，处理长文本的截断策略是一个重要的考虑因素。通常有两种主要的处理方式：</p>
<ol>
<li><strong>直接丢弃</strong>：截断后的部分直接丢弃，不再作为输入的一部分。这种方式简单直接，适用于对长文本中后续部分不太关心的场景。</li>
<li><strong>滑动窗口</strong>：将剩余部分通过滑动窗口的方式继续作为输入的一部分。这种方式确保了长文本中的所有信息都有机会被模型学习到。</li>
</ol>
<h6 id="llama-factory-的具体策略"><a href="#llama-factory-的具体策略" class="headerlink" title="llama_factory 的具体策略"></a><code>llama_factory</code> 的具体策略</h6><p>具体到 <code>llama_factory</code>，它可能会根据模型的架构和任务需求选择合适的截断策略。以下是可能的处理方式：</p>
<ul>
<li><strong>预训练阶段</strong>：在预训练阶段，<code>llama_factory</code> 可能会采用滑动窗口或分块处理策略，以确保模型能够学习到长文本中的全部信息。</li>
<li><strong>微调阶段</strong>：在微调阶段，<code>llama_factory</code> 可能会根据具体任务的需求选择直接截断或动态截断策略，以提高训练效率和模型性能。</li>
</ul>
<h4 id="批处理大小"><a href="#批处理大小" class="headerlink" title="批处理大小"></a>批处理大小</h4><p><strong>批处理大小（Batch Size）</strong> 是深度学习模型训练中的一个重要超参数，不仅影响训练速度，还对模型的性能、稳定性和资源消耗等方面有显著影响。以下是批处理大小对不同方面的影响：</p>
<h5 id="1-训练速度"><a href="#1-训练速度" class="headerlink" title="1. 训练速度"></a>1. 训练速度</h5><p>批处理大小直接影响训练的速度。较大的批处理大小可以提高计算效率，因为现代GPU在处理大批量数据时可以更好地利用其并行计算能力。然而，过大的批处理大小可能导致显存不足。</p>
<h5 id="2-模型性能"><a href="#2-模型性能" class="headerlink" title="2. 模型性能"></a>2. 模型性能</h5><p>批处理大小对模型的收敛速度和最终性能有显著影响：</p>
<ul>
<li><strong>较小的批处理大小</strong>：通常会导致更高的噪声梯度估计，这可能有助于跳出局部最优解，从而提高模型的泛化能力。然而，较小的批处理大小会导致训练时间更长。</li>
<li><strong>较大的批处理大小</strong>：梯度估计更为准确，收敛速度更快，但可能导致模型陷入局部最优解，泛化能力下降。</li>
</ul>
<h5 id="3-资源消耗"><a href="#3-资源消耗" class="headerlink" title="3. 资源消耗"></a>3. 资源消耗</h5><p>批处理大小直接影响计算资源的消耗：</p>
<ul>
<li><strong>显存（GPU Memory）</strong>：较大的批处理大小需要更多的显存。如果显存不足，可能会导致训练过程中的内存溢出。</li>
<li><strong>计算资源</strong>：较大的批处理大小可以更好地利用GPU的计算能力，但也需要更多的计算资源。</li>
</ul>
<h5 id="4-梯度更新频率"><a href="#4-梯度更新频率" class="headerlink" title="4. 梯度更新频率"></a>4. 梯度更新频率</h5><p>批处理大小影响梯度更新的频率：</p>
<ul>
<li><strong>较小的批处理大小</strong>：梯度更新更频繁，每次更新使用的样本数较少，梯度估计的方差较大。</li>
<li><strong>较大的批处理大小</strong>：梯度更新频率较低，每次更新使用的样本数较多，梯度估计的方差较小。</li>
</ul>
<h5 id="5-学习率调整"><a href="#5-学习率调整" class="headerlink" title="5. 学习率调整"></a>5. 学习率调整</h5><p>批处理大小与学习率密切相关：</p>
<ul>
<li><strong>较小的批处理大小</strong>：通常需要较小的学习率，以避免训练过程中的梯度波动过大。</li>
<li><strong>较大的批处理大小</strong>：可以使用较大的学习率，但需要注意避免过大的学习率导致训练不稳定。</li>
</ul>
<h5 id="6-模型的泛化能力"><a href="#6-模型的泛化能力" class="headerlink" title="6. 模型的泛化能力"></a>6. 模型的泛化能力</h5><p>批处理大小对模型的泛化能力有一定影响：</p>
<ul>
<li><strong>较小的批处理大小</strong>：由于梯度估计的噪声较大，可能有助于模型跳出局部最优解，从而提高泛化能力。</li>
<li><strong>较大的批处理大小</strong>：梯度估计较为准确，收敛速度更快，但可能导致模型陷入局部最优解，泛化能力下降。</li>
</ul>
<h5 id="7-训练稳定性"><a href="#7-训练稳定性" class="headerlink" title="7. 训练稳定性"></a>7. 训练稳定性</h5><p>批处理大小影响训练过程的稳定性：</p>
<ul>
<li><strong>较小的批处理大小</strong>：梯度波动较大，训练过程可能不够稳定。</li>
<li><strong>较大的批处理大小</strong>：梯度波动较小，训练过程较为稳定。</li>
</ul>
<h5 id="选择合适的批处理大小"><a href="#选择合适的批处理大小" class="headerlink" title="选择合适的批处理大小"></a>选择合适的批处理大小</h5><p>选择合适的批处理大小需要在训练速度、模型性能、资源消耗和训练稳定性之间进行权衡。一般来说，可以尝试不同的批处理大小，并通过实验找到最适合具体任务和模型的值。</p>
<h5 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h5><p>批处理大小不仅影响训练速度，还对模型性能、资源消耗、梯度更新频率、学习率调整、泛化能力和训练稳定性等方面有显著影响。选择合适的批处理大小需要在这些因素之间进行权衡，并通过实验找到最适合具体任务和模型的值。</p>
<h4 id="梯度累积"><a href="#梯度累积" class="headerlink" title="梯度累积"></a>梯度累积</h4><p><strong>梯度累积（Gradient Accumulation）</strong> 是一种在训练深度学习模型时的技术，目的是在显存有限的情况下，实现更大的有效批处理大小。它通过在多个小批次（mini-batch）上累积梯度，然后再进行一次梯度更新，从而模拟出较大的批处理大小。</p>
<h5 id="为什么需要梯度累积？"><a href="#为什么需要梯度累积？" class="headerlink" title="为什么需要梯度累积？"></a>为什么需要梯度累积？</h5><p>在训练大规模深度学习模型时，特别是当模型和数据集都非常大时，显存限制可能使得一次性处理大批量数据变得困难。较小的批处理大小虽然可以缓解显存压力，但可能会导致梯度估计的方差较大，从而影响模型的收敛速度和性能。梯度累积可以在不增加显存需求的情况下，实现更大的有效批处理大小，从而提高模型的性能和稳定性。</p>
<h5 id="梯度累积的工作原理"><a href="#梯度累积的工作原理" class="headerlink" title="梯度累积的工作原理"></a>梯度累积的工作原理</h5><p>梯度累积的基本思想是：</p>
<ol>
<li>将训练数据分成多个小批次（mini-batch）。</li>
<li>对每个小批次进行前向传播和反向传播，计算梯度。</li>
<li>将每个小批次的梯度累积起来，而不是立即更新模型参数。</li>
<li>当累积的梯度达到设定的批处理大小（accumulation steps）时，再进行一次梯度更新，并清零累积的梯度。</li>
</ol>
<h5 id="梯度累积的优点"><a href="#梯度累积的优点" class="headerlink" title="梯度累积的优点"></a>梯度累积的优点</h5><ol>
<li><strong>显存效率</strong>：在显存有限的情况下，可以模拟出更大的有效批处理大小。</li>
<li><strong>提高模型性能</strong>：通过累积梯度，可以减少梯度估计的方差，从而提高模型的收敛速度和性能。</li>
<li><strong>灵活性</strong>：可以根据显存限制和任务需求灵活调整累积步数。</li>
</ol>
<h5 id="梯度累积的注意事项"><a href="#梯度累积的注意事项" class="headerlink" title="梯度累积的注意事项"></a>梯度累积的注意事项</h5><ol>
<li><strong>学习率调整</strong>：由于梯度累积相当于增大了批处理大小，可能需要相应调整学习率。</li>
<li><strong>梯度爆炸或消失</strong>：累积梯度时需要注意梯度爆炸或消失的问题，可以考虑使用梯度裁剪（Gradient Clipping）技术。</li>
<li><strong>训练时间</strong>：虽然梯度累积可以提高模型性能，但也可能增加训练时间。</li>
</ol>
<h5 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h5><p>梯度累积是一种在显存有限的情况下实现更大有效批处理大小的技术，通过在多个小批次上累积梯度，然后再进行一次梯度更新，可以提高模型的性能和稳定性。选择合适的累积步数和学习率调整策略，可以在不增加显存需求的情况下，提升模型的训练效果。</p>
<h4 id="验证集比例"><a href="#验证集比例" class="headerlink" title="验证集比例"></a>验证集比例</h4><p>验证集比例（Validation Split Ratio）是指在划分数据集时，将数据集的一部分保留用作验证集的比例。验证集用于在训练过程中评估模型的性能，帮助选择最佳模型参数并防止过拟合。以下是关于验证集比例的详细总结：</p>
<h5 id="1-验证集的作用"><a href="#1-验证集的作用" class="headerlink" title="1. 验证集的作用"></a>1. 验证集的作用</h5><ul>
<li><strong>模型评估</strong>：验证集用于在训练过程中评估模型的性能，而不参与模型的训练。通过验证集的评价指标，可以了解模型在未见过的数据上的表现。</li>
<li><strong>参数调优</strong>：验证集用于选择最佳的超参数（如学习率、批处理大小等），帮助优化模型的性能。</li>
<li><strong>防止过拟合</strong>：通过在验证集上监控模型的表现，可以及时发现过拟合问题，并采取相应措施（如正则化、早停等）。</li>
</ul>
<h5 id="2-常见的验证集比例"><a href="#2-常见的验证集比例" class="headerlink" title="2. 常见的验证集比例"></a>2. 常见的验证集比例</h5><p>验证集比例通常根据数据集的大小和具体任务来选择。常见的验证集比例有：</p>
<ul>
<li><strong>70&#x2F;30</strong>：70%的数据用于训练，30%的数据用于验证。适用于数据量较少的情况，以确保验证集的绝对数量足够进行有效评估。</li>
<li><strong>80&#x2F;20</strong>：80%的数据用于训练，20%的数据用于验证。这是一个常见的选择，适用于大多数数据集。</li>
<li><strong>90&#x2F;10</strong>：90%的数据用于训练，10%的数据用于验证。适用于数据量较大的情况，因为即使验证集比例较小，验证集的绝对数量仍然足够进行有效评估。</li>
</ul>
<h5 id="3-验证集比例的选择"><a href="#3-验证集比例的选择" class="headerlink" title="3. 验证集比例的选择"></a>3. 验证集比例的选择</h5><p>选择验证集比例时需要考虑以下因素：</p>
<ul>
<li><strong>数据集大小</strong>：数据集较大时，可以选择较小的验证集比例；数据集较小时，可以选择较大的验证集比例。</li>
<li><strong>任务需求</strong>：不同任务对验证集的需求不同，需要根据具体情况选择合适的验证集比例。</li>
<li><strong>模型复杂度</strong>：复杂模型可能需要更多的验证数据来评估其性能，可以选择较大的验证集比例。</li>
</ul>
<h5 id="4-交叉验证"><a href="#4-交叉验证" class="headerlink" title="4. 交叉验证"></a>4. 交叉验证</h5><p>在某些情况下，特别是当数据量较少时，可以使用交叉验证（Cross-Validation）来更好地评估模型的性能。交叉验证将数据集分成多个子集，并在多个训练-验证轮次中使用不同的子集组合，最终取平均性能作为评估指标。常见的交叉验证方法有：</p>
<ul>
<li><strong>K折交叉验证（K-Fold Cross-Validation）</strong>：将数据集分成K个子集，每次使用其中一个子集作为验证集，其余K-1个子集作为训练集，重复K次。</li>
<li><strong>留一法交叉验证（Leave-One-Out Cross-Validation）</strong>：每次使用一个样本作为验证集，其余样本作为训练集，重复N次（N为样本总数）。</li>
</ul>
<h5 id="6-验证集比例的注意事项"><a href="#6-验证集比例的注意事项" class="headerlink" title="6. 验证集比例的注意事项"></a>6. 验证集比例的注意事项</h5><ul>
<li><strong>数据分布一致性</strong>：确保训练集和验证集的数据分布一致，避免模型在验证集上表现不佳。</li>
<li><strong>随机种子</strong>：设置随机种子（如 <code>random_state</code> 参数）以确保数据划分的可重复性。</li>
<li><strong>数据泄露</strong>：避免训练集和验证集之间的数据泄露，确保验证集上的评估结果真实可靠。</li>
</ul>
<h5 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h5><p>验证集比例是数据集划分中的一个重要参数，直接影响模型的评估和优化效果。选择合适的验证集比例需要根据数据集大小、任务需求和模型复杂度等因素进行权衡。通过合理的验证集划分和交叉验证，可以更好地评估模型的性能，优化模型参数，并防止过拟合。<br>当数据量较小时如果设置较大的验证集比例，可能存在学习不足的情况。通过提高学习轮数可以在一定程度上弥补训练数据不足的问题，但需要采取措施防止过拟合。早停法、正则化技术、数据增强、交叉验证和迁移学习都是有效的手段。通过综合运用这些方法，可以在数据量较小时仍然训练出性能良好的模型。</p>
<h4 id="预热步数（学习率预热采用的步数）"><a href="#预热步数（学习率预热采用的步数）" class="headerlink" title="预热步数（学习率预热采用的步数）"></a>预热步数（学习率预热采用的步数）</h4><p><strong>预热步数（Warm-up Steps）</strong> 是指在训练神经网络模型时，在初始阶段逐步增加学习率（Learning Rate），直到达到预设的最大学习率的过程。这个过程通常在训练的前几个步数（steps）中进行，以便模型能够平稳地适应训练过程，避免在训练初期因学习率过大而导致的梯度爆炸（Gradient Explosion）或训练不稳定。</p>
<h5 id="为什么需要预热步数？"><a href="#为什么需要预热步数？" class="headerlink" title="为什么需要预热步数？"></a>为什么需要预热步数？</h5><ol>
<li><strong>稳定训练过程</strong>：在训练的初期，模型的参数随机初始化，可能会导致梯度的波动较大。如果一开始就使用较大的学习率，可能会导致梯度爆炸或训练不稳定。通过逐步增加学习率，可以使模型在初期逐步适应训练过程，稳定训练。</li>
<li><strong>提高收敛速度</strong>：在训练的初期使用较小的学习率，可以避免模型在开始阶段过快地跳过最优解附近的区域，从而提高模型的收敛速度。</li>
<li><strong>防止过拟合</strong>：预热步数可以帮助模型在训练初期更好地探索参数空间，找到更好的参数初始化，从而降低过拟合的风险。</li>
</ol>
<h5 id="如何设置预热步数？"><a href="#如何设置预热步数？" class="headerlink" title="如何设置预热步数？"></a>如何设置预热步数？</h5><p>预热步数的设置通常根据具体的任务和数据集进行调整。常见的设置方法包括：</p>
<ol>
<li><strong>固定步数</strong>：预热步数设置为一个固定值，例如前1000步。</li>
<li><strong>比例设置</strong>：预热步数设置为总训练步数的一个比例，例如总训练步数的10%。</li>
</ol>
<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>预热步数是指在训练初期逐步增加学习率的步骤，以确保模型能够平稳地适应训练过程，避免初期因学习率过大导致的不稳定。通过合理设置预热步数，可以提高模型的收敛速度，稳定训练过程，并降低过拟合风险。</p>
<h4 id="NEFTune噪声"><a href="#NEFTune噪声" class="headerlink" title="NEFTune噪声"></a>NEFTune噪声</h4><p><strong>NEFTune（Noise Enhanced Fine-Tuning）</strong> 是一种在模型训练过程中通过添加噪声来增强嵌入向量的方法。嵌入向量是神经网络模型中用于表示输入数据（如单词、图像等）的低维向量表示。通过在这些向量中添加噪声，可以提高模型的鲁棒性和泛化能力。</p>
<h5 id="噪声的作用"><a href="#噪声的作用" class="headerlink" title="噪声的作用"></a>噪声的作用</h5><ol>
<li><strong>提高鲁棒性</strong>：添加噪声可以使模型在训练过程中更好地应对输入数据中的不确定性，从而提高模型在面对未见数据时的表现。</li>
<li><strong>防止过拟合</strong>：噪声可以作为一种正则化手段，防止模型在训练数据上过拟合，从而提高模型的泛化能力。</li>
<li><strong>增强探索</strong>：在训练初期添加噪声可以帮助模型更好地探索参数空间，从而找到更好的参数初始化。</li>
</ol>
<h5 id="噪声的类型"><a href="#噪声的类型" class="headerlink" title="噪声的类型"></a>噪声的类型</h5><ol>
<li><strong>高斯噪声（Gaussian Noise）</strong>：最常见的噪声类型，服从正态分布的随机噪声。</li>
<li><strong>均匀噪声（Uniform Noise）</strong>：服从均匀分布的随机噪声。</li>
<li><strong>泊松噪声（Poisson Noise）</strong>：服从泊松分布的随机噪声，适用于计数数据。</li>
</ol>
<h5 id="如何添加噪声"><a href="#如何添加噪声" class="headerlink" title="如何添加噪声"></a>如何添加噪声</h5><p>在训练过程中，噪声通常添加到嵌入向量的每一个维度上。噪声的大小（即噪声的标准差或方差）可以根据具体任务和数据集进行调整。</p>
<h5 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h5><p>NEFTune噪声是指在嵌入向量中添加的噪声大小，通过添加噪声可以提高模型的鲁棒性和泛化能力。噪声的类型和大小可以根据具体任务和数据集进行调整。在训练过程中，噪声通常添加到嵌入向量的每一个维度上。</p>
<h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p>在深度学习模型的训练过程中，优化器（Optimizer）起着至关重要的作用。它决定了如何更新模型的参数以最小化损失函数。以下是三种常见的优化器：AdamW、AdamW 8-bit 和 Adafactor。我们将逐一介绍它们的特点、适用场景以及如何在代码中使用它们。</p>
<h5 id="AdamW-优化器"><a href="#AdamW-优化器" class="headerlink" title="AdamW 优化器"></a>AdamW 优化器</h5><p>AdamW 是 Adam 优化器的一种变体，专门用于权重衰减（weight decay）。与传统的 Adam 不同，AdamW 将权重衰减作为独立的正则化项处理，而不是将其添加到梯度更新中。这种方法可以更好地控制模型的复杂度，防止过拟合。</p>
<h6 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h6><ul>
<li><strong>权重衰减</strong>：独立处理权重衰减，效果更好。</li>
<li><strong>适用场景</strong>：适用于大多数深度学习任务，尤其是需要正则化的场景。</li>
</ul>
<h5 id="AdamW-8-bit-优化器"><a href="#AdamW-8-bit-优化器" class="headerlink" title="AdamW 8-bit 优化器"></a>AdamW 8-bit 优化器</h5><p>AdamW 8-bit 是一种低精度版本的 AdamW 优化器，使用 8 位浮点数进行计算。它的主要目的是减少显存占用和计算开销，同时保持与原始 AdamW 类似的性能。</p>
<h6 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h6><ul>
<li><strong>低精度计算</strong>：使用 8 位浮点数，减少显存占用和计算开销。</li>
<li><strong>适用场景</strong>：适用于大规模模型或资源受限的场景。</li>
</ul>
<h5 id="Adafactor-优化器"><a href="#Adafactor-优化器" class="headerlink" title="Adafactor 优化器"></a>Adafactor 优化器</h5><p>Adafactor 是一种基于 Adam 的优化器，专门设计用于大型稀疏矩阵的优化。它通过动态调整学习率和矩阵因子分解来减少内存占用和计算复杂度。</p>
<h6 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h6><ul>
<li><strong>动态学习率</strong>：根据参数的大小动态调整学习率。</li>
<li><strong>适用场景</strong>：适用于大型稀疏矩阵的优化，如自然语言处理中的大规模词嵌入。</li>
</ul>
<h5 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h5><ul>
<li><strong>AdamW</strong>：适用于大多数深度学习任务，尤其是需要正则化的场景。</li>
<li><strong>AdamW 8-bit</strong>：适用于大规模模型或资源受限的场景，减少显存占用和计算开销。</li>
<li><strong>Adafactor</strong>：适用于大型稀疏矩阵的优化，如自然语言处理中的大规模词嵌入。</li>
</ul>
<blockquote>
<p>注：”AdamW” 和 “adamw_torch” 实际上是指同一种优化器，即 AdamW 优化器。</p>
</blockquote>
<h4 id="更改词表大小（更改分词器词表和嵌入层大小）"><a href="#更改词表大小（更改分词器词表和嵌入层大小）" class="headerlink" title="更改词表大小（更改分词器词表和嵌入层大小）"></a>更改词表大小（更改分词器词表和嵌入层大小）</h4><p>在深度学习模型的训练和应用过程中，词表（Vocabulary）和嵌入层（Embedding Layer）是处理文本数据的关键组件。更改词表大小和嵌入层大小是为了适应特定任务的需求，提升模型的性能。</p>
<h5 id="词表（Vocabulary）"><a href="#词表（Vocabulary）" class="headerlink" title="词表（Vocabulary）"></a>词表（Vocabulary）</h5><p>词表是模型能够识别和处理的单词或子词的集合。在自然语言处理中，词表的大小直接影响模型的输入和输出维度。更改词表大小通常包括以下步骤：</p>
<ol>
<li><strong>调整分词器词表</strong>：分词器（Tokenizer）是将文本转换为词或子词序列的工具。调整分词器的词表意味着增加或减少模型能够识别的词或子词数量。</li>
<li><strong>更新嵌入层大小</strong>：嵌入层是将词或子词映射到高维向量空间的层。词表大小的变化需要同步更新嵌入层的大小，以确保每个词或子词都有对应的向量表示。</li>
</ol>
<h5 id="嵌入层（Embedding-Layer）"><a href="#嵌入层（Embedding-Layer）" class="headerlink" title="嵌入层（Embedding Layer）"></a>嵌入层（Embedding Layer）</h5><p>嵌入层是模型的第一层，用于将离散的词或子词映射到连续的向量空间。嵌入层的大小通常由词表大小和嵌入维度决定。更改嵌入层大小可以提升模型对新词汇或特定任务的适应能力。</p>
<h5 id="为什么要更改词表大小和嵌入层大小？"><a href="#为什么要更改词表大小和嵌入层大小？" class="headerlink" title="为什么要更改词表大小和嵌入层大小？"></a>为什么要更改词表大小和嵌入层大小？</h5><ol>
<li><strong>适应新任务</strong>：不同任务可能涉及不同的词汇集合。例如，医学文本和法律文本的词汇差异较大。调整词表和嵌入层可以让模型更好地处理特定领域的文本。</li>
<li><strong>处理未登录词</strong>：在实际应用中，可能会遇到许多未在原始词表中的新词或罕见词。通过扩展词表和嵌入层，模型可以更好地处理这些未登录词。</li>
<li><strong>提升模型性能</strong>：通过优化词表和嵌入层，模型可以更有效地表示输入文本，从而提升整体性能。</li>
</ol>
<h5 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h5><p>更改词表大小和嵌入层大小是为了让模型更好地适应特定任务或处理新的词汇。这一过程包括调整分词器的词表和更新模型的嵌入层大小。在 LLaMA 中，这些步骤可以通过重新训练分词器和调整模型的嵌入层来实现。</p>
<h4 id="序列打包"><a href="#序列打包" class="headerlink" title="序列打包"></a>序列打包</h4><p>序列打包（Sequence Packing）是处理时间序列数据的一种常见技术，特别是在深度学习模型（如RNN、LSTM、Transformer）中应用广泛。其目的是将不定长的时间序列数据打包为等长样本，以便于批处理和模型训练。以下是对这一概念的详细解释及其应用。</p>
<h5 id="为什么需要序列打包？"><a href="#为什么需要序列打包？" class="headerlink" title="为什么需要序列打包？"></a>为什么需要序列打包？</h5><ol>
<li><strong>统一输入尺寸</strong>：深度学习模型通常要求输入数据具有统一的尺寸。序列打包可以将不定长的时间序列转换为等长的样本，方便批处理。</li>
<li><strong>提高计算效率</strong>：统一尺寸的数据可以提高计算效率，特别是在使用GPU进行并行计算时。</li>
<li><strong>处理缺失值</strong>：在金融数据、传感器数据等时间序列数据中，可能存在缺失值。序列打包可以通过填充（padding）处理这些缺失值。</li>
</ol>
<h5 id="如何进行序列打包？"><a href="#如何进行序列打包？" class="headerlink" title="如何进行序列打包？"></a>如何进行序列打包？</h5><p>序列打包通常包括以下步骤：</p>
<ol>
<li><strong>确定序列长度</strong>：选择一个固定的序列长度（例如，100个时间步长）。如果序列长度不一致，可以通过截断或填充来统一长度。</li>
<li><strong>填充（Padding）</strong>：对于长度不足的序列，可以用特定的值（如0）进行填充。</li>
<li><strong>截断（Truncation）</strong>：对于长度超过固定长度的序列，可以进行截断。</li>
</ol>
<h5 id="在深度学习中的应用"><a href="#在深度学习中的应用" class="headerlink" title="在深度学习中的应用"></a>在深度学习中的应用</h5><p>在深度学习模型中，可以使用类似的方式将时间序列数据打包为等长样本，然后输入到模型中进行训练。</p>
<h5 id="结论-4"><a href="#结论-4" class="headerlink" title="结论"></a>结论</h5><p>序列打包是处理时间序列数据的一种重要技术，通过将不定长的序列转换为等长样本，可以方便地进行批处理和模型训练。填充和截断是实现序列打包的两种常见方法。在深度学习应用中，序列打包可以显著提高计算效率和模型性能。</p>
<h4 id="缩放归一化层"><a href="#缩放归一化层" class="headerlink" title="缩放归一化层"></a>缩放归一化层</h4><p>在深度学习模型中，<strong>归一化层（Normalization Layer）</strong> 是一种常用技术，用于提高模型的训练稳定性和收敛速度。缩放归一化层（Scaling Normalization Layer）是指将归一化层的权重缩放至32位精度，以提高计算的精度和稳定性。以下是对这一概念的详细解释及其应用。</p>
<h5 id="为什么需要缩放归一化层？"><a href="#为什么需要缩放归一化层？" class="headerlink" title="为什么需要缩放归一化层？"></a>为什么需要缩放归一化层？</h5><ol>
<li><strong>提高计算精度</strong>：在某些情况下，模型的权重和激活值可能非常小或非常大，使用32位浮点数（FP32）可以提高计算的精度，减少数值误差。</li>
<li><strong>稳定训练过程</strong>：归一化层（如Batch Normalization、Layer Normalization）在训练过程中对数值稳定性要求较高，将权重缩放至32位精度可以避免数值不稳定导致的训练失败。</li>
<li><strong>兼容性需求</strong>：某些硬件或框架可能对32位浮点数有更好的支持，缩放至32位可以提高计算效率和兼容性。</li>
</ol>
<h5 id="常见的归一化层"><a href="#常见的归一化层" class="headerlink" title="常见的归一化层"></a>常见的归一化层</h5><ol>
<li><strong>Batch Normalization（BN）</strong>：对每个批次的数据进行归一化。</li>
<li><strong>Layer Normalization（LN）</strong>：对每一层的神经元进行归一化。</li>
<li><strong>Instance Normalization（IN）</strong>：对每个样本的每个通道进行归一化。</li>
<li><strong>Group Normalization（GN）</strong>：将通道分成若干组，对每组进行归一化。</li>
</ol>
<h5 id="如何实现缩放归一化层？"><a href="#如何实现缩放归一化层？" class="headerlink" title="如何实现缩放归一化层？"></a>如何实现缩放归一化层？</h5><p>在深度学习框架（如PyTorch、TensorFlow）中，可以通过设置数据类型为FP32来实现缩放归一化层。</p>
<h5 id="结论-5"><a href="#结论-5" class="headerlink" title="结论"></a>结论</h5><p>缩放归一化层是指将归一化层的权重和输入数据缩放至32位浮点数，以提高计算的精度和稳定性。通过这种方式，可以在训练过程中减少数值误差，提高模型的性能和训练稳定性。在实际应用中，可以根据具体需求选择合适的归一化层，并通过设置数据类型实现缩放。</p>
<h4 id="使用LLaMA-Pro"><a href="#使用LLaMA-Pro" class="headerlink" title="使用LLaMA Pro"></a>使用LLaMA Pro</h4><p>在深度学习模型的训练过程中，尤其是大规模语言模型（如LLaMA）的训练中，参数的数量和质量对模型的性能有着至关重要的影响。LLaMA Pro 是一种优化策略，专注于仅训练块扩展后的参数，这种方法有以下几个主要作用和优势：</p>
<h5 id="1-提高训练效率"><a href="#1-提高训练效率" class="headerlink" title="1. 提高训练效率"></a>1. 提高训练效率</h5><p>训练大规模模型需要大量的计算资源和时间。通过仅训练块扩展后的参数，可以显著减少需要更新的参数数量，从而加快训练速度。这种方法可以在保持模型性能的同时，减少训练时间和计算资源的消耗。</p>
<h5 id="2-保持模型的稳定性"><a href="#2-保持模型的稳定性" class="headerlink" title="2. 保持模型的稳定性"></a>2. 保持模型的稳定性</h5><p>在大规模模型中，训练所有参数可能会导致模型不稳定，尤其是在早期训练阶段。仅训练块扩展后的参数可以减少这种不稳定性，因为大部分参数保持不变，只有少量参数进行更新。这有助于保持模型的稳定性和收敛性。</p>
<h5 id="3-灵活性和可扩展性"><a href="#3-灵活性和可扩展性" class="headerlink" title="3. 灵活性和可扩展性"></a>3. 灵活性和可扩展性</h5><p>LLaMA Pro 允许在模型的特定部分进行扩展和优化，而无需重新训练整个模型。这种方法提供了更多的灵活性，允许研究人员和工程师在不影响整体模型性能的情况下，对模型的特定部分进行实验和改进。</p>
<h5 id="4-降低过拟合风险"><a href="#4-降低过拟合风险" class="headerlink" title="4. 降低过拟合风险"></a>4. 降低过拟合风险</h5><p>在大规模模型中，训练所有参数可能会导致过拟合，尤其是在数据量不足的情况下。通过仅训练块扩展后的参数，可以减少过拟合的风险，因为模型的大部分参数保持不变，只有少量参数进行更新。这有助于提高模型的泛化能力。</p>
<h5 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h5><p>以下是一些实际应用场景，展示了使用LLaMA Pro仅训练块扩展后的参数的优势：</p>
<h6 id="示例1：微调预训练模型"><a href="#示例1：微调预训练模型" class="headerlink" title="示例1：微调预训练模型"></a>示例1：微调预训练模型</h6><p>在微调预训练模型时，可以仅训练块扩展后的参数，而保持预训练模型的其他参数不变。这种方法可以显著减少微调的计算成本，同时保持预训练模型的性能。</p>
<h6 id="示例2：模型压缩和优化"><a href="#示例2：模型压缩和优化" class="headerlink" title="示例2：模型压缩和优化"></a>示例2：模型压缩和优化</h6><p>在模型压缩和优化过程中，可以使用LLaMA Pro仅训练块扩展后的参数，以减少模型的计算复杂度和存储需求。</p>
<h5 id="结论-6"><a href="#结论-6" class="headerlink" title="结论"></a>结论</h5><p>LLaMA Pro 仅训练块扩展后的参数是一种有效的优化策略，可以提高训练效率、保持模型稳定性、提供灵活性和可扩展性，并降低过拟合风险。在实际应用中，这种方法可以显著减少计算资源和时间的消耗，同时保持或提高模型的性能。</p>
<h4 id="S²-Attention-shift-short-attention"><a href="#S²-Attention-shift-short-attention" class="headerlink" title="S² Attention(shift short attention)"></a>S² Attention(shift short attention)</h4><p><strong>S² Attention（Shift Short Attention）</strong> 是一种改进的自注意力机制，旨在提高模型在处理长序列时的效率和性能。通过引入“Shift Short Attention”机制，S² Attention能够在保持计算效率的同时，捕捉到更多的局部和全局信息。以下是对S² Attention的详细解释及其实现方法。</p>
<h5 id="S²-Attention的核心思想"><a href="#S²-Attention的核心思想" class="headerlink" title="S² Attention的核心思想"></a>S² Attention的核心思想</h5><p>S² Attention的核心思想是通过引入“Shift Short Attention”机制，将注意力范围限制在较短的局部区域，并通过移位操作（Shift Operation）来覆盖整个序列。这样可以减少计算复杂度，同时保留足够的上下文信息。</p>
<h5 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h5><ol>
<li><strong>短距离注意力（Short Attention）</strong>：将注意力范围限制在较短的局部区域，例如一个固定的窗口大小。</li>
<li><strong>移位操作（Shift Operation）</strong>：通过移位操作，将短距离注意力覆盖到整个序列，从而实现全局信息的捕捉。</li>
</ol>
<h5 id="优势-10"><a href="#优势-10" class="headerlink" title="优势"></a>优势</h5><ol>
<li><strong>计算效率高</strong>：通过限制注意力范围，减少了计算复杂度，提高了计算效率。</li>
<li><strong>捕捉局部和全局信息</strong>：通过移位操作，能够覆盖整个序列，捕捉到全局信息。</li>
<li><strong>适用于长序列</strong>：尤其适用于处理长序列的数据，如自然语言处理中的长文本。</li>
</ol>
<h5 id="结论-7"><a href="#结论-7" class="headerlink" title="结论"></a>结论</h5><p>S² Attention（Shift Short Attention）通过引入短距离注意力和移位操作，能够在保持计算效率的同时，捕捉到更多的局部和全局信息。这种方法特别适用于处理长序列的数据，具有较高的计算效率和良好的性能。在实际应用中，可以根据具体需求调整窗口大小和注意力头的数量，以获得最佳效果。</p>
<h4 id="可训练层数"><a href="#可训练层数" class="headerlink" title="可训练层数"></a>可训练层数</h4><p>可训练层数（Trainable Layers）指的是在模型中设置为可训练的隐藏层的数量。通过调整模型的可训练层数，可以控制模型的训练复杂度、参数更新的范围以及计算资源的使用。可训练层数可以从模型的最末端（+）或最前端（-）开始设置，这取决于具体的需求和应用场景。</p>
<h5 id="最末端（-）可训练隐藏层的数量"><a href="#最末端（-）可训练隐藏层的数量" class="headerlink" title="最末端（+）可训练隐藏层的数量"></a>最末端（+）可训练隐藏层的数量</h5><p>在这种情况下，只有模型最末端的若干层是可训练的，其余层被冻结（即其参数不更新）。这种方法通常用于微调预训练模型，以减少训练时间和计算资源，同时利用预训练模型的已有知识。</p>
<h5 id="最前端（-）可训练隐藏层的数量"><a href="#最前端（-）可训练隐藏层的数量" class="headerlink" title="最前端（-）可训练隐藏层的数量"></a>最前端（-）可训练隐藏层的数量</h5><p>在这种情况下，只有模型最前端的若干层是可训练的，其余层被冻结。这种方法较少使用，因为通常模型的高层特征更具通用性，而底层特征更多地依赖于特定任务。</p>
<h5 id="结论-8"><a href="#结论-8" class="headerlink" title="结论"></a>结论</h5><p>通过调整模型的可训练层数，可以灵活控制模型的训练复杂度和计算资源的使用。根据具体需求，可以选择最末端（+）或最前端（-）的若干层作为可训练层，以实现最佳的训练效果和效率。</p>
<blockquote>
<p>调整可训练层数主要在采用 <strong>冻结策略(Freeze)</strong> 进行微调时才有显著作用。通过冻结部分层的参数，可以减少计算资源和时间的消耗，同时利用预训练模型的已有知识，提高微调的效率和效果。根据具体任务的需求，可以选择性地冻结和微调模型的某些层，以实现最佳的训练效果。</p>
</blockquote>
<h4 id="可训练模块"><a href="#可训练模块" class="headerlink" title="可训练模块"></a>可训练模块</h4><p>可训练模块（Trainable Modules）是指那些在模型训练过程中可以更新其参数的模块。这些模块的主要作用包括：</p>
<ol>
<li><strong>参数优化</strong>：通过训练过程中的反向传播算法，更新可训练模块的参数，以最小化损失函数，提高模型的性能和准确性。</li>
<li><strong>特征提取</strong>：在深度学习模型中，可训练模块负责从输入数据中提取有用的特征，这些特征可以用于各种任务，如分类、回归、生成等。</li>
<li><strong>模型微调</strong>：在微调（Fine-tuning）预训练模型时，可训练模块允许模型适应新的任务或数据集，从而提高模型在特定任务上的表现。</li>
</ol>
<h5 id="LLaMA-Factory中的常见可训练模块"><a href="#LLaMA-Factory中的常见可训练模块" class="headerlink" title="LLaMA Factory中的常见可训练模块"></a>LLaMA Factory中的常见可训练模块</h5><p>在LLaMA Factory中，常见的可训练模块包括：</p>
<ol>
<li><strong>线性层（Linear Layers）</strong>：全连接层，用于线性变换输入数据。</li>
<li><strong>卷积层（Convolutional Layers）</strong>：用于提取局部特征，常用于图像处理任务。</li>
<li><strong>注意力机制（Attention Mechanisms）</strong>：用于捕捉输入数据中的长距离依赖关系，常用于自然语言处理任务。</li>
<li><strong>嵌入层（Embedding Layers）</strong>：将离散输入数据映射到连续的向量空间，常用于处理文本数据。</li>
<li><strong>归一化层（Normalization Layers）</strong>：用于标准化输入数据，减少内部协变量偏移，提高训练稳定性。</li>
</ol>
<h5 id="结论-9"><a href="#结论-9" class="headerlink" title="结论"></a>结论</h5><p>LLaMA Factory中的可训练模块在模型训练过程中起到了关键作用，通过参数优化、特征提取和模型微调等功能，提高了模型的性能和准确性。理解和正确使用这些可训练模块，可以帮助你构建和优化深度学习模型，以满足各种任务的需求。</p>
<h4 id="额外模块-除隐藏层以外的可训练模块名称"><a href="#额外模块-除隐藏层以外的可训练模块名称" class="headerlink" title="额外模块(除隐藏层以外的可训练模块名称)"></a>额外模块(除隐藏层以外的可训练模块名称)</h4><p>在深度学习模型中，除了隐藏层之外，还有许多其他类型的可训练模块，这些模块在不同的任务和模型架构中起到了关键作用。以下是一些常见的可训练模块名称及其作用：</p>
<h5 id="1-嵌入层（Embedding-Layer）"><a href="#1-嵌入层（Embedding-Layer）" class="headerlink" title="1. 嵌入层（Embedding Layer）"></a>1. 嵌入层（Embedding Layer）</h5><p>嵌入层将离散输入（如单词、字符）映射到连续的向量空间。它在自然语言处理任务中广泛使用，如词嵌入（Word Embedding）和字符嵌入（Character Embedding）。</p>
<h5 id="2-卷积层（Convolutional-Layer）"><a href="#2-卷积层（Convolutional-Layer）" class="headerlink" title="2. 卷积层（Convolutional Layer）"></a>2. 卷积层（Convolutional Layer）</h5><p>卷积层用于提取输入数据的局部特征，广泛应用于图像处理和计算机视觉任务中。</p>
<h5 id="3-批归一化层（Batch-Normalization-Layer）"><a href="#3-批归一化层（Batch-Normalization-Layer）" class="headerlink" title="3. 批归一化层（Batch Normalization Layer）"></a>3. 批归一化层（Batch Normalization Layer）</h5><p>批归一化层用于标准化每一批数据的输入，以加速训练过程并提高模型的稳定性。</p>
<h5 id="4-注意力机制（Attention-Mechanism）"><a href="#4-注意力机制（Attention-Mechanism）" class="headerlink" title="4. 注意力机制（Attention Mechanism）"></a>4. 注意力机制（Attention Mechanism）</h5><p>注意力机制用于捕捉输入数据中的长距离依赖关系，广泛应用于自然语言处理和序列建模任务中。</p>
<h5 id="5-残差块（Residual-Block）"><a href="#5-残差块（Residual-Block）" class="headerlink" title="5. 残差块（Residual Block）"></a>5. 残差块（Residual Block）</h5><p>残差块是ResNet中的基本模块，通过跳跃连接（skip connection）缓解深层网络中的梯度消失问题。</p>
<h5 id="6-递归神经网络（Recurrent-Neural-Network-RNN）"><a href="#6-递归神经网络（Recurrent-Neural-Network-RNN）" class="headerlink" title="6. 递归神经网络（Recurrent Neural Network, RNN）"></a>6. 递归神经网络（Recurrent Neural Network, RNN）</h5><p>递归神经网络用于处理序列数据，如时间序列和自然语言文本。</p>
<h5 id="7-长短期记忆网络（Long-Short-Term-Memory-LSTM）"><a href="#7-长短期记忆网络（Long-Short-Term-Memory-LSTM）" class="headerlink" title="7. 长短期记忆网络（Long Short-Term Memory, LSTM）"></a>7. 长短期记忆网络（Long Short-Term Memory, LSTM）</h5><p>LSTM是一种特殊的RNN，能够捕捉长时间依赖关系，解决了传统RNN中的梯度消失问题。</p>
<h5 id="8-门控循环单元（Gated-Recurrent-Unit-GRU）"><a href="#8-门控循环单元（Gated-Recurrent-Unit-GRU）" class="headerlink" title="8. 门控循环单元（Gated Recurrent Unit, GRU）"></a>8. 门控循环单元（Gated Recurrent Unit, GRU）</h5><p>GRU是另一种改进的RNN，与LSTM类似，但结构更为简单，计算效率更高。</p>
<h5 id="9-变压器（Transformer）"><a href="#9-变压器（Transformer）" class="headerlink" title="9. 变压器（Transformer）"></a>9. 变压器（Transformer）</h5><p>变压器模型通过自注意力机制处理序列数据，广泛应用于自然语言处理任务，如机器翻译和文本生成。</p>
<h5 id="10-图卷积层（Graph-Convolutional-Layer）"><a href="#10-图卷积层（Graph-Convolutional-Layer）" class="headerlink" title="10. 图卷积层（Graph Convolutional Layer）"></a>10. 图卷积层（Graph Convolutional Layer）</h5><p>图卷积层用于处理图结构数据，如社交网络和分子结构。</p>
<h5 id="结论-10"><a href="#结论-10" class="headerlink" title="结论"></a>结论</h5><p>除了隐藏层之外，深度学习模型中还有许多其他类型的可训练模块，它们在不同的任务和模型架构中起到了关键作用。理解和正确使用这些可训练模块，可以帮助你构建和优化深度学习模型，以满足各种任务的需求。</p>
<h3 id="LoRA参数"><a href="#LoRA参数" class="headerlink" title="LoRA参数"></a>LoRA参数</h3><h4 id="LoRA秩（LoRA-矩阵的秩大小）"><a href="#LoRA秩（LoRA-矩阵的秩大小）" class="headerlink" title="LoRA秩（LoRA 矩阵的秩大小）"></a>LoRA秩（LoRA 矩阵的秩大小）</h4><p>LoRA秩（Rank）指的是在低秩分解中所使用的矩阵的秩大小。具体来说，如果我们有一个权重矩阵 W<em>W</em> 需要微调，LoRA会将其分解为两个低秩矩阵 A<em>A</em> 和 B<em>B</em>，使得 W≈A⋅B<em>W</em>≈<em>A</em>⋅<em>B</em>。这里，矩阵 A<em>A</em> 和 B<em>B</em> 的秩大小决定了分解的质量和参数的数量。</p>
<h5 id="低秩分解"><a href="#低秩分解" class="headerlink" title="低秩分解"></a>低秩分解</h5><p>假设原始权重矩阵 W<em>W</em> 的维度是 m×n<em>m</em>×<em>n</em>，低秩分解将其分解为两个矩阵 A<em>A</em> 和 B<em>B</em>，其中 A<em>A</em> 的维度是 m×r<em>m</em>×<em>r</em>，B<em>B</em> 的维度是 r×n<em>r</em>×<em>n</em>，其中 r<em>r</em> 是秩大小（rank）。<br>W≈A⋅B<em>W</em>≈<em>A</em>⋅<em>B</em></p>
<h5 id="LoRA-秩大小的选择"><a href="#LoRA-秩大小的选择" class="headerlink" title="LoRA 秩大小的选择"></a>LoRA 秩大小的选择</h5><p>选择适当的秩大小 r<em>r</em> 是LoRA方法中的一个关键步骤。秩大小的选择会影响以下几个方面：</p>
<ol>
<li><strong>参数数量</strong>：较小的秩会显著减少参数数量，从而降低计算和存储成本。</li>
<li><strong>模型性能</strong>：较小的秩可能会导致信息丢失，从而影响模型性能。需要在参数数量和模型性能之间找到一个平衡点。</li>
<li><strong>训练速度</strong>：较小的秩通常会加快训练速度，因为需要更新的参数更少。</li>
</ol>
<h5 id="结论-11"><a href="#结论-11" class="headerlink" title="结论"></a>结论</h5><p>LoRA秩大小的选择在LoRA方法中扮演着重要角色。适当的秩大小可以在减少参数数量和保持模型性能之间找到平衡。通过低秩分解，我们可以在降低计算和存储成本的同时，保持模型的高效性和准确性。</p>
<h4 id="LoRA-缩放系数（LoRA-缩放系数大小）"><a href="#LoRA-缩放系数（LoRA-缩放系数大小）" class="headerlink" title="LoRA 缩放系数（LoRA 缩放系数大小）"></a>LoRA 缩放系数（LoRA 缩放系数大小）</h4><p>LoRA（Low-Rank Adaptation）中的缩放系数（Scaling Factor）是用于控制低秩矩阵在模型中的影响力的参数。通过调整缩放系数，可以在保持模型性能的同时，进一步优化计算和存储效率。</p>
<h5 id="LoRA-缩放系数的作用"><a href="#LoRA-缩放系数的作用" class="headerlink" title="LoRA 缩放系数的作用"></a>LoRA 缩放系数的作用</h5><p>缩放系数的主要作用是调节低秩矩阵对原始权重矩阵的贡献。具体来说，LoRA方法将原始权重矩阵 W<em>W</em> 分解为两个低秩矩阵 A<em>A</em> 和 B<em>B</em>，并引入一个缩放系数 α<em>α</em>，使得新的权重矩阵表示为：W′&#x3D;W+α⋅(A⋅B)<em>W</em>′&#x3D;<em>W</em>+<em>α</em>⋅(<em>A</em>⋅<em>B</em>)</p>
<p>其中：</p>
<ul>
<li>W<em>W</em> 是原始权重矩阵。</li>
<li>A<em>A</em> 和 B<em>B</em> 是低秩矩阵。</li>
<li>α<em>α</em> 是缩放系数。</li>
</ul>
<p>通过调整 α<em>α</em> 的大小，可以控制低秩矩阵 A⋅B<em>A</em>⋅<em>B</em> 对整个权重矩阵的影响力。</p>
<h5 id="选择合适的缩放系数"><a href="#选择合适的缩放系数" class="headerlink" title="选择合适的缩放系数"></a>选择合适的缩放系数</h5><p>选择合适的缩放系数 α<em>α</em> 是LoRA方法中的一个关键步骤。一般来说，缩放系数的选择会影响以下几个方面：</p>
<ol>
<li><strong>模型性能</strong>：过大的缩放系数可能会导致模型过拟合，而过小的缩放系数可能会导致模型欠拟合。</li>
<li><strong>训练稳定性</strong>：适当的缩放系数可以提高训练的稳定性，使模型更容易收敛。</li>
<li><strong>计算效率</strong>：通过合理选择缩放系数，可以在保证模型性能的前提下，进一步优化计算效率。</li>
</ol>
<h5 id="结论-12"><a href="#结论-12" class="headerlink" title="结论"></a>结论</h5><p>LoRA缩放系数在LoRA方法中扮演着重要角色。通过调整缩放系数，可以在保持模型性能的同时，进一步优化计算和存储效率。合理选择缩放系数，可以提高模型的训练稳定性和性能。</p>
<h4 id="LoRA-随机丢弃（LoRA-权重随机丢弃的概率）"><a href="#LoRA-随机丢弃（LoRA-权重随机丢弃的概率）" class="headerlink" title="LoRA 随机丢弃（LoRA 权重随机丢弃的概率）"></a>LoRA 随机丢弃（LoRA 权重随机丢弃的概率）</h4><p>LoRA（Low-Rank Adaptation）中的随机丢弃（Dropout）是一种正则化技术，用于防止模型过拟合。在LoRA方法中，随机丢弃可以应用于低秩矩阵的权重，以进一步提高模型的泛化能力。</p>
<h5 id="随机丢弃的作用"><a href="#随机丢弃的作用" class="headerlink" title="随机丢弃的作用"></a>随机丢弃的作用</h5><p>随机丢弃的主要作用是通过在训练过程中随机丢弃部分神经元来防止模型过拟合。具体来说，在每次训练迭代中，随机丢弃会以一定的概率 p<em>p</em> 将某些神经元的输出设为零，从而迫使模型在不同的训练迭代中学习不同的特征组合。<br>在LoRA方法中，随机丢弃可以应用于低秩矩阵 A<em>A</em> 和 B<em>B</em>，以进一步提高模型的泛化能力。</p>
<h5 id="随机丢弃的概率"><a href="#随机丢弃的概率" class="headerlink" title="随机丢弃的概率"></a>随机丢弃的概率</h5><p>随机丢弃的概率 p<em>p</em> 是一个介于0和1之间的值，表示每个神经元在训练过程中被丢弃的概率。常见的选择范围是0.1到0.5之间，但具体的值需要根据实际情况进行调优。</p>
<h5 id="结论-13"><a href="#结论-13" class="headerlink" title="结论"></a>结论</h5><p>LoRA中的随机丢弃是一种有效的正则化技术，通过在训练过程中随机丢弃部分神经元，可以防止模型过拟合，提高模型的泛化能力。合理选择随机丢弃的概率，可以进一步优化模型的性能和训练稳定性。</p>
<h4 id="LoRA-学习率比例（LoRA-中-B-矩阵的学习率倍数）"><a href="#LoRA-学习率比例（LoRA-中-B-矩阵的学习率倍数）" class="headerlink" title="LoRA+ 学习率比例（LoRA+ 中 B 矩阵的学习率倍数）"></a>LoRA+ 学习率比例（LoRA+ 中 B 矩阵的学习率倍数）</h4><p>在LoRA+方法中，学习率比例（Learning Rate Scaling）是一个重要的超参数，用于控制低秩矩阵 A<em>A</em> 和 B<em>B</em> 的学习率。特别是，LoRA+方法中常常会为低秩矩阵 B<em>B</em> 设置一个不同于其他参数的学习率倍数，以便更好地调整模型的参数。</p>
<h5 id="为什么需要不同的学习率？"><a href="#为什么需要不同的学习率？" class="headerlink" title="为什么需要不同的学习率？"></a>为什么需要不同的学习率？</h5><p>不同的学习率可以帮助模型更好地适应不同参数的更新需求。低秩矩阵 B<em>B</em> 的学习率倍数可以控制其更新速度，从而影响模型的训练效果和收敛速度。</p>
<h5 id="LoRA-中-B-矩阵的学习率倍数"><a href="#LoRA-中-B-矩阵的学习率倍数" class="headerlink" title="LoRA+ 中 B 矩阵的学习率倍数"></a>LoRA+ 中 B 矩阵的学习率倍数</h5><p>在LoRA+方法中，通常会为低秩矩阵 B<em>B</em> 设置一个学习率倍数 β<em>β</em>，使得 B<em>B</em> 的学习率为 β⋅base_lr<em>β</em>⋅base_lr，其中 base_lrbase_lr 是基础学习率。</p>
<h5 id="结论-14"><a href="#结论-14" class="headerlink" title="结论"></a>结论</h5><p>在LoRA+方法中，为低秩矩阵 B<em>B</em> 设置不同的学习率倍数可以帮助模型更好地适应不同参数的更新需求，从而提高模型的训练效果和收敛速度。合理选择学习率倍数，可以进一步优化模型的性能和训练稳定性。</p>
<h4 id="新建适配器"><a href="#新建适配器" class="headerlink" title="新建适配器"></a>新建适配器</h4><p>在深度学习中，适配器（Adapter）是一种轻量级的可插拔模块，通常用于微调预训练模型，以便在特定任务上取得更好的性能。创建一个新的适配器并在现有的适配器上进行随机初始化，可以帮助模型更好地适应新的任务。</p>
<p>通过在现有模型上创建一个随机初始化的新适配器，可以提高模型在特定任务上的性能。适配器模块的设计可以根据具体任务的需求进行调整，以便更好地适应不同的任务。</p>
<h4 id="使用-rslora（对-LoRA-层使用秩稳定缩放方法）"><a href="#使用-rslora（对-LoRA-层使用秩稳定缩放方法）" class="headerlink" title="使用 rslora（对 LoRA 层使用秩稳定缩放方法）"></a>使用 rslora（对 LoRA 层使用秩稳定缩放方法）</h4><p>RSLora（Rank-Stable LoRA）是一种改进的LoRA方法，旨在通过秩稳定缩放来增强模型的适应性和稳定性。在RSLora方法中，低秩矩阵的秩和缩放系数会动态调整，以便更好地适应不同的训练阶段和数据分布。</p>
<blockquote>
<p>RSLora方法通过引入秩稳定缩放，可以动态调整低秩矩阵的秩和缩放系数，从而提高模型的适应性和稳定性。合理选择秩缩放系数，可以进一步优化模型的性能和训练稳定性。</p>
</blockquote>
<h4 id="使用-DoRA（使用权重分解的-LoRA）"><a href="#使用-DoRA（使用权重分解的-LoRA）" class="headerlink" title="使用 DoRA（使用权重分解的 LoRA）"></a>使用 DoRA（使用权重分解的 LoRA）</h4><p>DoRA（Decomposed Rank Adaptation）是一种改进的LoRA方法，通过对权重矩阵进行分解来提高模型的适应性和性能。在DoRA方法中，权重矩阵被分解为多个低秩矩阵，以便更好地适应不同的训练阶段和数据分布。</p>
<blockquote>
<p>DoRA方法通过对权重矩阵进行分解，可以提高模型的适应性和性能。合理选择分解的数量和秩，可以进一步优化模型的性能和训练稳定性。</p>
</blockquote>
<h4 id="LoRA-作用模块"><a href="#LoRA-作用模块" class="headerlink" title="LoRA 作用模块"></a>LoRA 作用模块</h4><p>LoRA 作用模块指的是你希望应用LoRA技术的模型层或模块。通常，这些模块是模型中最重要和最复杂的部分，通过在这些模块上应用LoRA，可以显著提高模型的适应性和表现。</p>
<h5 id="常见的LoRA作用模块"><a href="#常见的LoRA作用模块" class="headerlink" title="常见的LoRA作用模块"></a>常见的LoRA作用模块</h5><ol>
<li><strong>Transformer层</strong>：<ul>
<li><strong>Self-Attention</strong>：自注意力机制是Transformer模型的核心部分，通过在此应用LoRA，可以有效地捕捉输入数据中的复杂关系。</li>
<li>**Feed-Forward Network (FFN)**：FFN是Transformer层中的全连接网络部分，通过在此应用LoRA，可以增强模型的非线性表达能力。</li>
</ul>
</li>
<li><strong>嵌入层</strong>：<ul>
<li><strong>词嵌入（Word Embeddings）</strong>：在自然语言处理任务中，词嵌入层是将词汇映射到向量空间的关键部分，通过在此应用LoRA，可以提高词汇表示的质量。</li>
<li><strong>位置嵌入（Positional Embeddings）</strong>：位置嵌入用于表示输入序列中各个位置的信息，通过在此应用LoRA，可以增强模型对序列信息的理解。</li>
</ul>
</li>
<li><strong>卷积层</strong>（对于卷积神经网络）：<ul>
<li><strong>卷积核（Convolutional Kernels）</strong>：在图像处理任务中，卷积层是提取图像特征的核心部分，通过在此应用LoRA，可以提高图像特征提取的效果。</li>
</ul>
</li>
</ol>
<h4 id="附加模块"><a href="#附加模块" class="headerlink" title="附加模块"></a>附加模块</h4><p>附加模块指的是除了LoRA层之外，模型中其他可以训练的模块。这些模块可能不是模型的核心部分，但通过对它们进行训练，可以进一步提高模型的性能和适应性。</p>
<h4 id="常见的附加模块"><a href="#常见的附加模块" class="headerlink" title="常见的附加模块"></a>常见的附加模块</h4><ol>
<li><strong>LayerNorm</strong>：</li>
</ol>
<ul>
<li>层归一化是Transformer模型中的标准化技术，通过对其进行训练，可以提高模型的稳定性和训练效果。</li>
</ul>
<ol>
<li><strong>Residual Connections</strong>：</li>
</ol>
<ul>
<li>残差连接用于在深度神经网络中传递信息，通过对其进行训练，可以增强模型的梯度传播和信息流动。</li>
</ul>
<ol>
<li><strong>Output Layer</strong>：</li>
</ol>
<ul>
<li>输出层是模型的最后一层，通过对其进行训练，可以提高模型的预测效果和准确性。</li>
</ul>
<h3 id="RLHF参数"><a href="#RLHF参数" class="headerlink" title="RLHF参数"></a>RLHF参数</h3><h4 id="Beta参数"><a href="#Beta参数" class="headerlink" title="Beta参数"></a>Beta参数</h4><p>在强化学习中的人类反馈（RLHF）过程中，损失函数中的超参数β（Beta）起着关键作用。β参数通常用于平衡不同损失项之间的权重，从而控制模型在训练过程中的行为和性能。</p>
<h5 id="RLHF中的Beta参数"><a href="#RLHF中的Beta参数" class="headerlink" title="RLHF中的Beta参数"></a>RLHF中的Beta参数</h5><p>在RLHF中，损失函数通常包含多个部分，例如奖励损失、行为克隆损失和正则化项。β参数用于调整这些损失项的相对重要性。</p>
<h6 id="1-奖励损失（Reward-Loss）"><a href="#1-奖励损失（Reward-Loss）" class="headerlink" title="1. 奖励损失（Reward Loss）"></a>1. 奖励损失（Reward Loss）</h6><p>奖励损失用于衡量模型的行为与期望奖励之间的差距。它反映了模型在执行动作后所获得的奖励。</p>
<h6 id="2-行为克隆损失（Behavior-Cloning-Loss）"><a href="#2-行为克隆损失（Behavior-Cloning-Loss）" class="headerlink" title="2. 行为克隆损失（Behavior Cloning Loss）"></a>2. 行为克隆损失（Behavior Cloning Loss）</h6><p>行为克隆损失用于衡量模型的行为与人类示范行为之间的差距。它反映了模型模仿人类行为的能力。</p>
<h6 id="3-正则化项（Regularization-Term）"><a href="#3-正则化项（Regularization-Term）" class="headerlink" title="3. 正则化项（Regularization Term）"></a>3. 正则化项（Regularization Term）</h6><p>正则化项用于防止模型过拟合，通常通过添加一些约束来控制模型的复杂度。</p>
<h5 id="Beta参数的作用"><a href="#Beta参数的作用" class="headerlink" title="Beta参数的作用"></a>Beta参数的作用</h5><p>通过调整β参数，可以控制不同损失项之间的平衡，从而影响模型的训练过程和最终性能。</p>
<h6 id="1-调整奖励损失的权重"><a href="#1-调整奖励损失的权重" class="headerlink" title="1. 调整奖励损失的权重"></a>1. 调整奖励损失的权重</h6><p>通过增加β参数的值，可以增加奖励损失在总损失中的权重，从而使模型更关注获得高奖励的行为。这在需要模型最大化奖励的任务中非常有用。</p>
<h6 id="2-调整行为克隆损失的权重"><a href="#2-调整行为克隆损失的权重" class="headerlink" title="2. 调整行为克隆损失的权重"></a>2. 调整行为克隆损失的权重</h6><p>通过减小β参数的值，可以增加行为克隆损失在总损失中的权重，从而使模型更关注模仿人类行为。这在需要模型严格遵循人类示范行为的任务中非常有用。</p>
<h6 id="3-控制正则化项的影响"><a href="#3-控制正则化项的影响" class="headerlink" title="3. 控制正则化项的影响"></a>3. 控制正则化项的影响</h6><p>通过调整β参数，可以控制正则化项在总损失中的权重，从而影响模型的复杂度和泛化能力。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>假设我们有一个包含奖励损失、行为克隆损失和正则化项的总损失函数：Ltotal&#x3D;β1Lreward+β2Lbehavior+β3Lregularization<em>L</em>total&#x3D;<em>β</em>1<em>L</em>reward+<em>β</em>2<em>L</em>behavior+<em>β</em>3<em>L</em>regularization</p>
<p>其中，β1<em>β</em>1、β2<em>β</em>2 和 β3<em>β</em>3 是分别用于奖励损失、行为克隆损失和正则化项的权重超参数。</p>
<h6 id="调整Beta参数"><a href="#调整Beta参数" class="headerlink" title="调整Beta参数"></a>调整Beta参数</h6><ol>
<li><strong>增加奖励损失权重</strong>：</li>
</ol>
<ul>
<li>如果我们希望模型更加关注获得高奖励的行为，可以增大 β1<em>β</em>1 的值。例如，设定 β1&#x3D;2.0<em>β</em>1&#x3D;2.0。</li>
</ul>
<ol>
<li><strong>增加行为克隆损失权重</strong>：</li>
</ol>
<ul>
<li>如果我们希望模型更加关注模仿人类行为，可以增大 β2<em>β</em>2 的值。例如，设定 β2&#x3D;1.5<em>β</em>2&#x3D;1.5。</li>
</ul>
<ol>
<li><strong>增加正则化项权重</strong>：</li>
</ol>
<ul>
<li>如果我们希望防止模型过拟合，可以增大 β3<em>β</em>3 的值。例如，设定 β3&#x3D;0.5<em>β</em>3&#x3D;0.5。</li>
</ul>
<h5 id="结论-15"><a href="#结论-15" class="headerlink" title="结论"></a>结论</h5><p>Beta参数在RLHF中用于调整不同损失项的相对权重，从而控制模型的训练过程和最终性能。通过合理调整Beta参数，可以使模型在奖励最大化、行为模仿和正则化之间达到平衡，从而提高模型的整体表现。</p>
<h4 id="Ftx-gamma"><a href="#Ftx-gamma" class="headerlink" title="Ftx gamma"></a>Ftx gamma</h4><p>在强化学习中的人类反馈（RLHF）过程中，损失函数中的超参数γ（Gamma）用于控制监督微调（Supervised Fine-Tuning, SFT）损失的权重。γ参数的选择对模型的训练过程和最终性能有重要影响。</p>
<h5 id="RLHF中的Gamma参数"><a href="#RLHF中的Gamma参数" class="headerlink" title="RLHF中的Gamma参数"></a>RLHF中的Gamma参数</h5><p>在RLHF过程中，损失函数通常包含多个部分，例如奖励损失、行为克隆损失、监督微调损失和正则化项。γ参数用于调整监督微调损失在总损失中的相对权重。</p>
<h6 id="1-奖励损失（Reward-Loss）-1"><a href="#1-奖励损失（Reward-Loss）-1" class="headerlink" title="1. 奖励损失（Reward Loss）"></a>1. 奖励损失（Reward Loss）</h6><p>奖励损失用于衡量模型的行为与期望奖励之间的差距。</p>
<h6 id="2-行为克隆损失（Behavior-Cloning-Loss）-1"><a href="#2-行为克隆损失（Behavior-Cloning-Loss）-1" class="headerlink" title="2. 行为克隆损失（Behavior Cloning Loss）"></a>2. 行为克隆损失（Behavior Cloning Loss）</h6><p>行为克隆损失用于衡量模型的行为与人类示范行为之间的差距。</p>
<h6 id="3-监督微调损失（SFT-Loss）"><a href="#3-监督微调损失（SFT-Loss）" class="headerlink" title="3. 监督微调损失（SFT Loss）"></a>3. 监督微调损失（SFT Loss）</h6><p>监督微调损失用于衡量模型生成的输出与预期的监督数据之间的差距。它通常用于在初始阶段对模型进行微调，使其更好地适应特定任务。</p>
<h6 id="4-正则化项（Regularization-Term）"><a href="#4-正则化项（Regularization-Term）" class="headerlink" title="4. 正则化项（Regularization Term）"></a>4. 正则化项（Regularization Term）</h6><p>正则化项用于防止模型过拟合，控制模型的复杂度。</p>
<h5 id="Gamma参数的作用"><a href="#Gamma参数的作用" class="headerlink" title="Gamma参数的作用"></a>Gamma参数的作用</h5><p>通过调整γ参数，可以控制监督微调损失在总损失中的权重，从而影响模型的训练过程和最终性能。</p>
<h6 id="1-增加监督微调损失的权重"><a href="#1-增加监督微调损失的权重" class="headerlink" title="1. 增加监督微调损失的权重"></a>1. 增加监督微调损失的权重</h6><p>通过增加γ参数的值，可以增加监督微调损失在总损失中的权重，使模型更关注与监督数据的匹配。这在模型需要严格遵循监督数据的任务中非常有用。</p>
<h6 id="2-减少监督微调损失的权重"><a href="#2-减少监督微调损失的权重" class="headerlink" title="2. 减少监督微调损失的权重"></a>2. 减少监督微调损失的权重</h6><p>通过减小γ参数的值，可以减少监督微调损失在总损失中的权重，使模型更关注其他损失项（如奖励损失和行为克隆损失）。这在模型需要更灵活地适应环境变化的任务中非常有用。</p>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><p>假设我们有一个包含奖励损失、行为克隆损失、监督微调损失和正则化项的总损失函数：Ltotal&#x3D;αLreward+βLbehavior+γLSFT+δLregularization<em>L</em>total&#x3D;<em>α**L</em>reward+<em>β**L</em>behavior+<em>γ**L</em>SFT+<em>δ**L</em>regularization<br>其中，α<em>α</em>、β<em>β</em>、γ<em>γ</em> 和 δ<em>δ</em> 是分别用于奖励损失、行为克隆损失、监督微调损失和正则化项的权重超参数。</p>
<h5 id="调整Gamma参数"><a href="#调整Gamma参数" class="headerlink" title="调整Gamma参数"></a>调整Gamma参数</h5><ol>
<li><strong>增加监督微调损失权重</strong>：</li>
</ol>
<ul>
<li>如果我们希望模型更加关注与监督数据的匹配，可以增大 γ<em>γ</em> 的值。例如，设定 γ&#x3D;1.5<em>γ</em>&#x3D;1.5。</li>
</ul>
<ol>
<li><strong>减少监督微调损失权重</strong>：</li>
</ol>
<ul>
<li>如果我们希望模型更加关注奖励和行为克隆损失，可以减小 γ<em>γ</em> 的值。例如，设定 γ&#x3D;0.5<em>γ</em>&#x3D;0.5。</li>
</ul>
<h5 id="结论-16"><a href="#结论-16" class="headerlink" title="结论"></a>结论</h5><p>Gamma参数在RLHF中用于调整监督微调损失的相对权重，从而控制模型的训练过程和最终性能。通过合理调整Gamma参数，可以使模型在监督数据匹配、奖励最大化和行为模仿之间达到平衡，从而提高模型的整体表现。</p>
<h4 id="损失函数类型"><a href="#损失函数类型" class="headerlink" title="损失函数类型"></a>损失函数类型</h4><h5 id="sigmoid"><a href="#sigmoid" class="headerlink" title="sigmoid"></a>sigmoid</h5><p>在机器学习和深度学习中，损失函数是用于衡量模型预测与真实标签之间差距的函数。不同的损失函数适用于不同的任务和模型架构。Sigmoid损失函数是一种常用的损失函数，特别适用于二分类问题。</p>
<h6 id="Sigmoid-损失函数"><a href="#Sigmoid-损失函数" class="headerlink" title="Sigmoid 损失函数"></a>Sigmoid 损失函数</h6><p>Sigmoid损失函数通常与二分类问题中的逻辑回归模型或神经网络中的输出层一起使用。它结合了Sigmoid激活函数和二元交叉熵损失函数。</p>
<ol>
<li><strong>Sigmoid 激活函数</strong></li>
</ol>
<p>Sigmoid激活函数将输入值映射到0到1之间的概率值。其数学表达式为：σ(x)&#x3D;11+e−x<em>σ</em>(<em>x</em>)&#x3D;1+<em>e</em>−<em>x</em>1</p>
<ol>
<li><strong>二元交叉熵损失函数</strong></li>
</ol>
<p>二元交叉熵损失函数用于衡量模型预测的概率分布与真实标签之间的差距。其数学表达式为：LBCE&#x3D;−1N∑i&#x3D;1N[yilog⁡(y^i)+(1−yi)log⁡(1−y^i)]<em>L</em>BCE&#x3D;−<em>N</em>1∑<em>i</em>&#x3D;1<em>N</em>[<em>y**i</em>log(<em>y</em>^<em>i</em>)+(1−<em>y**i</em>)log(1−<em>y</em>^<em>i</em>)]</p>
<p>其中：</p>
<ul>
<li>N<em>N</em> 是样本数量</li>
<li>yi<em>y**i</em> 是第 i<em>i</em> 个样本的真实标签（0或1）</li>
<li>y^i<em>y</em>^<em>i</em> 是第 i<em>i</em> 个样本的预测概率（通过Sigmoid激活函数计算得到）</li>
</ul>
<h6 id="Sigmoid-损失函数的应用"><a href="#Sigmoid-损失函数的应用" class="headerlink" title="Sigmoid 损失函数的应用"></a>Sigmoid 损失函数的应用</h6><p>Sigmoid损失函数在以下场景中非常常见：</p>
<ol>
<li><strong>二分类问题</strong></li>
</ol>
<p>在二分类问题中，Sigmoid损失函数用于衡量模型预测的正类或负类概率与真实标签之间的差距。常见的应用包括垃圾邮件检测、图像分类（如猫狗分类）等。</p>
<ol>
<li><strong>多标签分类问题</strong></li>
</ol>
<p>在多标签分类问题中，每个标签独立地进行二分类，Sigmoid损失函数可以用于每个标签的二分类任务。常见的应用包括多标签图像标注、文本分类等。</p>
<h6 id="结论-17"><a href="#结论-17" class="headerlink" title="结论"></a>结论</h6><p>Sigmoid损失函数结合了Sigmoid激活函数和二元交叉熵损失函数，广泛应用于二分类和多标签分类问题中。通过将模型输出映射到概率值，并计算与真实标签之间的差距，Sigmoid损失函数能够有效地指导模型训练，提高分类性能。</p>
<h5 id="hinge"><a href="#hinge" class="headerlink" title="hinge"></a>hinge</h5><p>Hinge损失函数，或称为铰链损失函数，主要用于支持向量机（SVM）和一些二分类任务中。它在分类问题中帮助模型最大化分类边界的间隔，从而提高分类的鲁棒性和准确性。</p>
<h6 id="Hinge-损失函数"><a href="#Hinge-损失函数" class="headerlink" title="Hinge 损失函数"></a>Hinge 损失函数</h6><p>Hinge损失函数用于衡量模型预测与真实标签之间的差距，特别是对于线性分类器。其数学表达式为：Lhinge&#x3D;max⁡(0,1−yi⋅y^i)<em>L</em>hinge&#x3D;max(0,1−<em>y**i</em>⋅<em>y</em>^<em>i</em>)</p>
<p>其中：</p>
<ul>
<li>yi<em>y**i</em> 是第 i<em>i</em> 个样本的真实标签（取值为 -1 或 1）</li>
<li>y^i<em>y</em>^<em>i</em> 是第 i<em>i</em> 个样本的预测值（通常是未经过激活函数的线性输出）</li>
</ul>
<h6 id="Hinge-损失函数的特点"><a href="#Hinge-损失函数的特点" class="headerlink" title="Hinge 损失函数的特点"></a>Hinge 损失函数的特点</h6><ol>
<li><strong>边界最大化</strong>：Hinge损失函数通过最大化分类边界的间隔，确保模型不仅正确分类样本，还尽可能远离分类边界，从而提高分类的鲁棒性。</li>
<li><strong>适用于硬边界分类</strong>：Hinge损失函数特别适用于硬边界分类任务，即模型需要严格区分正类和负类样本。</li>
<li><strong>非平滑性</strong>：Hinge损失函数在 1−yi⋅y^i&#x3D;01−<em>y**i</em>⋅<em>y</em>^<em>i</em>&#x3D;0 处是非平滑的，这使得其在优化过程中可能会有一些挑战。</li>
</ol>
<h6 id="Hinge-损失函数的应用"><a href="#Hinge-损失函数的应用" class="headerlink" title="Hinge 损失函数的应用"></a>Hinge 损失函数的应用</h6><p>Hinge损失函数在以下场景中非常常见：</p>
<ol>
<li><strong>支持向量机（SVM）</strong></li>
</ol>
<p>Hinge损失函数是SVM的核心部分，通过最大化分类边界的间隔，SVM能够有效地处理高维数据和线性不可分的数据。</p>
<ol>
<li><strong>二分类任务</strong></li>
</ol>
<p>在一些二分类任务中，Hinge损失函数可以用于确保模型对正类和负类样本进行严格区分，特别是在需要硬边界分类的场景中。</p>
<h6 id="Hinge-损失函数的变体"><a href="#Hinge-损失函数的变体" class="headerlink" title="Hinge 损失函数的变体"></a>Hinge 损失函数的变体</h6><p>除了标准的Hinge损失函数，还有一些变体，例如：</p>
<ol>
<li><strong>平滑Hinge损失（Smooth Hinge Loss）</strong></li>
</ol>
<p>平滑Hinge损失通过引入平滑项，使得损失函数在优化过程中更加平滑和稳定。</p>
<ol>
<li><strong>多分类Hinge损失（Multiclass Hinge Loss</strong>）</li>
</ol>
<p>多分类Hinge损失用于多分类任务，通过对每个类别分别计算Hinge损失，并结合Softmax函数来处理多类别分类问题。</p>
<h6 id="结论-18"><a href="#结论-18" class="headerlink" title="结论"></a>结论</h6><p>Hinge损失函数在分类任务中，通过最大化分类边界的间隔，提高模型的鲁棒性和准确性。它在支持向量机（SVM）和一些二分类任务中得到了广泛应用。通过合理使用Hinge损失函数，可以有效地指导模型训练，提高分类性能。</p>
<h4 id="ipo"><a href="#ipo" class="headerlink" title="ipo"></a>ipo</h4><p>身份偏好优化（Identity Preference Optimization, IPO）是一种用于强化学习和人类反馈（Reinforcement Learning from Human Feedback, RLHF）中的损失函数优化方法。IPO 旨在通过优化模型的偏好来提高生成结果的质量和一致性。以下是对 IPO 及其在 RLHF 中应用的详细解释。</p>
<h5 id="什么是身份偏好优化-IPO-？"><a href="#什么是身份偏好优化-IPO-？" class="headerlink" title="什么是身份偏好优化 (IPO)？"></a>什么是身份偏好优化 (IPO)？</h5><p>身份偏好优化（IPO）是一种优化技术，主要用于通过人类反馈来调整模型的生成行为。在 RLHF 中，IPO 通过比较模型生成的多个候选结果，并根据人类反馈来优化模型的偏好，使其更符合人类的期望。</p>
<h5 id="IPO-的工作原理"><a href="#IPO-的工作原理" class="headerlink" title="IPO 的工作原理"></a>IPO 的工作原理</h5><ol>
<li><strong>生成候选结果</strong>：模型生成多个候选结果（例如，多个句子或图像）。</li>
<li><strong>人类反馈</strong>：人类评估者对这些候选结果进行打分或排序，表示他们的偏好。</li>
<li><strong>优化偏好</strong>：基于人类反馈，使用 IPO 方法调整模型的参数，使其生成的结果更符合人类的偏好。</li>
</ol>
<h5 id="IPO-中的损失函数"><a href="#IPO-中的损失函数" class="headerlink" title="IPO 中的损失函数"></a>IPO 中的损失函数</h5><p>IPO 的关键在于设计一个合适的损失函数，以有效地将人类偏好转化为模型的优化目标。常见的损失函数类型包括：</p>
<ol>
<li><strong>对比损失（Contrastive Loss）</strong>：用于比较两个候选结果的优劣，优化模型生成更优的结果。</li>
<li><strong>排序损失（Ranking Loss）</strong>：根据人类反馈对候选结果进行排序，优化模型生成的结果顺序。</li>
<li><strong>加权损失（Weighted Loss）</strong>：根据人类反馈的权重，优化模型生成结果的质量。</li>
</ol>
<h5 id="IPO-的优势"><a href="#IPO-的优势" class="headerlink" title="IPO 的优势"></a>IPO 的优势</h5><ol>
<li><strong>人类反馈驱动</strong>：通过直接利用人类反馈，IPO 可以有效地优化模型，使其生成的结果更符合人类的期望。</li>
<li><strong>灵活性</strong>：IPO 可以适用于各种生成任务，如文本生成、图像生成等。</li>
<li><strong>提高生成质量</strong>：通过优化模型的偏好，IPO 可以提高生成结果的质量和一致性。</li>
</ol>
<h5 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h5><p>身份偏好优化（IPO）是一种通过人类反馈来优化模型生成行为的技术。通过设计合适的损失函数，IPO 可以有效地将人类偏好转化为模型的优化目标，从而提高生成结果的质量和一致性。IPO 在强化学习和人类反馈（RLHF）中的应用具有广泛的前景，能够显著提升生成模型的性能和用户体验。</p>
<h4 id="kto-pair"><a href="#kto-pair" class="headerlink" title="kto_pair"></a>kto_pair</h4><p>KTO（Kahneman-Tversky Optimization）是一种基于行为经济学理论的优化方法。它是由著名心理学家丹尼尔·卡尼曼（Daniel Kahneman）和阿莫斯·特沃斯基（Amos Tversky）提出的前景理论（Prospect Theory）衍生出来的一种优化策略。KTO 旨在通过模拟人类决策过程中的偏好和风险态度来优化模型的行为。</p>
<h5 id="Kahneman-Tversky-优化（KTO）的核心思想"><a href="#Kahneman-Tversky-优化（KTO）的核心思想" class="headerlink" title="Kahneman-Tversky 优化（KTO）的核心思想"></a>Kahneman-Tversky 优化（KTO）的核心思想</h5><p>KTO 的核心思想是基于前景理论，该理论描述了人类在面临风险和不确定性时的决策行为。前景理论认为，人们在决策时会受到以下两种主要因素的影响：</p>
<ol>
<li><strong>价值函数（Value Function）</strong>：描述人们如何评估不同结果的价值。价值函数通常是凹形的，用于描述人们对收益的风险厌恶，以及凸形的，用于描述人们对损失的风险偏好。</li>
<li><strong>概率加权函数（Probability Weighting Function）</strong>：描述人们如何感知和处理概率。人们通常会高估小概率事件的发生概率，低估大概率事件的发生概率。</li>
</ol>
<h5 id="KTO-的工作原理"><a href="#KTO-的工作原理" class="headerlink" title="KTO 的工作原理"></a>KTO 的工作原理</h5><p>在 KTO 中，通过定义价值函数和概率加权函数，优化模型的行为，使其更符合人类的决策偏好。以下是 KTO 的基本步骤：</p>
<ol>
<li><strong>定义价值函数</strong>：根据前景理论定义一个价值函数，用于评估不同结果的价值。</li>
<li><strong>定义概率加权函数</strong>：根据前景理论定义一个概率加权函数，用于描述人们对不同概率的感知。</li>
<li><strong>计算预期价值</strong>：结合价值函数和概率加权函数，计算每个候选结果的预期价值。</li>
<li><strong>优化决策</strong>：选择预期价值最高的结果，优化模型的行为。</li>
</ol>
<h5 id="价值函数和概率加权函数的示例"><a href="#价值函数和概率加权函数的示例" class="headerlink" title="价值函数和概率加权函数的示例"></a>价值函数和概率加权函数的示例</h5><h6 id="价值函数"><a href="#价值函数" class="headerlink" title="价值函数"></a>价值函数</h6><p>价值函数通常具有以下形式：</p>
<p>V(x)&#x3D;{xαamp;如果 x≥0−λ(−x)βamp;如果 xlt;0<em>V</em>(<em>x</em>)&#x3D;{<em>x**α</em>−<em>λ</em>(−<em>x</em>)<em>β<strong>am</strong>p</em>;如果 <em>x</em>≥0<em>am**p</em>;如果 <em>x**lt</em>;0</p>
<p>其中，α<em>α</em> 和 β<em>β</em> 是描述收益和损失的曲线形状的参数，λ<em>λ</em> 是描述损失厌恶程度的参数。</p>
<h6 id="概率加权函数"><a href="#概率加权函数" class="headerlink" title="概率加权函数"></a>概率加权函数</h6><p>概率加权函数通常具有以下形式：π(p)&#x3D;pγ(pγ+(1−p)γ)1&#x2F;γ<em>π</em>(<em>p</em>)&#x3D;(<em>p**γ</em>+(1−<em>p</em>)<em>γ</em>)1&#x2F;<em>γ<strong>p</strong>γ</em><br>其中，γ<em>γ</em> 是描述概率感知的参数。</p>
<h5 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h5><p>Kahneman-Tversky 优化（KTO）是一种基于前景理论的优化方法，通过模拟人类在决策过程中的偏好和风险态度，优化模型的行为。KTO 通过定义价值函数和概率加权函数，计算候选结果的预期价值，选择最优结果，从而提高模型的决策质量。KTO 在强化学习和行为经济学中的应用具有广泛的前景，能够显著提升模型的性能和用户体验。</p>
<h4 id="orpo"><a href="#orpo" class="headerlink" title="orpo"></a>orpo</h4><p>ORPO（Monolithic Preference Optimization without Reference Model）是一种新的偏好优化方法，旨在优化生成模型的行为，而无需参考模型。ORPO 通过直接利用人类反馈，优化生成模型，使其更符合人类的期望。以下是对 ORPO 及其在强化学习和人类反馈（RLHF）中的应用的详细解释。</p>
<h5 id="ORPO-的核心思想"><a href="#ORPO-的核心思想" class="headerlink" title="ORPO 的核心思想"></a>ORPO 的核心思想</h5><p>ORPO 的核心思想是通过直接优化生成模型的偏好，而不依赖参考模型。传统的偏好优化方法通常会利用一个参考模型来指导优化过程，而 ORPO 则直接利用人类反馈，简化了优化过程，并提高了效率和性能。</p>
<h5 id="ORPO-的工作原理"><a href="#ORPO-的工作原理" class="headerlink" title="ORPO 的工作原理"></a>ORPO 的工作原理</h5><p>ORPO 的工作原理包括以下几个步骤：</p>
<ol>
<li><strong>生成候选结果</strong>：模型生成多个候选结果（例如，多个句子或图像）。</li>
<li><strong>人类反馈</strong>：人类评估者对这些候选结果进行打分或排序，表示他们的偏好。</li>
<li><strong>优化偏好</strong>：基于人类反馈，使用 ORPO 方法直接调整生成模型的参数，使其生成的结果更符合人类的偏好。</li>
</ol>
<h5 id="ORPO-的优势"><a href="#ORPO-的优势" class="headerlink" title="ORPO 的优势"></a>ORPO 的优势</h5><ol>
<li><strong>无需参考模型</strong>：ORPO 不依赖参考模型，简化了优化过程，减少了计算资源的消耗。</li>
<li><strong>直接优化</strong>：通过直接利用人类反馈，ORPO 可以更高效地优化生成模型的行为。</li>
<li><strong>性能提升</strong>：ORPO 在生成结果的质量和一致性方面表现更优，能够更好地满足人类的期望。</li>
</ol>
<h5 id="ORPO-的实现步骤"><a href="#ORPO-的实现步骤" class="headerlink" title="ORPO 的实现步骤"></a>ORPO 的实现步骤</h5><ol>
<li><strong>数据准备</strong>：收集并整理人类反馈数据，包括输入和相应的偏好评分。</li>
<li><strong>模型初始化</strong>：定义生成模型的结构，并初始化模型参数和优化器。</li>
<li><strong>定义损失函数</strong>：根据人类反馈定义偏好优化损失函数。</li>
<li><strong>训练模型</strong>：通过前向传播、损失计算和反向传播，优化模型参数，使其生成的结果更符合人类的偏好。</li>
</ol>
<h5 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h5><p>ORPO（Monolithic Preference Optimization without Reference Model）是一种新的偏好优化方法，通过直接利用人类反馈，优化生成模型的行为，而无需参考模型。ORPO 简化了优化过程，提高了训练效率和生成结果的质量。与传统的偏好优化方法相比，ORPO 在性能和一致性方面表现更优，成为一种有前景的 RLHF 优化方案。</p>
<h4 id="simpo"><a href="#simpo" class="headerlink" title="simpo"></a>simpo</h4><p>SimPO（Simple Preference Optimization）是斯坦福大学陈丹琦团队提出的一种简单的强化学习和人类反馈（RLHF）优化方法。它旨在通过简化 RLHF 的训练过程，提供一种高效且性能优越的替代方案。根据你的描述，SimPO 的性能远超 DPO（Direct Preference Optimization），这表明它在实际应用中具有显著的优势。</p>
<h5 id="SimPO-的核心思想"><a href="#SimPO-的核心思想" class="headerlink" title="SimPO 的核心思想"></a>SimPO 的核心思想</h5><p>SimPO 的核心思想是通过简化 RLHF 的训练过程，使得模型能够更高效地学习人类偏好，从而提高生成结果的质量。具体来说，SimPO 通过以下几个关键步骤来实现这一目标：</p>
<ol>
<li><strong>简化的偏好优化</strong>：通过简化偏好优化过程，减少训练复杂度和时间。</li>
<li><strong>高效的反馈利用</strong>：利用人类反馈信息，优化模型的生成行为，使其更符合人类的期望。</li>
<li><strong>性能提升</strong>：通过优化算法和模型结构，提高生成结果的质量和一致性。</li>
</ol>
<h5 id="SimPO-的工作原理"><a href="#SimPO-的工作原理" class="headerlink" title="SimPO 的工作原理"></a>SimPO 的工作原理</h5><p>SimPO 的工作原理包括以下几个步骤：</p>
<ol>
<li><strong>生成候选结果</strong>：模型生成多个候选结果（例如，多个句子或图像）。</li>
<li><strong>人类反馈</strong>：人类评估者对这些候选结果进行打分或排序，表示他们的偏好。</li>
<li><strong>优化偏好</strong>：基于人类反馈，使用 SimPO 方法调整模型的参数，使其生成的结果更符合人类的偏好。</li>
</ol>
<h5 id="SimPO-与-DPO-的对比"><a href="#SimPO-与-DPO-的对比" class="headerlink" title="SimPO 与 DPO 的对比"></a>SimPO 与 DPO 的对比</h5><p>SimPO 与 DPO（Direct Preference Optimization）相比，具有以下几个优势：</p>
<ol>
<li><strong>训练效率</strong>：SimPO 通过简化训练过程，显著减少了训练时间和计算资源的消耗。</li>
<li><strong>性能提升</strong>：SimPO 在生成结果的质量和一致性方面表现更优，能够更好地满足人类的期望。</li>
<li><strong>易于实现</strong>：SimPO 的实现相对简单，更容易集成到现有的生成模型和训练框架中。</li>
</ol>
<h5 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h5><p>SimPO（Simple Preference Optimization）是斯坦福大学陈丹琦团队提出的一种高效的 RLHF 优化方法。通过简化训练过程和高效利用人类反馈，SimPO 显著提升了生成模型的性能和一致性。与 DPO 相比，SimPO 在训练效率和生成结果质量方面表现更优，成为一种有前景的 RLHF 替代方案。</p>
<h3 id="GaLore"><a href="#GaLore" class="headerlink" title="GaLore"></a>GaLore</h3><h4 id="GaLore参数"><a href="#GaLore参数" class="headerlink" title="GaLore参数"></a>GaLore参数</h4><p>“GaLore” 参数代表的是“使用梯度低秩投影”（Gradient Low-Rank Projection）。这种方法在深度学习模型的微调过程中被用来提高训练效率和性能。</p>
<h5 id="什么是梯度低秩投影？"><a href="#什么是梯度低秩投影？" class="headerlink" title="什么是梯度低秩投影？"></a>什么是梯度低秩投影？</h5><p>梯度低秩投影是一种优化技术，用于在训练神经网络时减少计算量和内存使用。这种方法通过将梯度矩阵投影到一个低秩子空间中，从而减少了参数更新的复杂性。</p>
<h5 id="为什么使用梯度低秩投影？"><a href="#为什么使用梯度低秩投影？" class="headerlink" title="为什么使用梯度低秩投影？"></a>为什么使用梯度低秩投影？</h5><ol>
<li><strong>计算效率</strong>：通过将梯度矩阵投影到低秩子空间，可以显著减少计算量，提高训练速度。</li>
<li><strong>内存节省</strong>：低秩投影减少了梯度矩阵的维度，从而减少了内存使用。</li>
<li><strong>避免过拟合</strong>：在某些情况下，低秩投影可以起到正则化的作用，帮助模型避免过拟合。</li>
</ol>
<h5 id="GaLore-参数在微调中的作用"><a href="#GaLore-参数在微调中的作用" class="headerlink" title="GaLore 参数在微调中的作用"></a>GaLore 参数在微调中的作用</h5><p>在微调过程中，GaLore 参数用于控制是否应用梯度低秩投影。启用这个参数后，训练过程会对梯度矩阵进行低秩投影，从而实现上述的优势。</p>
<h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><ol>
<li><strong>梯度计算</strong>：首先计算出完整的梯度矩阵。</li>
<li><strong>低秩近似</strong>：使用某种低秩近似方法（如SVD分解）将梯度矩阵分解为低秩形式。</li>
<li><strong>梯度更新</strong>：使用低秩形式的梯度进行参数更新。</li>
</ol>
<h5 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h5><p>“GaLore” 参数通过启用梯度低秩投影，帮助在模型微调过程中提高计算效率、节省内存并可能避免过拟合。具体的实现和效果可能依赖于你所使用的框架和数据集，因此建议参考相关文档和资源以获得最佳实践。</p>
<h4 id="GaLore秩"><a href="#GaLore秩" class="headerlink" title="GaLore秩"></a>GaLore秩</h4><p>“GaLore秩”（GaLore Rank）指的是在应用梯度低秩投影时所选择的秩大小。秩大小决定了梯度矩阵在投影到低秩子空间后的维度。选择合适的秩大小对于平衡计算效率和模型性能非常重要。</p>
<h5 id="选择GaLore秩的影响"><a href="#选择GaLore秩的影响" class="headerlink" title="选择GaLore秩的影响"></a>选择GaLore秩的影响</h5><ol>
<li><strong>计算效率</strong>：较低的秩会减少计算量和内存使用，但可能会丢失一些重要的梯度信息。</li>
<li><strong>模型性能</strong>：较高的秩会保留更多的梯度信息，有助于更准确地更新模型参数，但会增加计算和内存开销。</li>
<li><strong>正则化效果</strong>：适当的低秩可以起到正则化的作用，帮助模型避免过拟合。</li>
</ol>
<h5 id="如何选择合适的GaLore秩"><a href="#如何选择合适的GaLore秩" class="headerlink" title="如何选择合适的GaLore秩"></a>如何选择合适的GaLore秩</h5><p>选择合适的秩通常需要在计算效率和模型性能之间进行权衡。以下是一些建议：</p>
<ol>
<li><strong>实验验证</strong>：通过实验验证不同秩大小对模型性能和训练速度的影响。</li>
<li><strong>数据集大小和复杂性</strong>：对于较大的数据集和复杂的模型，可能需要较高的秩以保留更多的梯度信息。</li>
<li><strong>应用场景</strong>：根据具体的应用场景和性能要求进行调整。例如，在实时应用中，计算效率可能比模型性能更重要。</li>
</ol>
<h5 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h5><p>“GaLore秩”决定了梯度低秩投影的维度大小，是影响计算效率和模型性能的关键参数。选择合适的秩需要根据具体的应用场景和性能要求进行权衡和实验验证。通过合理设置GaLore秩，可以在提高计算效率的同时，保持较好的模型性能。</p>
<h4 id="更新间隔"><a href="#更新间隔" class="headerlink" title="更新间隔"></a>更新间隔</h4><p>“更新间隔”指的是在训练过程中，相邻两次进行梯度低秩投影更新之间的步数。这个参数决定了多长时间（以训练步数为单位）进行一次梯度低秩投影，从而影响训练效率和模型性能。</p>
<h5 id="选择合适的更新间隔"><a href="#选择合适的更新间隔" class="headerlink" title="选择合适的更新间隔"></a>选择合适的更新间隔</h5><ol>
<li><strong>频繁更新</strong>：如果更新间隔较短（即频繁进行梯度低秩投影），可以更频繁地减少梯度矩阵的维度，从而节省计算资源和内存。但是，频繁更新也可能增加计算开销，因为每次投影本身也是有成本的。</li>
<li><strong>间隔较长</strong>：如果更新间隔较长（即较少进行梯度低秩投影），则模型会在较长时间内使用完整的梯度矩阵进行更新，可能会提高模型的性能，但计算资源和内存的节省效果会减弱。</li>
</ol>
<h5 id="如何选择合适的更新间隔"><a href="#如何选择合适的更新间隔" class="headerlink" title="如何选择合适的更新间隔"></a>如何选择合适的更新间隔</h5><p>选择合适的更新间隔通常需要在计算效率和模型性能之间进行权衡。以下是一些建议：</p>
<ol>
<li><strong>实验验证</strong>：通过实验验证不同更新间隔对模型性能和训练速度的影响。</li>
<li><strong>数据集大小和复杂性</strong>：对于较大的数据集和复杂的模型，可能需要较短的更新间隔以更频繁地进行低秩投影，从而节省计算资源。</li>
<li><strong>应用场景</strong>：根据具体的应用场景和性能要求进行调整。例如，在实时应用中，计算效率可能比模型性能更重要。</li>
</ol>
<h5 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h5><p>“更新间隔”参数决定了相邻两次进行梯度低秩投影更新之间的步数。选择合适的更新间隔需要根据具体的应用场景和性能要求进行权衡和实验验证。通过合理设置更新间隔，可以在提高计算效率的同时，保持较好的模型性能。</p>
<h4 id="GaLore-缩放系数"><a href="#GaLore-缩放系数" class="headerlink" title="GaLore 缩放系数"></a>GaLore 缩放系数</h4><p>“GaLore 缩放系数” 是指在应用梯度低秩投影时，对投影后的梯度进行缩放的系数。这个系数用于调整投影后的梯度幅度，以确保模型参数更新的稳定性和有效性。</p>
<h5 id="缩放系数的作用"><a href="#缩放系数的作用" class="headerlink" title="缩放系数的作用"></a>缩放系数的作用</h5><ol>
<li><strong>调整梯度幅度</strong>：在进行低秩投影后，梯度的幅度可能会发生变化。通过缩放系数，可以调整梯度的幅度，使其保持在一个合理的范围内。</li>
<li><strong>稳定训练过程</strong>：合适的缩放系数可以帮助稳定训练过程，避免由于梯度幅度变化过大导致的训练不稳定。</li>
<li><strong>提高模型性能</strong>：通过合理的缩放，可以确保投影后的梯度仍然有效地指导模型参数的更新，从而提高模型性能。</li>
</ol>
<h5 id="如何选择合适的缩放系数"><a href="#如何选择合适的缩放系数" class="headerlink" title="如何选择合适的缩放系数"></a>如何选择合适的缩放系数</h5><p>选择合适的缩放系数通常需要通过实验验证。以下是一些建议：</p>
<ol>
<li><strong>实验验证</strong>：通过实验验证不同缩放系数对模型性能和训练稳定性的影响。</li>
<li><strong>数据集大小和复杂性</strong>：根据数据集的大小和模型的复杂性调整缩放系数。较大的数据集和复杂的模型可能需要更精细的调整。</li>
<li><strong>学习率的配合</strong>：缩放系数的选择也需要与学习率配合使用，确保整体的梯度更新幅度合理。</li>
</ol>
<h5 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h5><p>“GaLore 缩放系数” 用于调整梯度低秩投影后的梯度幅度，以确保模型参数更新的稳定性和有效性。选择合适的缩放系数需要通过实验验证，并与学习率等其他超参数配合使用。通过合理设置缩放系数，可以在提高计算效率的同时，保持较好的模型性能和训练稳定性。</p>
<h3 id="BAdam-参数"><a href="#BAdam-参数" class="headerlink" title="BAdam 参数"></a>BAdam 参数</h3><h4 id="BAdam-优化器"><a href="#BAdam-优化器" class="headerlink" title="BAdam 优化器"></a>BAdam 优化器</h4><p>BAdam 是一种改进的优化算法，基于 Adam 优化器（Adaptive Moment Estimation）进行增强。Adam 优化器是一种广泛使用的自适应学习率优化算法，结合了动量和 RMSProp 的优点。BAdam 在此基础上进行了进一步的改进，通常包括对学习率、动量、梯度估计等方面的调整，以提高优化效率和模型性能。</p>
<h5 id="Adam-优化器回顾"><a href="#Adam-优化器回顾" class="headerlink" title="Adam 优化器回顾"></a>Adam 优化器回顾</h5><p>Adam 优化器通过计算梯度的一阶矩估计（动量）和二阶矩估计（梯度的平方和的加权平均）来调整学习率。其更新规则如下：</p>
<ol>
<li><strong>一阶矩估计（动量）</strong>：mt&#x3D;β1mt−1+(1−β1)gt<em>m**t</em>&#x3D;<em>β</em>1<em>m**t</em>−1+(1−<em>β</em>1)<em>g**t</em> 其中 mt<em>m**t</em> 是第 t 步的一阶矩估计， gt<em>g**t</em> 是梯度， β1<em>β</em>1 是动量衰减率。</li>
<li><strong>二阶矩估计</strong>：vt&#x3D;β2vt−1+(1−β2)gt2<em>v**t</em>&#x3D;<em>β</em>2<em>v**t</em>−1+(1−<em>β</em>2)<em>g**t</em>2 其中 vt<em>v**t</em> 是第 t 步的二阶矩估计， β2<em>β</em>2 是二阶矩衰减率。</li>
<li><strong>偏差修正</strong>：m^t&#x3D;mt1−β1t,v^t&#x3D;vt1−β2t<em>m</em>^<em>t</em>&#x3D;1−<em>β</em>1<em>t<strong>m</strong>t</em>,<em>v</em>^<em>t</em>&#x3D;1−<em>β</em>2<em>t<strong>v</strong>t</em></li>
<li><strong>参数更新</strong>：θt&#x3D;θt−1−αv^t+ϵm^t<em>θ**t</em>&#x3D;<em>θ**t</em>−1−<em>v</em>^<em>t</em>+<em>ϵ<strong>α</strong>m</em>^<em>t</em> 其中 α<em>α</em> 是学习率， ϵ<em>ϵ</em> 是防止除零的小常数。</li>
</ol>
<h5 id="BAdam-优化器的改进"><a href="#BAdam-优化器的改进" class="headerlink" title="BAdam 优化器的改进"></a>BAdam 优化器的改进</h5><p>BAdam 在 Adam 的基础上进行了改进，通常包括以下几个方面：</p>
<ol>
<li><strong>学习率调整</strong>：更灵活或自适应的学习率调整机制，以应对不同训练阶段的需求。</li>
<li><strong>动量调整</strong>：对动量的计算进行优化，使其更适合特定的训练任务。</li>
<li><strong>梯度估计改进</strong>：对梯度的一阶和二阶矩估计进行改进，以提高优化效率和稳定性。</li>
<li><strong>正则化</strong>：引入额外的正则化项，以防止过拟合和提高泛化能力。</li>
</ol>
<h5 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a>总结</h5><p>BAdam 是对 Adam 优化器的改进版本，旨在通过更灵活和自适应的机制提高优化效率和模型性能。它在学习率、动量、梯度估计等方面进行了增强，使其更适合复杂的训练任务和大规模数据集。通过合理设置 BAdam 的超参数，可以在实际应用中获得更好的优化效果。</p>
<h4 id="BAdam-模式"><a href="#BAdam-模式" class="headerlink" title="BAdam 模式"></a>BAdam 模式</h4><p>BAdam 模式可以分为两种主要方式：layer-wise 和 ratio-wise。这两种模式在优化过程中有不同的侧重点和应用场景。</p>
<h5 id="Layer-wise-BAdam"><a href="#Layer-wise-BAdam" class="headerlink" title="Layer-wise BAdam"></a>Layer-wise BAdam</h5><p>Layer-wise BAdam 是一种针对神经网络中不同层的优化方法。每一层都有独立的优化器参数（如学习率、动量等），这使得可以对不同层进行更细粒度的控制。通常情况下，神经网络的不同层对学习率和动量的需求是不同的，因此这种方法可以提高训练效率和模型性能。</p>
<h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ol>
<li><strong>细粒度控制</strong>：可以对每一层进行独立的参数调整。</li>
<li><strong>适应性强</strong>：不同层可以有不同的学习率和动量，适应不同的训练需求。</li>
<li><strong>提高性能</strong>：通过针对性优化，提高模型的整体性能。</li>
</ol>
<h5 id="Ratio-wise-BAdam"><a href="#Ratio-wise-BAdam" class="headerlink" title="Ratio-wise BAdam"></a>Ratio-wise BAdam</h5><p>Ratio-wise BAdam 是一种根据梯度的比例进行优化的方法。它通过对梯度的大小进行归一化处理，使得不同参数的更新幅度保持在一个合理的范围内。这种方法特别适用于梯度幅度差异较大的情况，通过归一化处理，可以防止梯度爆炸或消失的问题。</p>
<h6 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h6><ol>
<li><strong>防止梯度爆炸和消失</strong>：通过归一化处理，保持梯度更新幅度的稳定。</li>
<li><strong>提高稳定性</strong>：使得优化过程更加稳定，特别是在梯度差异较大的情况下。</li>
<li><strong>适用广泛</strong>：适用于各种不同类型的神经网络和训练任务。</li>
</ol>
<h5 id="总结-22"><a href="#总结-22" class="headerlink" title="总结"></a>总结</h5><ul>
<li><strong>Layer-wise BAdam</strong>：针对神经网络的每一层进行独立优化，适用于需要细粒度控制的场景。</li>
<li><strong>Ratio-wise BAdam</strong>：根据梯度的比例进行优化，适用于梯度幅度差异较大的情况。</li>
</ul>
<h4 id="切换策略"><a href="#切换策略" class="headerlink" title="切换策略"></a>切换策略</h4><p>在 Layer-wise BAdam 优化器中，块切换策略是指在优化过程中，如何选择不同的层或块进行更新。常见的块切换策略包括：ascending（升序）、descending（降序）、random（随机）和 fixed（固定）。每种策略有其独特的特点和适用场景。</p>
<h5 id="1-Ascending（升序）"><a href="#1-Ascending（升序）" class="headerlink" title="1. Ascending（升序）"></a>1. Ascending（升序）</h5><p><strong>升序策略</strong> 是按照层或块在模型中的顺序，从前到后依次进行更新。这种策略通常适用于层次结构明显的模型，如卷积神经网络（CNN），从低层特征到高层特征逐步优化。</p>
<h6 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h6><ul>
<li><strong>逐层优化</strong>：有助于从低层特征到高层特征的逐步优化。</li>
<li><strong>简单易实现</strong>：实现起来相对简单。</li>
</ul>
<h5 id="2-Descending（降序）"><a href="#2-Descending（降序）" class="headerlink" title="2. Descending（降序）"></a>2. Descending（降序）</h5><p><strong>降序策略</strong> 是按照层或块在模型中的顺序，从后到前依次进行更新。这种策略适用于需要优先优化高层特征的模型，通常在某些特定任务中可能会有更好的效果。</p>
<h6 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h6><ul>
<li><strong>优先优化高层特征</strong>：有助于优先优化高层特征，适用于特定任务。</li>
<li><strong>适应性强</strong>：在某些任务中可能会表现更好。</li>
</ul>
<h5 id="3-Random（随机）"><a href="#3-Random（随机）" class="headerlink" title="3. Random（随机）"></a>3. Random（随机）</h5><p><strong>随机策略</strong> 是在每次更新时，随机选择一个层或块进行优化。这种策略可以防止模型陷入局部最优解，具有较好的探索性。</p>
<h6 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h6><ul>
<li><strong>防止局部最优</strong>：通过随机选择层进行优化，防止模型陷入局部最优。</li>
<li><strong>探索性强</strong>：具有较好的探索性，适用于复杂任务。</li>
</ul>
<h5 id="4-Fixed（固定）"><a href="#4-Fixed（固定）" class="headerlink" title="4. Fixed（固定）"></a>4. Fixed（固定）</h5><p><strong>固定策略</strong> 是按照预先设定的顺序或特定层进行更新。这种策略适用于对特定层有特殊需求的模型，或者在某些特定任务中需要固定更新顺序。</p>
<h6 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h6><ul>
<li><strong>特定需求</strong>：适用于对特定层有特殊需求的模型。</li>
<li><strong>可控性强</strong>：更新顺序固定，可控性强。</li>
</ul>
<h5 id="总结-23"><a href="#总结-23" class="headerlink" title="总结"></a>总结</h5><ul>
<li><strong>Ascending（升序）</strong>：逐层从前到后进行更新，适用于层次结构明显的模型。</li>
<li><strong>Descending（降序）</strong>：逐层从后到前进行更新，适用于需要优先优化高层特征的模型。</li>
<li><strong>Random（随机）</strong>：随机选择层进行更新，防止模型陷入局部最优，具有较好的探索性。</li>
<li><strong>Fixed（固定）</strong>：按照预先设定的顺序或特定层进行更新，适用于对特定层有特殊需求的模型。</li>
</ul>
<h4 id="切换频率"><a href="#切换频率" class="headerlink" title="切换频率"></a>切换频率</h4><p>在 Layer-wise BAdam 优化器中，块切换频率指的是在训练过程中，切换不同层或块进行优化的频率。根据具体的任务和模型需求，块切换频率可以是高频切换或低频切换。以下是几种常见的块切换频率策略：</p>
<h5 id="1-每次迭代切换（Per-Iteration-Switching）"><a href="#1-每次迭代切换（Per-Iteration-Switching）" class="headerlink" title="1. 每次迭代切换（Per-Iteration Switching）"></a>1. 每次迭代切换（Per-Iteration Switching）</h5><p>在每次迭代中切换不同的层或块进行优化。这种高频切换策略可以确保所有层都得到均匀的优化机会。</p>
<h6 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h6><ul>
<li><strong>均匀优化</strong>：每次迭代都切换层，确保所有层都得到均匀的优化。</li>
<li><strong>快速响应</strong>：可以快速响应模型的变化，适用于动态变化较大的任务。</li>
</ul>
<h5 id="2-每个-Epoch-切换（Per-Epoch-Switching）"><a href="#2-每个-Epoch-切换（Per-Epoch-Switching）" class="headerlink" title="2. 每个 Epoch 切换（Per-Epoch Switching）"></a>2. 每个 Epoch 切换（Per-Epoch Switching）</h5><p>在每个 epoch 结束后切换不同的层或块进行优化。这种中频切换策略适用于需要在整个数据集上进行完整训练后再切换层的情况。</p>
<h6 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h6><ul>
<li><strong>稳定训练</strong>：每个 epoch 结束后切换，确保在整个数据集上进行完整训练后再切换层。</li>
<li><strong>适应性强</strong>：适用于需要较长时间稳定训练的任务。</li>
</ul>
<h5 id="3-每-N-次迭代切换（Per-N-Iterations-Switching）"><a href="#3-每-N-次迭代切换（Per-N-Iterations-Switching）" class="headerlink" title="3. 每 N 次迭代切换（Per-N-Iterations Switching）"></a>3. 每 N 次迭代切换（Per-N-Iterations Switching）</h5><p>在每 N 次迭代后切换不同的层或块进行优化。这种低频切换策略适用于需要在一个较长的时间段内稳定优化特定层的情况。</p>
<h6 id="优点-8"><a href="#优点-8" class="headerlink" title="优点"></a>优点</h6><ul>
<li><strong>稳定优化</strong>：每 N 次迭代后切换，确保在一个较长的时间段内稳定优化特定层。</li>
<li><strong>灵活性高</strong>：可以根据任务需求调整 N 的大小，灵活性高。</li>
</ul>
<h5 id="4-动态切换（Dynamic-Switching）"><a href="#4-动态切换（Dynamic-Switching）" class="headerlink" title="4. 动态切换（Dynamic Switching）"></a>4. 动态切换（Dynamic Switching）</h5><p>根据训练过程中的某些指标（如损失函数的变化、梯度的大小等）动态调整切换频率。这种策略适用于需要根据训练过程中的反馈进行实时调整的情况。</p>
<h6 id="优点-9"><a href="#优点-9" class="headerlink" title="优点"></a>优点</h6><ul>
<li><strong>自适应性强</strong>：根据训练过程中的反馈进行实时调整，适应性强。</li>
<li><strong>优化效果好</strong>：可以根据实际情况动态调整，优化效果更好。</li>
</ul>
<h5 id="总结-24"><a href="#总结-24" class="headerlink" title="总结"></a>总结</h5><ul>
<li><strong>每次迭代切换（Per-Iteration Switching）</strong>：高频切换，适用于需要快速响应模型变化的任务。</li>
<li><strong>每个 Epoch 切换（Per-Epoch Switching）</strong>：中频切换，适用于需要在整个数据集上进行完整训练后再切换层的情况。</li>
<li><strong>每 N 次迭代切换（Per-N-Iterations Switching）</strong>：低频切换，适用于需要在一个较长的时间段内稳定优化特定层的情况。</li>
<li><strong>动态切换（Dynamic Switching）</strong>：根据训练过程中的反馈动态调整，适用于需要根据实际情况进行实时调整的任务。</li>
</ul>
<h4 id="更新比例"><a href="#更新比例" class="headerlink" title="更新比例"></a>更新比例</h4><p>在 Ratio-wise BAdam 优化器中，更新比例（Update Ratio）是指在优化过程中，不同层或块的更新频率和幅度的比例。通过调整更新比例，可以更好地平衡各层或块的优化进程，从而提高模型的整体性能和训练效率。以下是几种常见的更新比例策略：</p>
<h5 id="1-均匀更新比例（Uniform-Update-Ratio）"><a href="#1-均匀更新比例（Uniform-Update-Ratio）" class="headerlink" title="1. 均匀更新比例（Uniform Update Ratio）"></a>1. 均匀更新比例（Uniform Update Ratio）</h5><p><strong>均匀更新比例</strong> 是指所有层或块的更新频率和幅度相同。这种策略适用于层次结构相对均匀的模型，不需要对某些特定层进行特殊优化。</p>
<h6 id="优点-10"><a href="#优点-10" class="headerlink" title="优点"></a>优点</h6><ul>
<li><strong>简单易实现</strong>：实现起来相对简单。</li>
<li><strong>均匀优化</strong>：所有层或块的更新频率和幅度相同，适用于层次结构均匀的模型。</li>
</ul>
<h5 id="2-加权更新比例（Weighted-Update-Ratio）"><a href="#2-加权更新比例（Weighted-Update-Ratio）" class="headerlink" title="2. 加权更新比例（Weighted Update Ratio）"></a>2. 加权更新比例（Weighted Update Ratio）</h5><p><strong>加权更新比例</strong> 是指不同层或块根据其重要性或需求，分配不同的更新频率和幅度。这种策略适用于需要对某些特定层进行特殊优化的情况。</p>
<h6 id="优点-11"><a href="#优点-11" class="headerlink" title="优点"></a>优点</h6><ul>
<li><strong>灵活性高</strong>：可以根据层或块的重要性或需求，分配不同的更新频率和幅度。</li>
<li><strong>优化效果好</strong>：对重要层或块进行特殊优化，提高整体性能。</li>
</ul>
<h5 id="3-动态更新比例（Dynamic-Update-Ratio）"><a href="#3-动态更新比例（Dynamic-Update-Ratio）" class="headerlink" title="3. 动态更新比例（Dynamic Update Ratio）"></a>3. 动态更新比例（Dynamic Update Ratio）</h5><p><strong>动态更新比例</strong> 是指根据训练过程中的某些指标（如损失函数的变化、梯度的大小等）动态调整不同层或块的更新频率和幅度。这种策略适用于需要根据训练过程中的反馈进行实时调整的情况。</p>
<h6 id="优点-12"><a href="#优点-12" class="headerlink" title="优点"></a>优点</h6><ul>
<li><strong>自适应性强</strong>：根据训练过程中的反馈进行实时调整，适应性强。</li>
<li><strong>优化效果好</strong>：可以根据实际情况动态调整，优化效果更好。</li>
</ul>
<h5 id="4-固定更新比例（Fixed-Update-Ratio）"><a href="#4-固定更新比例（Fixed-Update-Ratio）" class="headerlink" title="4. 固定更新比例（Fixed Update Ratio）"></a>4. 固定更新比例（Fixed Update Ratio）</h5><p><strong>固定更新比例</strong> 是指提前设定好不同层或块的更新频率和幅度，并在整个训练过程中保持不变。这种策略适用于对某些特定层有特殊需求的模型，或者在某些特定任务中需要固定更新比例。</p>
<h6 id="优点-13"><a href="#优点-13" class="headerlink" title="优点"></a>优点</h6><ul>
<li><strong>可控性强</strong>：更新比例固定，可控性强。</li>
<li><strong>适用于特定需求</strong>：适用于对某些特定层有特殊需求的模型。</li>
</ul>
<h5 id="总结-25"><a href="#总结-25" class="headerlink" title="总结"></a>总结</h5><ul>
<li><strong>均匀更新比例（Uniform Update Ratio）</strong>：所有层或块的更新频率和幅度相同，适用于层次结构均匀的模型。</li>
<li><strong>加权更新比例（Weighted Update Ratio）</strong>：根据层或块的重要性或需求，分配不同的更新频率和幅度，灵活性高。</li>
<li><strong>动态更新比例（Dynamic Update Ratio）</strong>：根据训练过程中的反馈动态调整，适用于需要实时调整的任务。</li>
<li><strong>固定更新比例（Fixed Update Ratio）</strong>：提前设定好更新比例，并在整个训练过程中保持不变，适用于对某些特定层有特殊需求的模型。</li>
</ul>
<h3 id="DeepSpeed-stage"><a href="#DeepSpeed-stage" class="headerlink" title="DeepSpeed stage"></a>DeepSpeed stage</h3><p>在多卡训练中，DeepSpeed 是一个非常强大的深度学习优化库，能够显著提高模型训练的效率和性能。DeepSpeed 提供了不同的优化级别（stages），每个级别都有其独特的特性和适用场景。主要有以下几个可选值：None、Stage 2 和 Stage 3。</p>
<h4 id="1-None"><a href="#1-None" class="headerlink" title="1. None"></a>1. None</h4><p><strong>None</strong> 表示不使用 DeepSpeed 的任何优化特性，直接进行多卡训练。这种方式适用于不需要特殊优化的简单任务。</p>
<h5 id="优点-14"><a href="#优点-14" class="headerlink" title="优点"></a>优点</h5><ul>
<li><strong>简单直接</strong>：不需要额外的配置和优化，适用于简单任务。</li>
<li><strong>兼容性好</strong>：与现有的训练代码兼容性好。</li>
</ul>
<h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul>
<li>小规模模型和数据集。</li>
<li>不需要特殊优化的任务。</li>
</ul>
<h4 id="2-Stage-2"><a href="#2-Stage-2" class="headerlink" title="2. Stage 2"></a>2. Stage 2</h4><p><strong>Stage 2</strong> 提供了优化的梯度累加和混合精度训练，能够显著减少显存占用，提高训练效率。</p>
<h5 id="优点-15"><a href="#优点-15" class="headerlink" title="优点"></a>优点</h5><ul>
<li><strong>显存优化</strong>：通过梯度累加和混合精度训练，显著减少显存占用。</li>
<li><strong>提高效率</strong>：能够加速训练过程，适用于中等规模的模型和数据集。</li>
</ul>
<h5 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h5><ul>
<li>中等规模的模型和数据集。</li>
<li>需要优化显存占用和训练效率的任务。</li>
</ul>
<h4 id="3-Stage-3"><a href="#3-Stage-3" class="headerlink" title="3. Stage 3"></a>3. Stage 3</h4><p><strong>Stage 3</strong> 是 DeepSpeed 提供的最高级别优化，包含了零冗余优化（ZeRO），能够极大地减少显存占用，适用于超大规模模型的训练。</p>
<h5 id="优点-16"><a href="#优点-16" class="headerlink" title="优点"></a>优点</h5><ul>
<li><strong>极限显存优化</strong>：通过零冗余优化，最大限度地减少显存占用，适用于超大规模模型。</li>
<li><strong>支持超大模型</strong>：能够支持超大规模模型的训练，适用于需要训练大模型的任务。</li>
</ul>
<h5 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h5><ul>
<li>超大规模模型和数据集。</li>
<li>需要极限显存优化和高效训练的任务。</li>
</ul>
<h4 id="总结-26"><a href="#总结-26" class="headerlink" title="总结"></a>总结</h4><ul>
<li><strong>None</strong>：不使用 DeepSpeed 优化，适用于简单任务和小规模模型。</li>
<li><strong>Stage 2</strong>：提供梯度累加和混合精度训练，适用于中等规模模型和需要优化显存占用的任务。</li>
<li><strong>Stage 3</strong>：包含零冗余优化，适用于超大规模模型和需要极限显存优化的任务。</li>
</ul>
<p>选择合适的 DeepSpeed stage 取决于具体的模型规模、数据集大小和任务需求。通过合理的选择和配置，可以显著提高模型的训练效率和性能。</p>
<h3 id="DeepSpeed-offload"><a href="#DeepSpeed-offload" class="headerlink" title="DeepSpeed offload"></a>DeepSpeed offload</h3><p>DeepSpeed 的 offload 功能是一种优化策略，它允许将部分计算任务（如优化器状态和模型参数）从 GPU 显存转移到 CPU 内存或 NVMe 存储，从而显著减少 GPU 显存的占用。这对于训练超大规模模型尤其有用，因为它可以扩展模型训练的规模和效率。</p>
<h4 id="DeepSpeed-Offload-主要特性"><a href="#DeepSpeed-Offload-主要特性" class="headerlink" title="DeepSpeed Offload 主要特性"></a>DeepSpeed Offload 主要特性</h4><ol>
<li><strong>Optimizer State Offload</strong>：将优化器状态（如梯度、动量等）从 GPU 显存转移到 CPU 内存或 NVMe 存储。</li>
<li><strong>Parameter Offload</strong>：将模型参数从 GPU 显存转移到 CPU 内存或 NVMe 存储。</li>
<li><strong>Mixed Precision Training</strong>：支持混合精度训练，进一步减少显存占用。</li>
</ol>
<h4 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h4><ul>
<li><strong>train_batch_size</strong>：训练批次大小。</li>
<li><strong>gradient_accumulation_steps</strong>：梯度累加步数，用于在显存受限的情况下增大有效批次大小。</li>
<li><strong>zero_optimization</strong>：ZeRO 优化配置。<ul>
<li><strong>stage</strong>：ZeRO 优化的阶段，这里使用 Stage 3，包含最全面的优化。</li>
<li><strong>offload_optimizer</strong>：优化器状态的 offload 配置。<ul>
<li><strong>device</strong>：目标设备，可以是 “cpu” 或 “nvme”。</li>
<li><strong>pin_memory</strong>：是否使用固定内存，以提高数据传输效率。</li>
</ul>
</li>
<li><strong>offload_param</strong>：模型参数的 offload 配置。<ul>
<li><strong>device</strong>：目标设备，可以是 “cpu” 或 “nvme”。</li>
<li><strong>pin_memory</strong>：是否使用固定内存，以提高数据传输效率。</li>
</ul>
</li>
</ul>
</li>
<li><strong>fp16</strong>：混合精度训练配置。<ul>
<li><strong>enabled</strong>：是否启用混合精度训练。</li>
</ul>
</li>
</ul>
<h4 id="Offload-的优势"><a href="#Offload-的优势" class="headerlink" title="Offload 的优势"></a>Offload 的优势</h4><ol>
<li><strong>显著减少显存占用</strong>：通过将优化器状态和模型参数转移到 CPU 或 NVMe，可以显著减少 GPU 显存的占用。</li>
<li><strong>支持更大规模的模型训练</strong>：由于显存占用减少，可以在同样的硬件条件下训练更大规模的模型。</li>
<li><strong>提高训练效率</strong>：通过混合精度训练和固定内存，可以提高数据传输效率和整体训练速度。</li>
</ol>
<h4 id="总结-27"><a href="#总结-27" class="headerlink" title="总结"></a>总结</h4><p>DeepSpeed 的 offload 功能通过将优化器状态和模型参数转移到 CPU 或 NVMe，显著减少了 GPU 显存的占用，支持更大规模的模型训练，并提高了训练效率。合理配置和使用 offload 功能，可以极大地提升模型训练的性能和效果。</p>
<h3 id="Top-p-采样值"><a href="#Top-p-采样值" class="headerlink" title="Top-p 采样值"></a>Top-p 采样值</h3><p>Top-p 采样（也称为核采样，Nucleus Sampling）是一种生成文本时的采样策略，用于从语言模型的概率分布中选择下一个词。与 Top-k 采样不同，Top-p 采样根据累积概率来选择候选词，从而在生成过程中引入更多的多样性和灵活性。</p>
<h4 id="Top-p-采样的工作原理"><a href="#Top-p-采样的工作原理" class="headerlink" title="Top-p 采样的工作原理"></a>Top-p 采样的工作原理</h4><ol>
<li><strong>概率排序</strong>：首先，将所有可能的候选词按照其概率从高到低排序。</li>
<li><strong>累积概率</strong>：从排序后的候选词中，逐个累加其概率，直到累积概率达到或超过一个预设的阈值 ( p )。</li>
<li><strong>候选词选择</strong>：只从这些累积概率达到阈值的候选词中进行采样。</li>
</ol>
<h4 id="参数解释-1"><a href="#参数解释-1" class="headerlink" title="参数解释"></a>参数解释</h4><ul>
<li><strong>p（累积概率阈值）</strong>：这是一个介于 0 和 1 之间的值，表示累积概率的阈值。例如，p &#x3D; 0.9 表示只考虑累积概率达到 90% 的候选词。</li>
</ul>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>假设我们有以下候选词及其概率：</p>
<table>
<thead>
<tr>
<th>候选词</th>
<th>概率</th>
</tr>
</thead>
<tbody><tr>
<td>词A</td>
<td>0.4</td>
</tr>
<tr>
<td>词B</td>
<td>0.3</td>
</tr>
<tr>
<td>词C</td>
<td>0.2</td>
</tr>
<tr>
<td>词D</td>
<td>0.05</td>
</tr>
<tr>
<td>词E</td>
<td>0.05</td>
</tr>
</tbody></table>
<p>如果我们设置 ( p &#x3D; 0.8 )：</p>
<ol>
<li><strong>概率排序</strong>：候选词已经按概率从高到低排序。</li>
<li><strong>累积概率</strong>：<ul>
<li>词A：0.4</li>
<li>词A + 词B：0.4 + 0.3 &#x3D; 0.7</li>
<li>词A + 词B + 词C：0.4 + 0.3 + 0.2 &#x3D; 0.9</li>
</ul>
</li>
<li><strong>候选词选择</strong>：累积概率达到 0.8 时，候选词为 [词A, 词B, 词C]。因此，我们只从这些词中进行采样。</li>
</ol>
<h4 id="Top-p-采样的优点"><a href="#Top-p-采样的优点" class="headerlink" title="Top-p 采样的优点"></a>Top-p 采样的优点</h4><ol>
<li><strong>更高的多样性</strong>：相比于 Top-k 采样，Top-p 采样能够引入更多的多样性，因为它考虑了更多的候选词。</li>
<li><strong>动态调整</strong>：Top-p 采样根据累积概率动态调整候选词的数量，而不是固定数量，这使得它在不同的上下文中更加灵活。</li>
</ol>
<h4 id="Top-p-采样的缺点"><a href="#Top-p-采样的缺点" class="headerlink" title="Top-p 采样的缺点"></a>Top-p 采样的缺点</h4><ol>
<li><strong>计算复杂度</strong>：由于需要对所有候选词进行排序和累积概率计算，Top-p 采样的计算复杂度较高。</li>
<li><strong>参数调优</strong>：需要选择合适的 p 值，不同的任务和数据集可能需要不同的 p 值。</li>
</ol>
<h4 id="Top-p-采样与-Top-k-采样的比较"><a href="#Top-p-采样与-Top-k-采样的比较" class="headerlink" title="Top-p 采样与 Top-k 采样的比较"></a>Top-p 采样与 Top-k 采样的比较</h4><ul>
<li><strong>Top-k 采样</strong>：从概率最高的 k 个候选词中进行采样。适用于需要控制候选词数量的场景。</li>
<li><strong>Top-p 采样</strong>：从累积概率达到阈值 p 的候选词中进行采样。适用于需要更高多样性和灵活性的场景。</li>
</ul>
<h4 id="总结-28"><a href="#总结-28" class="headerlink" title="总结"></a>总结</h4><p>Top-p 采样是一种基于累积概率的采样策略，通过动态调整候选词的数量，引入更多的多样性和灵活性。合理设置 p 值，可以在生成文本时取得平衡，提高生成质量。</p>
<h3 id="温度系数"><a href="#温度系数" class="headerlink" title="温度系数"></a>温度系数</h3><p>温度系数（Temperature Coefficient）在深度学习中的采样策略中是一个重要的参数，用于控制生成文本时的随机性和多样性。温度系数通常用符号 T<em>T</em> 表示，通过调整模型输出的概率分布来影响生成结果。</p>
<h4 id="温度系数的工作原理"><a href="#温度系数的工作原理" class="headerlink" title="温度系数的工作原理"></a>温度系数的工作原理</h4><p>温度系数 T<em>T</em> 影响模型输出的概率分布 P<em>P</em> 的方式如下：Pi&#x3D;exp⁡(log⁡PiT)∑jexp⁡(log⁡PjT)<em>P**i</em>&#x3D;∑<em>j</em>exp(<em>T</em>log<em>P**j</em>)exp(<em>T</em>log<em>P**i</em>)</p>
<p>其中，Pi<em>P**i</em> 是第 i<em>i</em> 个词的原始概率，调整后的概率分布根据温度系数 T<em>T</em> 进行缩放。</p>
<h4 id="温度系数的影响"><a href="#温度系数的影响" class="headerlink" title="温度系数的影响"></a>温度系数的影响</h4><ul>
<li><strong>低温度（T &lt; 1）</strong>：低温度会使概率分布变得更加陡峭，模型更倾向于选择概率最高的词，生成的文本更加确定性，随机性较低。</li>
<li><strong>高温度（T &gt; 1）</strong>：高温度会使概率分布变得更加平缓，模型更倾向于选择不同的词，生成的文本更加多样化，但也可能变得不太连贯。</li>
<li><strong>温度为 1（T &#x3D; 1）</strong>：温度为 1 时，概率分布不变，生成的文本基于模型的原始概率分布。</li>
</ul>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><p>假设我们有以下候选词及其概率：</p>
<table>
<thead>
<tr>
<th>候选词</th>
<th>原始概率</th>
</tr>
</thead>
<tbody><tr>
<td>词A</td>
<td>0.4</td>
</tr>
<tr>
<td>词B</td>
<td>0.3</td>
</tr>
<tr>
<td>词C</td>
<td>0.2</td>
</tr>
<tr>
<td>词D</td>
<td>0.05</td>
</tr>
<tr>
<td>词E</td>
<td>0.05</td>
</tr>
</tbody></table>
<h5 id="低温度（T-0-5）"><a href="#低温度（T-0-5）" class="headerlink" title="低温度（T &#x3D; 0.5）"></a>低温度（T &#x3D; 0.5）</h5><p>低温度会使概率分布更加陡峭：Pi′&#x3D;exp⁡(log⁡Pi0.5)∑jexp⁡(log⁡Pj0.5)<em>P**i</em>′&#x3D;∑<em>j</em>exp(0.5log<em>P**j</em>)exp(0.5log<em>P**i</em>)</p>
<p>调整后的概率分布可能会变成：</p>
<table>
<thead>
<tr>
<th>候选词</th>
<th>调整后概率</th>
</tr>
</thead>
<tbody><tr>
<td>词A</td>
<td>0.55</td>
</tr>
<tr>
<td>词B</td>
<td>0.25</td>
</tr>
<tr>
<td>词C</td>
<td>0.15</td>
</tr>
<tr>
<td>词D</td>
<td>0.025</td>
</tr>
<tr>
<td>词E</td>
<td>0.025</td>
</tr>
</tbody></table>
<h5 id="高温度（T-1-5）"><a href="#高温度（T-1-5）" class="headerlink" title="高温度（T &#x3D; 1.5）"></a>高温度（T &#x3D; 1.5）</h5><p>高温度会使概率分布更加平缓：Pi′&#x3D;exp⁡(log⁡Pi1.5)∑jexp⁡(log⁡Pj1.5)<em>P**i</em>′&#x3D;∑<em>j</em>exp(1.5log<em>P**j</em>)exp(1.5log<em>P**i</em>)</p>
<p>调整后的概率分布可能会变成：</p>
<table>
<thead>
<tr>
<th>候选词</th>
<th>调整后概率</th>
</tr>
</thead>
<tbody><tr>
<td>词A</td>
<td>0.35</td>
</tr>
<tr>
<td>词B</td>
<td>0.3</td>
</tr>
<tr>
<td>词C</td>
<td>0.2</td>
</tr>
<tr>
<td>词D</td>
<td>0.075</td>
</tr>
<tr>
<td>词E</td>
<td>0.075</td>
</tr>
</tbody></table>
<h4 id="总结-29"><a href="#总结-29" class="headerlink" title="总结"></a>总结</h4><p>温度系数是控制生成文本随机性和多样性的一个重要参数。通过调整温度系数，可以在生成的确定性和多样性之间取得平衡。低温度会使生成结果更加确定性，而高温度会引入更多的随机性和多样性。合理设置温度系数，可以提高生成文本的质量和适用性。</p>
<h3 id="safetensors-格式"><a href="#safetensors-格式" class="headerlink" title="safetensors 格式"></a>safetensors 格式</h3><p>safetensors 是一种用于保存和加载深度学习模型权重的文件格式，旨在提高文件的安全性和加载速度。与传统的 PyTorch 和 TensorFlow 权重保存格式相比，safetensors 格式具有以下几个显著的优势：</p>
<h4 id="safetensors-格式的特点"><a href="#safetensors-格式的特点" class="headerlink" title="safetensors 格式的特点"></a>safetensors 格式的特点</h4><ol>
<li><strong>安全性</strong>：safetensors 格式通过避免使用可执行代码来加载权重文件，从而减少了潜在的安全漏洞。这意味着即使文件被恶意篡改，也不会执行任意代码。</li>
<li><strong>加载速度</strong>：safetensors 格式使用二进制格式存储数据，加载速度更快，特别是在处理大规模模型时效果显著。</li>
<li><strong>跨平台兼容性</strong>：safetensors 格式是独立于框架的，可以在不同的深度学习框架之间互操作。</li>
</ol>
<h4 id="safetensors-的使用"><a href="#safetensors-的使用" class="headerlink" title="safetensors 的使用"></a>safetensors 的使用</h4><p>safetensors 格式通常与 Hugging Face 的库一起使用，如 Transformers 和 Diffusers。以下是一个简单的示例，展示了如何使用 safetensors 格式保存和加载模型权重。</p>
<h5 id="安装-safetensors-库"><a href="#安装-safetensors-库" class="headerlink" title="安装 safetensors 库"></a>安装 safetensors 库</h5><p>首先，确保你已经安装了 safetensors 库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install safetensors</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h5 id="保存模型权重为-safetensors-格式"><a href="#保存模型权重为-safetensors-格式" class="headerlink" title="保存模型权重为 safetensors 格式"></a>保存模型权重为 safetensors 格式</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> safetensors.torch <span class="keyword">import</span> save_file</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设我们有一个 PyTorch 模型</span></span><br><span class="line">model = torch.nn.Linear(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取模型的状态字典</span></span><br><span class="line">state_dict = model.state_dict()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 safetensors 保存模型权重</span></span><br><span class="line">save_file(state_dict, <span class="string">&#x27;model.safetensors&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h5 id="加载-safetensors-格式的模型权重"><a href="#加载-safetensors-格式的模型权重" class="headerlink" title="加载 safetensors 格式的模型权重"></a>加载 safetensors 格式的模型权重</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> safetensors.torch <span class="keyword">import</span> load_file</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个新的模型实例</span></span><br><span class="line">model = torch.nn.Linear(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 safetensors 文件中加载权重</span></span><br><span class="line">state_dict = load_file(<span class="string">&#x27;model.safetensors&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将权重加载到模型中</span></span><br><span class="line">model.load_state_dict(state_dict)</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h4 id="safetensors-格式的优点"><a href="#safetensors-格式的优点" class="headerlink" title="safetensors 格式的优点"></a>safetensors 格式的优点</h4><ol>
<li><strong>安全性</strong>：避免了潜在的代码执行风险，非常适合在生产环境中使用。</li>
<li><strong>性能</strong>：加载速度更快，特别是对于大规模模型。</li>
<li><strong>易用性</strong>：与现有的深度学习框架兼容，易于集成到现有工作流中。</li>
</ol>
<h4 id="safetensors-格式的缺点"><a href="#safetensors-格式的缺点" class="headerlink" title="safetensors 格式的缺点"></a>safetensors 格式的缺点</h4><ol>
<li><strong>社区支持</strong>：虽然 safetensors 格式正在快速发展，但其社区支持和生态系统可能不如传统格式广泛。</li>
<li><strong>功能限制</strong>：safetensors 格式主要关注权重的安全和高效存储，可能不支持一些高级功能，如自定义对象的序列化。</li>
</ol>
<h4 id="总结-30"><a href="#总结-30" class="headerlink" title="总结"></a>总结</h4><p>safetensors 格式是一种专注于安全性和性能的模型权重存储格式。它通过避免代码执行风险和提高加载速度，提供了一个安全高效的解决方案，特别适合在生产环境中使用。尽管 safetensors 格式在社区支持和功能方面可能存在一些限制，但它的优势使其成为保存和加载深度学习模型权重的一个有吸引力的选择。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://dummyv07.github.io">Dummy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://dummyv07.github.io/2024/12/10/LlamaFactory%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/">https://dummyv07.github.io/2024/12/10/LlamaFactory%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://dummyv07.github.io" target="_blank">廾匸</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LLM/">LLM</a></div><div class="post-share"><div class="social-share" data-image="/img/eyes.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/12/05/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" title="大模型学习之大模型文件结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">大模型学习之大模型文件结构</div></div><div class="info-2"><div class="info-item-1">下载途径不一样是否文件构成也不一样？ 以下内容以Xinference加载的Qwen2_5-InstructionAWQ-14B模型为例。  config.json configuration.json generation_config.json LIENSE merges.txt model.safetensors.index.json .safeatensors README.md tokenizer.json tokenizer_config.json vocab.json  1. config.json 配置文件 描述模型的架构、超参数和训练时的设置。包括模型的层数、隐藏单元数、激活函数等信息。 {“architectures”: [  “Qwen2ForCausalLM”],“attention_dropout”: 0.0,“bos_token_id”: 151643,“eos_token_id”: 151645,“hidden_act”: “silu”,“hidden_size”: 5120,“initializer_range”:...</div></div></div></a><a class="pagination-related" href="/2024/12/12/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B5%84%E6%BA%90%E5%8D%A0%E7%94%A8/" title="大模型学习之资源占用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">大模型学习之资源占用</div></div><div class="info-2"><div class="info-item-1">待测试更新 大模型学习之资源占用资源：在本文中主要指的是cpu内存和gpu显存。 首先要分两种场景模型推理和模型训练进行讨论，针对不同的场景显存所需要加载的内容也不一样 0.预备知识模型参数1B 代表10亿个参数；1byte(字节)&#x3D;8bit(位)    参数精度 fp32 fp16&#x2F;bp16 int8&#x2F;fp8 Int4    所占内存 4byte 2byte 1byte 0.5byte   eg：fp32 1B：4byte * 10亿 &#x2F; 1024^3(kb mb gb) 约等于 3.725GB 量化量化一般指的降低参数所占的内存空间，比如一个参数本来占4字节32位，现在为了节省空间，需要将其量化到int8也就是只允许参数占8位，量化的过程并不是简单的抹除小数位！ 在神经网络模型导出的时候我们才会去做量化，以提高模型的推理速度以及模型所占显存大小，但量化同时会导致模型精度的下降。 量化方法的分类： QAT(Quant-Aware Training)也可以称为在线量化(On...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/11/24/OpenAI/" title="OpenAI"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-24</div><div class="info-item-2">OpenAI</div></div><div class="info-2"><div class="info-item-1">OpenAILink OpenAI最核心的功能，就是它所提供的文本生成模型。模型经过训练可以理解自然语言、代码和图像。模型可以接受任意类型的输入，最终输出文本。 使用模型，你可以构建任意你所需要的AI应用程序，比如： 1.编写文案 2.编写编程代码 3.回答知识库问题 4.分析文本 5.日常助手 6.语言翻译 01第一个聊天程序ChatCompletion的输入是一个message list，返回是一个chatCompletion对象，示例代码如下： 123456789101112131415161718192021222324#openai默认的声明方式，注册openai后在对应的控制台获取api_keyfrom openai import OpenAIclient = OpenAI(api_key=&quot;sk-&quot;)# 通常我会把自己的API-KEY放在.env文件里，然后gitignore掉。# .env文件可以通过 dotenv库来读取，然后放进系统变量里，这样OpenAI就可以直接识别from dotenv import load_dotenv,...</div></div></div></a><a class="pagination-related" href="/2024/09/22/Tokenizer/" title="Tokenizer"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-22</div><div class="info-item-2">Tokenizer</div></div><div class="info-2"><div class="info-item-1">Tokenizer 作用：将文本序列转化为数字(token)序列，作为transformer的输入 分词粒度：word；character；subword  Word Tokenizer按照词进行分词，如：”I love you” -&gt; [“I”, “love”, “you”]优点：简单，容易理解，便于理解模型输出结果缺点：每个word分配一个id，所需的vocabulary根据语料大小而不同，会将意思一致的词分成两个不同的id Character Tokenizer按照字符进行分词，如：”I love you” -&gt; [“I”, “ “, “l”, “o”, “v”, “e”, “ “, “y”, “o”, “u”]优点：vocabulary相对小的多，适合中文缺点：对于英语来说，分词后的每个字符是毫无意义的，且输入的长度会变长 Subword Tokenizer按照词的子词进行分词，常用于英语，如‘today is...</div></div></div></a><a class="pagination-related" href="/2025/02/09/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E4%B9%8BDeepSeek/" title="大模型学习之DeepSeek"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-09</div><div class="info-item-2">大模型学习之DeepSeek</div></div><div class="info-2"><div class="info-item-1">个人学习笔记，如有错误欢迎指正 参考链接🔗： B站视频 DeepSeek LLM: Scaling Open-Source Language Models with Longtermism DeepSeek-V2: A Strong, Economical, and Efficient Mixture-of-Experts Language Model DeepSeekMoE: Towards Ultimate Expert Specialization in Mixture-of-Experts Language Models DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning 引言因为要看DeepSeek的优化的部分，绕不开的就是MoE 再然后就是COT  MoE 混合专家模型混合专家模型详解 MoE发展历史Jacobs et al 1991 每个专家都是独立的FFN，Gating是FFN，由Gating来决定输出那一个专家的结果   2017...</div></div></div></a><a class="pagination-related" href="/2024/10/04/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%A4%9A%E6%A8%A1%E6%80%81/" title="大模型学习之多模态"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-04</div><div class="info-item-2">大模型学习之多模态</div></div><div class="info-2"><div class="info-item-1">参考 多模态简述1. 多模态学习的概念 模态(Modality)：食物表达或感知的方式 多模态(multimodal)：研究异构(heterogeneous)和相互链接数据(interconnected data)的科学 多模态的行为和信号：   2.多模态学习六大挑战及经典工作 挑战一：Representation Learning 表式学习  学习不同模态之间交叉交互，包括融合，协调和分裂等子挑战。   挑战二：Aligment 对齐  连接，对齐表示，分割，将不同模态之间的信息进行关联对齐   挑战三：Reasoning 推理  结构 中间概念，外部范式，知识建模，不仅要求理解单个模态的信息，还要要求理解不同模态之间的信息如何进行交互，影响最终推理决策   挑战四：Generation 生成  摘要，翻译和生成，创造性的理解和生成信息一致的信息   挑战五：Transference 迁移  在模态之间转换知识，通过用一个模态的知识来提高另一个模态的能力   挑战六：Quantification 量化  更好的理解异构性，交叉模态交互，以及多模态学习的过程    </div></div></div></a><a class="pagination-related" href="/2024/12/05/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" title="大模型学习之大模型文件结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-05</div><div class="info-item-2">大模型学习之大模型文件结构</div></div><div class="info-2"><div class="info-item-1">下载途径不一样是否文件构成也不一样？ 以下内容以Xinference加载的Qwen2_5-InstructionAWQ-14B模型为例。  config.json configuration.json generation_config.json LIENSE merges.txt model.safetensors.index.json .safeatensors README.md tokenizer.json tokenizer_config.json vocab.json  1. config.json 配置文件 描述模型的架构、超参数和训练时的设置。包括模型的层数、隐藏单元数、激活函数等信息。 {“architectures”: [  “Qwen2ForCausalLM”],“attention_dropout”: 0.0,“bos_token_id”: 151643,“eos_token_id”: 151645,“hidden_act”: “silu”,“hidden_size”: 5120,“initializer_range”:...</div></div></div></a><a class="pagination-related" href="/2024/09/10/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%9B%86/" title="大模型学习之数据集"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-10</div><div class="info-item-2">大模型学习之数据集</div></div><div class="info-2"><div class="info-item-1">数据集预训练数据集和指令微调数据集的比较1. 预训练数据集 目的：学习通用的语言模式和特征，建立一个强大的语言理解和生成能力的模型 格式： 文本连续性：预训练数据集通常是由大量的连续文本组成的。这些文本可以来自书籍、文章、对话等 无明确标签：预训练数据集不需要显式的输入-输出对。例如，GPT类模型通常只需要大量的未标注文本来预测下一词或填补掩盖词    2. 指令微调数据集 目的：使模型能够理解和执行特定的任务指令，如回答问题，生成特定格式的文本等 格式： 明确的输入-输出对：指令微调数据集通常包含明确的输入(指令)和期望的输出(响应)。这些数据旨在训练模型根据特定的任务或指令生成准确的输出 指令和响应的对话结构：通常以对话形式，包括“指令”与回应    LLaMA-Factory支持 alpaca 格式和 sharegpt 格式的数据集 指令微调数据集的制作</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/eyes.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Dummy</div><div class="author-info-description">山与山不见面 再见容易再见难</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/DummyV07" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:dummy.v07@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Wechat:---NoOneIsComing （注明来意）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#LlamaFactory%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">LlamaFactory参数详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E8%B0%83%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.0.1.</span> <span class="toc-text">微调的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="toc-number">1.0.2.</span> <span class="toc-text">主要特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%BE%AE%E8%B0%83%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">1.微调方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LORA"><span class="toc-number">1.1.1.</span> <span class="toc-text">LORA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Full"><span class="toc-number">1.1.2.</span> <span class="toc-text">Full</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Freeze"><span class="toc-number">1.1.3.</span> <span class="toc-text">Freeze</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AE%AD%E7%BB%83%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">2.训练方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pre-Training"><span class="toc-number">1.2.1.</span> <span class="toc-text">Pre-Training</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Supervised-Fine-Tuning"><span class="toc-number">1.2.2.</span> <span class="toc-text">Supervised Fine-Tuning</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reward-Modeing"><span class="toc-number">1.2.3.</span> <span class="toc-text">Reward Modeing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PPO"><span class="toc-number">1.2.4.</span> <span class="toc-text">PPO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%BB%86%E8%8A%82"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">算法细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DPO"><span class="toc-number">1.2.5.</span> <span class="toc-text">DPO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KTO"><span class="toc-number">1.2.6.</span> <span class="toc-text">KTO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%BB%86%E8%8A%82-1"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">算法细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">具体实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E8%B0%83%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">微调参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">通用参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%8E%87"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">学习率</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.1.1.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.1.2.</span> <span class="toc-text">设置方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%8E%87%E8%B0%83%E8%8A%82%E5%99%A8"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">学习率调节器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#cosine"><span class="toc-number">1.3.1.2.1.</span> <span class="toc-text">cosine</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%AC%E5%BC%8F"><span class="toc-number">1.3.1.2.1.1.</span> <span class="toc-text">公式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">1.3.1.2.1.2.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.3.1.2.1.3.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.1.2.1.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#linear"><span class="toc-number">1.3.1.2.2.</span> <span class="toc-text">linear</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%AC%E5%BC%8F-1"><span class="toc-number">1.3.1.2.2.1.</span> <span class="toc-text">公式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF-1"><span class="toc-number">1.3.1.2.2.2.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">1.3.1.2.2.3.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.3.1.2.2.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cosine-with-restarts"><span class="toc-number">1.3.1.2.3.</span> <span class="toc-text">cosine_with_restarts</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%AC%E5%BC%8F-2"><span class="toc-number">1.3.1.2.3.1.</span> <span class="toc-text">公式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF-2"><span class="toc-number">1.3.1.2.3.2.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="toc-number">1.3.1.2.3.3.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">1.3.1.2.3.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#polynomial"><span class="toc-number">1.3.1.2.4.</span> <span class="toc-text">polynomial</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%AC%E5%BC%8F-3"><span class="toc-number">1.3.1.2.4.1.</span> <span class="toc-text">公式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF-3"><span class="toc-number">1.3.1.2.4.2.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-3"><span class="toc-number">1.3.1.2.4.3.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">1.3.1.2.4.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#constant"><span class="toc-number">1.3.1.2.5.</span> <span class="toc-text">constant</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%AC%E5%BC%8F-4"><span class="toc-number">1.3.1.2.5.1.</span> <span class="toc-text">公式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF-4"><span class="toc-number">1.3.1.2.5.2.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-4"><span class="toc-number">1.3.1.2.5.3.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">1.3.1.2.5.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#constant-with-warmup"><span class="toc-number">1.3.1.2.6.</span> <span class="toc-text">constant_with_warmup</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%AC%E5%BC%8F-5"><span class="toc-number">1.3.1.2.6.1.</span> <span class="toc-text">公式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF-5"><span class="toc-number">1.3.1.2.6.2.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-5"><span class="toc-number">1.3.1.2.6.3.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">1.3.1.2.6.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#inverse-sqrt"><span class="toc-number">1.3.1.2.7.</span> <span class="toc-text">inverse_sqrt</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%AC%E5%BC%8F-6"><span class="toc-number">1.3.1.2.7.1.</span> <span class="toc-text">公式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF-6"><span class="toc-number">1.3.1.2.7.2.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-6"><span class="toc-number">1.3.1.2.7.3.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-number">1.3.1.2.7.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#reduce-lr-on-plateau"><span class="toc-number">1.3.1.2.8.</span> <span class="toc-text">reduce_lr_on_plateau</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.1.2.8.1.</span> <span class="toc-text">机制</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF-7"><span class="toc-number">1.3.1.2.8.2.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-7"><span class="toc-number">1.3.1.2.8.3.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-7"><span class="toc-number">1.3.1.2.8.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cosine-with-min-lr"><span class="toc-number">1.3.1.2.9.</span> <span class="toc-text">cosine_with_min_lr</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%AC%E5%BC%8F-7"><span class="toc-number">1.3.1.2.9.1.</span> <span class="toc-text">公式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF-8"><span class="toc-number">1.3.1.2.9.2.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-8"><span class="toc-number">1.3.1.2.9.3.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-8"><span class="toc-number">1.3.1.2.9.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#warmup-stable-decay"><span class="toc-number">1.3.1.2.10.</span> <span class="toc-text">warmup_stable_decay</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%BA%E5%88%B6-1"><span class="toc-number">1.3.1.2.10.1.</span> <span class="toc-text">机制</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF-9"><span class="toc-number">1.3.1.2.10.2.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-9"><span class="toc-number">1.3.1.2.10.3.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-9"><span class="toc-number">1.3.1.2.10.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%AD%E7%BB%83%E8%BD%AE%E6%95%B0%EF%BC%88Epochs%EF%BC%89"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">训练轮数（Epochs）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-1"><span class="toc-number">1.3.1.3.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95-1"><span class="toc-number">1.3.1.3.2.</span> <span class="toc-text">设置方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%A2%AF%E5%BA%A6%E8%8C%83%E6%95%B0"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">最大梯度范数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-2"><span class="toc-number">1.3.1.4.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95-2"><span class="toc-number">1.3.1.4.2.</span> <span class="toc-text">设置方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%A0%B7%E6%9C%AC%E6%95%B0"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">最大样本数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-3"><span class="toc-number">1.3.1.5.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95-3"><span class="toc-number">1.3.1.5.2.</span> <span class="toc-text">设置方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">计算类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%AA%E6%96%AD%E9%95%BF%E5%BA%A6"><span class="toc-number">1.3.1.7.</span> <span class="toc-text">截断长度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-4"><span class="toc-number">1.3.1.7.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AD%96%E7%95%A5"><span class="toc-number">1.3.1.7.2.</span> <span class="toc-text">策略</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#llama-factory-%E7%9A%84%E5%85%B7%E4%BD%93%E7%AD%96%E7%95%A5"><span class="toc-number">1.3.1.7.2.1.</span> <span class="toc-text">llama_factory 的具体策略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.3.1.8.</span> <span class="toc-text">批处理大小</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%AE%AD%E7%BB%83%E9%80%9F%E5%BA%A6"><span class="toc-number">1.3.1.8.1.</span> <span class="toc-text">1. 训练速度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%A8%A1%E5%9E%8B%E6%80%A7%E8%83%BD"><span class="toc-number">1.3.1.8.2.</span> <span class="toc-text">2. 模型性能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97"><span class="toc-number">1.3.1.8.3.</span> <span class="toc-text">3. 资源消耗</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%A2%AF%E5%BA%A6%E6%9B%B4%E6%96%B0%E9%A2%91%E7%8E%87"><span class="toc-number">1.3.1.8.4.</span> <span class="toc-text">4. 梯度更新频率</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%AD%A6%E4%B9%A0%E7%8E%87%E8%B0%83%E6%95%B4"><span class="toc-number">1.3.1.8.5.</span> <span class="toc-text">5. 学习率调整</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B3%9B%E5%8C%96%E8%83%BD%E5%8A%9B"><span class="toc-number">1.3.1.8.6.</span> <span class="toc-text">6. 模型的泛化能力</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E8%AE%AD%E7%BB%83%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">1.3.1.8.7.</span> <span class="toc-text">7. 训练稳定性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%89%B9%E5%A4%84%E7%90%86%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.3.1.8.8.</span> <span class="toc-text">选择合适的批处理大小</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-10"><span class="toc-number">1.3.1.8.9.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A2%AF%E5%BA%A6%E7%B4%AF%E7%A7%AF"><span class="toc-number">1.3.1.9.</span> <span class="toc-text">梯度累积</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%A2%AF%E5%BA%A6%E7%B4%AF%E7%A7%AF%EF%BC%9F"><span class="toc-number">1.3.1.9.1.</span> <span class="toc-text">为什么需要梯度累积？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A2%AF%E5%BA%A6%E7%B4%AF%E7%A7%AF%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.1.9.2.</span> <span class="toc-text">梯度累积的工作原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A2%AF%E5%BA%A6%E7%B4%AF%E7%A7%AF%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.3.1.9.3.</span> <span class="toc-text">梯度累积的优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A2%AF%E5%BA%A6%E7%B4%AF%E7%A7%AF%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.3.1.9.4.</span> <span class="toc-text">梯度累积的注意事项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-11"><span class="toc-number">1.3.1.9.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E9%9B%86%E6%AF%94%E4%BE%8B"><span class="toc-number">1.3.1.10.</span> <span class="toc-text">验证集比例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%AA%8C%E8%AF%81%E9%9B%86%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.1.10.1.</span> <span class="toc-text">1. 验证集的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B8%B8%E8%A7%81%E7%9A%84%E9%AA%8C%E8%AF%81%E9%9B%86%E6%AF%94%E4%BE%8B"><span class="toc-number">1.3.1.10.2.</span> <span class="toc-text">2. 常见的验证集比例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%AA%8C%E8%AF%81%E9%9B%86%E6%AF%94%E4%BE%8B%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">1.3.1.10.3.</span> <span class="toc-text">3. 验证集比例的选择</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81"><span class="toc-number">1.3.1.10.4.</span> <span class="toc-text">4. 交叉验证</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E9%AA%8C%E8%AF%81%E9%9B%86%E6%AF%94%E4%BE%8B%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.3.1.10.5.</span> <span class="toc-text">6. 验证集比例的注意事项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-12"><span class="toc-number">1.3.1.10.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E7%83%AD%E6%AD%A5%E6%95%B0%EF%BC%88%E5%AD%A6%E4%B9%A0%E7%8E%87%E9%A2%84%E7%83%AD%E9%87%87%E7%94%A8%E7%9A%84%E6%AD%A5%E6%95%B0%EF%BC%89"><span class="toc-number">1.3.1.11.</span> <span class="toc-text">预热步数（学习率预热采用的步数）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%A2%84%E7%83%AD%E6%AD%A5%E6%95%B0%EF%BC%9F"><span class="toc-number">1.3.1.11.1.</span> <span class="toc-text">为什么需要预热步数？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E9%A2%84%E7%83%AD%E6%AD%A5%E6%95%B0%EF%BC%9F"><span class="toc-number">1.3.1.11.2.</span> <span class="toc-text">如何设置预热步数？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">1.3.1.11.3.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NEFTune%E5%99%AA%E5%A3%B0"><span class="toc-number">1.3.1.12.</span> <span class="toc-text">NEFTune噪声</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%99%AA%E5%A3%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.1.12.1.</span> <span class="toc-text">噪声的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%99%AA%E5%A3%B0%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.1.12.2.</span> <span class="toc-text">噪声的类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E5%99%AA%E5%A3%B0"><span class="toc-number">1.3.1.12.3.</span> <span class="toc-text">如何添加噪声</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-1"><span class="toc-number">1.3.1.12.4.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-number">1.3.1.13.</span> <span class="toc-text">优化器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#AdamW-%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-number">1.3.1.13.1.</span> <span class="toc-text">AdamW 优化器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.3.1.13.1.1.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AdamW-8-bit-%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-number">1.3.1.13.2.</span> <span class="toc-text">AdamW 8-bit 优化器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-number">1.3.1.13.2.1.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Adafactor-%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-number">1.3.1.13.3.</span> <span class="toc-text">Adafactor 优化器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-2"><span class="toc-number">1.3.1.13.3.1.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-2"><span class="toc-number">1.3.1.13.4.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E8%AF%8D%E8%A1%A8%E5%A4%A7%E5%B0%8F%EF%BC%88%E6%9B%B4%E6%94%B9%E5%88%86%E8%AF%8D%E5%99%A8%E8%AF%8D%E8%A1%A8%E5%92%8C%E5%B5%8C%E5%85%A5%E5%B1%82%E5%A4%A7%E5%B0%8F%EF%BC%89"><span class="toc-number">1.3.1.14.</span> <span class="toc-text">更改词表大小（更改分词器词表和嵌入层大小）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%8D%E8%A1%A8%EF%BC%88Vocabulary%EF%BC%89"><span class="toc-number">1.3.1.14.1.</span> <span class="toc-text">词表（Vocabulary）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%B1%82%EF%BC%88Embedding-Layer%EF%BC%89"><span class="toc-number">1.3.1.14.2.</span> <span class="toc-text">嵌入层（Embedding Layer）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9B%B4%E6%94%B9%E8%AF%8D%E8%A1%A8%E5%A4%A7%E5%B0%8F%E5%92%8C%E5%B5%8C%E5%85%A5%E5%B1%82%E5%A4%A7%E5%B0%8F%EF%BC%9F"><span class="toc-number">1.3.1.14.3.</span> <span class="toc-text">为什么要更改词表大小和嵌入层大小？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-3"><span class="toc-number">1.3.1.14.4.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E6%89%93%E5%8C%85"><span class="toc-number">1.3.1.15.</span> <span class="toc-text">序列打包</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%BA%8F%E5%88%97%E6%89%93%E5%8C%85%EF%BC%9F"><span class="toc-number">1.3.1.15.1.</span> <span class="toc-text">为什么需要序列打包？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E6%89%93%E5%8C%85%EF%BC%9F"><span class="toc-number">1.3.1.15.2.</span> <span class="toc-text">如何进行序列打包？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.1.15.3.</span> <span class="toc-text">在深度学习中的应用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-4"><span class="toc-number">1.3.1.15.4.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%A9%E6%94%BE%E5%BD%92%E4%B8%80%E5%8C%96%E5%B1%82"><span class="toc-number">1.3.1.16.</span> <span class="toc-text">缩放归一化层</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BC%A9%E6%94%BE%E5%BD%92%E4%B8%80%E5%8C%96%E5%B1%82%EF%BC%9F"><span class="toc-number">1.3.1.16.1.</span> <span class="toc-text">为什么需要缩放归一化层？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BD%92%E4%B8%80%E5%8C%96%E5%B1%82"><span class="toc-number">1.3.1.16.2.</span> <span class="toc-text">常见的归一化层</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BC%A9%E6%94%BE%E5%BD%92%E4%B8%80%E5%8C%96%E5%B1%82%EF%BC%9F"><span class="toc-number">1.3.1.16.3.</span> <span class="toc-text">如何实现缩放归一化层？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-5"><span class="toc-number">1.3.1.16.4.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8LLaMA-Pro"><span class="toc-number">1.3.1.17.</span> <span class="toc-text">使用LLaMA Pro</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%8F%90%E9%AB%98%E8%AE%AD%E7%BB%83%E6%95%88%E7%8E%87"><span class="toc-number">1.3.1.17.1.</span> <span class="toc-text">1. 提高训练效率</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BF%9D%E6%8C%81%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">1.3.1.17.2.</span> <span class="toc-text">2. 保持模型的稳定性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%81%B5%E6%B4%BB%E6%80%A7%E5%92%8C%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7"><span class="toc-number">1.3.1.17.3.</span> <span class="toc-text">3. 灵活性和可扩展性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E9%99%8D%E4%BD%8E%E8%BF%87%E6%8B%9F%E5%90%88%E9%A3%8E%E9%99%A9"><span class="toc-number">1.3.1.17.4.</span> <span class="toc-text">4. 降低过拟合风险</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.3.1.17.5.</span> <span class="toc-text">实际应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B1%EF%BC%9A%E5%BE%AE%E8%B0%83%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.1.17.5.1.</span> <span class="toc-text">示例1：微调预训练模型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B2%EF%BC%9A%E6%A8%A1%E5%9E%8B%E5%8E%8B%E7%BC%A9%E5%92%8C%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.1.17.5.2.</span> <span class="toc-text">示例2：模型压缩和优化</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-6"><span class="toc-number">1.3.1.17.6.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#S%C2%B2-Attention-shift-short-attention"><span class="toc-number">1.3.1.18.</span> <span class="toc-text">S² Attention(shift short attention)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#S%C2%B2-Attention%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">1.3.1.18.1.</span> <span class="toc-text">S² Attention的核心思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6"><span class="toc-number">1.3.1.18.2.</span> <span class="toc-text">主要组件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF-10"><span class="toc-number">1.3.1.18.3.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-7"><span class="toc-number">1.3.1.18.4.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%AE%AD%E7%BB%83%E5%B1%82%E6%95%B0"><span class="toc-number">1.3.1.19.</span> <span class="toc-text">可训练层数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E6%9C%AB%E7%AB%AF%EF%BC%88-%EF%BC%89%E5%8F%AF%E8%AE%AD%E7%BB%83%E9%9A%90%E8%97%8F%E5%B1%82%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-number">1.3.1.19.1.</span> <span class="toc-text">最末端（+）可训练隐藏层的数量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%89%8D%E7%AB%AF%EF%BC%88-%EF%BC%89%E5%8F%AF%E8%AE%AD%E7%BB%83%E9%9A%90%E8%97%8F%E5%B1%82%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-number">1.3.1.19.2.</span> <span class="toc-text">最前端（-）可训练隐藏层的数量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-8"><span class="toc-number">1.3.1.19.3.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9D%97"><span class="toc-number">1.3.1.20.</span> <span class="toc-text">可训练模块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#LLaMA-Factory%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8F%AF%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9D%97"><span class="toc-number">1.3.1.20.1.</span> <span class="toc-text">LLaMA Factory中的常见可训练模块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-9"><span class="toc-number">1.3.1.20.2.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E6%A8%A1%E5%9D%97-%E9%99%A4%E9%9A%90%E8%97%8F%E5%B1%82%E4%BB%A5%E5%A4%96%E7%9A%84%E5%8F%AF%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9D%97%E5%90%8D%E7%A7%B0"><span class="toc-number">1.3.1.21.</span> <span class="toc-text">额外模块(除隐藏层以外的可训练模块名称)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%B5%8C%E5%85%A5%E5%B1%82%EF%BC%88Embedding-Layer%EF%BC%89"><span class="toc-number">1.3.1.21.1.</span> <span class="toc-text">1. 嵌入层（Embedding Layer）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8D%B7%E7%A7%AF%E5%B1%82%EF%BC%88Convolutional-Layer%EF%BC%89"><span class="toc-number">1.3.1.21.2.</span> <span class="toc-text">2. 卷积层（Convolutional Layer）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%89%B9%E5%BD%92%E4%B8%80%E5%8C%96%E5%B1%82%EF%BC%88Batch-Normalization-Layer%EF%BC%89"><span class="toc-number">1.3.1.21.3.</span> <span class="toc-text">3. 批归一化层（Batch Normalization Layer）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%EF%BC%88Attention-Mechanism%EF%BC%89"><span class="toc-number">1.3.1.21.4.</span> <span class="toc-text">4. 注意力机制（Attention Mechanism）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E6%AE%8B%E5%B7%AE%E5%9D%97%EF%BC%88Residual-Block%EF%BC%89"><span class="toc-number">1.3.1.21.5.</span> <span class="toc-text">5. 残差块（Residual Block）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E9%80%92%E5%BD%92%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88Recurrent-Neural-Network-RNN%EF%BC%89"><span class="toc-number">1.3.1.21.6.</span> <span class="toc-text">6. 递归神经网络（Recurrent Neural Network, RNN）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E9%95%BF%E7%9F%AD%E6%9C%9F%E8%AE%B0%E5%BF%86%E7%BD%91%E7%BB%9C%EF%BC%88Long-Short-Term-Memory-LSTM%EF%BC%89"><span class="toc-number">1.3.1.21.7.</span> <span class="toc-text">7. 长短期记忆网络（Long Short-Term Memory, LSTM）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E9%97%A8%E6%8E%A7%E5%BE%AA%E7%8E%AF%E5%8D%95%E5%85%83%EF%BC%88Gated-Recurrent-Unit-GRU%EF%BC%89"><span class="toc-number">1.3.1.21.8.</span> <span class="toc-text">8. 门控循环单元（Gated Recurrent Unit, GRU）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-%E5%8F%98%E5%8E%8B%E5%99%A8%EF%BC%88Transformer%EF%BC%89"><span class="toc-number">1.3.1.21.9.</span> <span class="toc-text">9. 变压器（Transformer）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-%E5%9B%BE%E5%8D%B7%E7%A7%AF%E5%B1%82%EF%BC%88Graph-Convolutional-Layer%EF%BC%89"><span class="toc-number">1.3.1.21.10.</span> <span class="toc-text">10. 图卷积层（Graph Convolutional Layer）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-10"><span class="toc-number">1.3.1.21.11.</span> <span class="toc-text">结论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LoRA%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">LoRA参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LoRA%E7%A7%A9%EF%BC%88LoRA-%E7%9F%A9%E9%98%B5%E7%9A%84%E7%A7%A9%E5%A4%A7%E5%B0%8F%EF%BC%89"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">LoRA秩（LoRA 矩阵的秩大小）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%8E%E7%A7%A9%E5%88%86%E8%A7%A3"><span class="toc-number">1.3.2.1.1.</span> <span class="toc-text">低秩分解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LoRA-%E7%A7%A9%E5%A4%A7%E5%B0%8F%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">1.3.2.1.2.</span> <span class="toc-text">LoRA 秩大小的选择</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-11"><span class="toc-number">1.3.2.1.3.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LoRA-%E7%BC%A9%E6%94%BE%E7%B3%BB%E6%95%B0%EF%BC%88LoRA-%E7%BC%A9%E6%94%BE%E7%B3%BB%E6%95%B0%E5%A4%A7%E5%B0%8F%EF%BC%89"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">LoRA 缩放系数（LoRA 缩放系数大小）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#LoRA-%E7%BC%A9%E6%94%BE%E7%B3%BB%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.2.2.1.</span> <span class="toc-text">LoRA 缩放系数的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E7%BC%A9%E6%94%BE%E7%B3%BB%E6%95%B0"><span class="toc-number">1.3.2.2.2.</span> <span class="toc-text">选择合适的缩放系数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-12"><span class="toc-number">1.3.2.2.3.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LoRA-%E9%9A%8F%E6%9C%BA%E4%B8%A2%E5%BC%83%EF%BC%88LoRA-%E6%9D%83%E9%87%8D%E9%9A%8F%E6%9C%BA%E4%B8%A2%E5%BC%83%E7%9A%84%E6%A6%82%E7%8E%87%EF%BC%89"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">LoRA 随机丢弃（LoRA 权重随机丢弃的概率）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E4%B8%A2%E5%BC%83%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.2.3.1.</span> <span class="toc-text">随机丢弃的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E4%B8%A2%E5%BC%83%E7%9A%84%E6%A6%82%E7%8E%87"><span class="toc-number">1.3.2.3.2.</span> <span class="toc-text">随机丢弃的概率</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-13"><span class="toc-number">1.3.2.3.3.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LoRA-%E5%AD%A6%E4%B9%A0%E7%8E%87%E6%AF%94%E4%BE%8B%EF%BC%88LoRA-%E4%B8%AD-B-%E7%9F%A9%E9%98%B5%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%8E%87%E5%80%8D%E6%95%B0%EF%BC%89"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">LoRA+ 学习率比例（LoRA+ 中 B 矩阵的学习率倍数）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%8E%87%EF%BC%9F"><span class="toc-number">1.3.2.4.1.</span> <span class="toc-text">为什么需要不同的学习率？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LoRA-%E4%B8%AD-B-%E7%9F%A9%E9%98%B5%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%8E%87%E5%80%8D%E6%95%B0"><span class="toc-number">1.3.2.4.2.</span> <span class="toc-text">LoRA+ 中 B 矩阵的学习率倍数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-14"><span class="toc-number">1.3.2.4.3.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">新建适配器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-rslora%EF%BC%88%E5%AF%B9-LoRA-%E5%B1%82%E4%BD%BF%E7%94%A8%E7%A7%A9%E7%A8%B3%E5%AE%9A%E7%BC%A9%E6%94%BE%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">使用 rslora（对 LoRA 层使用秩稳定缩放方法）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-DoRA%EF%BC%88%E4%BD%BF%E7%94%A8%E6%9D%83%E9%87%8D%E5%88%86%E8%A7%A3%E7%9A%84-LoRA%EF%BC%89"><span class="toc-number">1.3.2.7.</span> <span class="toc-text">使用 DoRA（使用权重分解的 LoRA）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LoRA-%E4%BD%9C%E7%94%A8%E6%A8%A1%E5%9D%97"><span class="toc-number">1.3.2.8.</span> <span class="toc-text">LoRA 作用模块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84LoRA%E4%BD%9C%E7%94%A8%E6%A8%A1%E5%9D%97"><span class="toc-number">1.3.2.8.1.</span> <span class="toc-text">常见的LoRA作用模块</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E6%A8%A1%E5%9D%97"><span class="toc-number">1.3.2.9.</span> <span class="toc-text">附加模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%99%84%E5%8A%A0%E6%A8%A1%E5%9D%97"><span class="toc-number">1.3.2.10.</span> <span class="toc-text">常见的附加模块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RLHF%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text">RLHF参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Beta%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">Beta参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RLHF%E4%B8%AD%E7%9A%84Beta%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.3.1.1.</span> <span class="toc-text">RLHF中的Beta参数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%A5%96%E5%8A%B1%E6%8D%9F%E5%A4%B1%EF%BC%88Reward-Loss%EF%BC%89"><span class="toc-number">1.3.3.1.1.1.</span> <span class="toc-text">1. 奖励损失（Reward Loss）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E8%A1%8C%E4%B8%BA%E5%85%8B%E9%9A%86%E6%8D%9F%E5%A4%B1%EF%BC%88Behavior-Cloning-Loss%EF%BC%89"><span class="toc-number">1.3.3.1.1.2.</span> <span class="toc-text">2. 行为克隆损失（Behavior Cloning Loss）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E6%AD%A3%E5%88%99%E5%8C%96%E9%A1%B9%EF%BC%88Regularization-Term%EF%BC%89"><span class="toc-number">1.3.3.1.1.3.</span> <span class="toc-text">3. 正则化项（Regularization Term）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Beta%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.3.1.2.</span> <span class="toc-text">Beta参数的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E8%B0%83%E6%95%B4%E5%A5%96%E5%8A%B1%E6%8D%9F%E5%A4%B1%E7%9A%84%E6%9D%83%E9%87%8D"><span class="toc-number">1.3.3.1.2.1.</span> <span class="toc-text">1. 调整奖励损失的权重</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E8%B0%83%E6%95%B4%E8%A1%8C%E4%B8%BA%E5%85%8B%E9%9A%86%E6%8D%9F%E5%A4%B1%E7%9A%84%E6%9D%83%E9%87%8D"><span class="toc-number">1.3.3.1.2.2.</span> <span class="toc-text">2. 调整行为克隆损失的权重</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E6%8E%A7%E5%88%B6%E6%AD%A3%E5%88%99%E5%8C%96%E9%A1%B9%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.3.3.1.2.3.</span> <span class="toc-text">3. 控制正则化项的影响</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.3.1.3.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B0%83%E6%95%B4Beta%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.3.1.3.1.</span> <span class="toc-text">调整Beta参数</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-15"><span class="toc-number">1.3.3.1.4.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ftx-gamma"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">Ftx gamma</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RLHF%E4%B8%AD%E7%9A%84Gamma%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.3.2.1.</span> <span class="toc-text">RLHF中的Gamma参数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%A5%96%E5%8A%B1%E6%8D%9F%E5%A4%B1%EF%BC%88Reward-Loss%EF%BC%89-1"><span class="toc-number">1.3.3.2.1.1.</span> <span class="toc-text">1. 奖励损失（Reward Loss）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E8%A1%8C%E4%B8%BA%E5%85%8B%E9%9A%86%E6%8D%9F%E5%A4%B1%EF%BC%88Behavior-Cloning-Loss%EF%BC%89-1"><span class="toc-number">1.3.3.2.1.2.</span> <span class="toc-text">2. 行为克隆损失（Behavior Cloning Loss）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E7%9B%91%E7%9D%A3%E5%BE%AE%E8%B0%83%E6%8D%9F%E5%A4%B1%EF%BC%88SFT-Loss%EF%BC%89"><span class="toc-number">1.3.3.2.1.3.</span> <span class="toc-text">3. 监督微调损失（SFT Loss）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E6%AD%A3%E5%88%99%E5%8C%96%E9%A1%B9%EF%BC%88Regularization-Term%EF%BC%89"><span class="toc-number">1.3.3.2.1.4.</span> <span class="toc-text">4. 正则化项（Regularization Term）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Gamma%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.3.2.2.</span> <span class="toc-text">Gamma参数的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%A2%9E%E5%8A%A0%E7%9B%91%E7%9D%A3%E5%BE%AE%E8%B0%83%E6%8D%9F%E5%A4%B1%E7%9A%84%E6%9D%83%E9%87%8D"><span class="toc-number">1.3.3.2.2.1.</span> <span class="toc-text">1. 增加监督微调损失的权重</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%87%8F%E5%B0%91%E7%9B%91%E7%9D%A3%E5%BE%AE%E8%B0%83%E6%8D%9F%E5%A4%B1%E7%9A%84%E6%9D%83%E9%87%8D"><span class="toc-number">1.3.3.2.2.2.</span> <span class="toc-text">2. 减少监督微调损失的权重</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">1.3.3.2.3.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E6%95%B4Gamma%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.3.2.4.</span> <span class="toc-text">调整Gamma参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-16"><span class="toc-number">1.3.3.2.5.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">损失函数类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#sigmoid"><span class="toc-number">1.3.3.3.1.</span> <span class="toc-text">sigmoid</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Sigmoid-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.3.3.1.1.</span> <span class="toc-text">Sigmoid 损失函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Sigmoid-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.3.3.1.2.</span> <span class="toc-text">Sigmoid 损失函数的应用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-17"><span class="toc-number">1.3.3.3.1.3.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#hinge"><span class="toc-number">1.3.3.3.2.</span> <span class="toc-text">hinge</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Hinge-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.3.3.2.1.</span> <span class="toc-text">Hinge 损失函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Hinge-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.3.3.3.2.2.</span> <span class="toc-text">Hinge 损失函数的特点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Hinge-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.3.3.2.3.</span> <span class="toc-text">Hinge 损失函数的应用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Hinge-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%98%E4%BD%93"><span class="toc-number">1.3.3.3.2.4.</span> <span class="toc-text">Hinge 损失函数的变体</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-18"><span class="toc-number">1.3.3.3.2.5.</span> <span class="toc-text">结论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ipo"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">ipo</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BA%AB%E4%BB%BD%E5%81%8F%E5%A5%BD%E4%BC%98%E5%8C%96-IPO-%EF%BC%9F"><span class="toc-number">1.3.3.4.1.</span> <span class="toc-text">什么是身份偏好优化 (IPO)？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IPO-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.3.4.2.</span> <span class="toc-text">IPO 的工作原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IPO-%E4%B8%AD%E7%9A%84%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.3.4.3.</span> <span class="toc-text">IPO 中的损失函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IPO-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.3.3.4.4.</span> <span class="toc-text">IPO 的优势</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-13"><span class="toc-number">1.3.3.4.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kto-pair"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">kto_pair</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Kahneman-Tversky-%E4%BC%98%E5%8C%96%EF%BC%88KTO%EF%BC%89%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">1.3.3.5.1.</span> <span class="toc-text">Kahneman-Tversky 优化（KTO）的核心思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#KTO-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.3.5.2.</span> <span class="toc-text">KTO 的工作原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%B7%E5%80%BC%E5%87%BD%E6%95%B0%E5%92%8C%E6%A6%82%E7%8E%87%E5%8A%A0%E6%9D%83%E5%87%BD%E6%95%B0%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.3.5.3.</span> <span class="toc-text">价值函数和概率加权函数的示例</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%B7%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.3.5.3.1.</span> <span class="toc-text">价值函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A6%82%E7%8E%87%E5%8A%A0%E6%9D%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.3.5.3.2.</span> <span class="toc-text">概率加权函数</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-14"><span class="toc-number">1.3.3.5.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#orpo"><span class="toc-number">1.3.3.6.</span> <span class="toc-text">orpo</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ORPO-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">1.3.3.6.1.</span> <span class="toc-text">ORPO 的核心思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ORPO-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.3.6.2.</span> <span class="toc-text">ORPO 的工作原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ORPO-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.3.3.6.3.</span> <span class="toc-text">ORPO 的优势</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ORPO-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.3.3.6.4.</span> <span class="toc-text">ORPO 的实现步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-15"><span class="toc-number">1.3.3.6.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#simpo"><span class="toc-number">1.3.3.7.</span> <span class="toc-text">simpo</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SimPO-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">1.3.3.7.1.</span> <span class="toc-text">SimPO 的核心思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SimPO-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.3.7.2.</span> <span class="toc-text">SimPO 的工作原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SimPO-%E4%B8%8E-DPO-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.3.3.7.3.</span> <span class="toc-text">SimPO 与 DPO 的对比</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-16"><span class="toc-number">1.3.3.7.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GaLore"><span class="toc-number">1.3.4.</span> <span class="toc-text">GaLore</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GaLore%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">GaLore参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A2%AF%E5%BA%A6%E4%BD%8E%E7%A7%A9%E6%8A%95%E5%BD%B1%EF%BC%9F"><span class="toc-number">1.3.4.1.1.</span> <span class="toc-text">什么是梯度低秩投影？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%A2%AF%E5%BA%A6%E4%BD%8E%E7%A7%A9%E6%8A%95%E5%BD%B1%EF%BC%9F"><span class="toc-number">1.3.4.1.2.</span> <span class="toc-text">为什么使用梯度低秩投影？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#GaLore-%E5%8F%82%E6%95%B0%E5%9C%A8%E5%BE%AE%E8%B0%83%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.4.1.3.</span> <span class="toc-text">GaLore 参数在微调中的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.4.1.4.</span> <span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-17"><span class="toc-number">1.3.4.1.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GaLore%E7%A7%A9"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">GaLore秩</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%89%E6%8B%A9GaLore%E7%A7%A9%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.3.4.2.1.</span> <span class="toc-text">选择GaLore秩的影响</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84GaLore%E7%A7%A9"><span class="toc-number">1.3.4.2.2.</span> <span class="toc-text">如何选择合适的GaLore秩</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-18"><span class="toc-number">1.3.4.2.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E9%97%B4%E9%9A%94"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">更新间隔</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%9B%B4%E6%96%B0%E9%97%B4%E9%9A%94"><span class="toc-number">1.3.4.3.1.</span> <span class="toc-text">选择合适的更新间隔</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%9B%B4%E6%96%B0%E9%97%B4%E9%9A%94"><span class="toc-number">1.3.4.3.2.</span> <span class="toc-text">如何选择合适的更新间隔</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-19"><span class="toc-number">1.3.4.3.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GaLore-%E7%BC%A9%E6%94%BE%E7%B3%BB%E6%95%B0"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">GaLore 缩放系数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%A9%E6%94%BE%E7%B3%BB%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.4.4.1.</span> <span class="toc-text">缩放系数的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E7%BC%A9%E6%94%BE%E7%B3%BB%E6%95%B0"><span class="toc-number">1.3.4.4.2.</span> <span class="toc-text">如何选择合适的缩放系数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-20"><span class="toc-number">1.3.4.4.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BAdam-%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.5.</span> <span class="toc-text">BAdam 参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BAdam-%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">BAdam 优化器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Adam-%E4%BC%98%E5%8C%96%E5%99%A8%E5%9B%9E%E9%A1%BE"><span class="toc-number">1.3.5.1.1.</span> <span class="toc-text">Adam 优化器回顾</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BAdam-%E4%BC%98%E5%8C%96%E5%99%A8%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">1.3.5.1.2.</span> <span class="toc-text">BAdam 优化器的改进</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-21"><span class="toc-number">1.3.5.1.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BAdam-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">BAdam 模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Layer-wise-BAdam"><span class="toc-number">1.3.5.2.1.</span> <span class="toc-text">Layer-wise BAdam</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">1.3.5.2.1.1.</span> <span class="toc-text">优点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Ratio-wise-BAdam"><span class="toc-number">1.3.5.2.2.</span> <span class="toc-text">Ratio-wise BAdam</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">1.3.5.2.2.1.</span> <span class="toc-text">优点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-22"><span class="toc-number">1.3.5.2.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">切换策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Ascending%EF%BC%88%E5%8D%87%E5%BA%8F%EF%BC%89"><span class="toc-number">1.3.5.3.1.</span> <span class="toc-text">1. Ascending（升序）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-2"><span class="toc-number">1.3.5.3.1.1.</span> <span class="toc-text">优点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Descending%EF%BC%88%E9%99%8D%E5%BA%8F%EF%BC%89"><span class="toc-number">1.3.5.3.2.</span> <span class="toc-text">2. Descending（降序）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-3"><span class="toc-number">1.3.5.3.2.1.</span> <span class="toc-text">优点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Random%EF%BC%88%E9%9A%8F%E6%9C%BA%EF%BC%89"><span class="toc-number">1.3.5.3.3.</span> <span class="toc-text">3. Random（随机）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-4"><span class="toc-number">1.3.5.3.3.1.</span> <span class="toc-text">优点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Fixed%EF%BC%88%E5%9B%BA%E5%AE%9A%EF%BC%89"><span class="toc-number">1.3.5.3.4.</span> <span class="toc-text">4. Fixed（固定）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-5"><span class="toc-number">1.3.5.3.4.1.</span> <span class="toc-text">优点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-23"><span class="toc-number">1.3.5.3.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E9%A2%91%E7%8E%87"><span class="toc-number">1.3.5.4.</span> <span class="toc-text">切换频率</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%AF%8F%E6%AC%A1%E8%BF%AD%E4%BB%A3%E5%88%87%E6%8D%A2%EF%BC%88Per-Iteration-Switching%EF%BC%89"><span class="toc-number">1.3.5.4.1.</span> <span class="toc-text">1. 每次迭代切换（Per-Iteration Switching）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-6"><span class="toc-number">1.3.5.4.1.1.</span> <span class="toc-text">优点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%AF%8F%E4%B8%AA-Epoch-%E5%88%87%E6%8D%A2%EF%BC%88Per-Epoch-Switching%EF%BC%89"><span class="toc-number">1.3.5.4.2.</span> <span class="toc-text">2. 每个 Epoch 切换（Per-Epoch Switching）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-7"><span class="toc-number">1.3.5.4.2.1.</span> <span class="toc-text">优点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%AF%8F-N-%E6%AC%A1%E8%BF%AD%E4%BB%A3%E5%88%87%E6%8D%A2%EF%BC%88Per-N-Iterations-Switching%EF%BC%89"><span class="toc-number">1.3.5.4.3.</span> <span class="toc-text">3. 每 N 次迭代切换（Per-N-Iterations Switching）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-8"><span class="toc-number">1.3.5.4.3.1.</span> <span class="toc-text">优点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2%EF%BC%88Dynamic-Switching%EF%BC%89"><span class="toc-number">1.3.5.4.4.</span> <span class="toc-text">4. 动态切换（Dynamic Switching）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-9"><span class="toc-number">1.3.5.4.4.1.</span> <span class="toc-text">优点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-24"><span class="toc-number">1.3.5.4.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%AF%94%E4%BE%8B"><span class="toc-number">1.3.5.5.</span> <span class="toc-text">更新比例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9D%87%E5%8C%80%E6%9B%B4%E6%96%B0%E6%AF%94%E4%BE%8B%EF%BC%88Uniform-Update-Ratio%EF%BC%89"><span class="toc-number">1.3.5.5.1.</span> <span class="toc-text">1. 均匀更新比例（Uniform Update Ratio）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-10"><span class="toc-number">1.3.5.5.1.1.</span> <span class="toc-text">优点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8A%A0%E6%9D%83%E6%9B%B4%E6%96%B0%E6%AF%94%E4%BE%8B%EF%BC%88Weighted-Update-Ratio%EF%BC%89"><span class="toc-number">1.3.5.5.2.</span> <span class="toc-text">2. 加权更新比例（Weighted Update Ratio）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-11"><span class="toc-number">1.3.5.5.2.1.</span> <span class="toc-text">优点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E6%AF%94%E4%BE%8B%EF%BC%88Dynamic-Update-Ratio%EF%BC%89"><span class="toc-number">1.3.5.5.3.</span> <span class="toc-text">3. 动态更新比例（Dynamic Update Ratio）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-12"><span class="toc-number">1.3.5.5.3.1.</span> <span class="toc-text">优点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%9B%BA%E5%AE%9A%E6%9B%B4%E6%96%B0%E6%AF%94%E4%BE%8B%EF%BC%88Fixed-Update-Ratio%EF%BC%89"><span class="toc-number">1.3.5.5.4.</span> <span class="toc-text">4. 固定更新比例（Fixed Update Ratio）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-13"><span class="toc-number">1.3.5.5.4.1.</span> <span class="toc-text">优点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-25"><span class="toc-number">1.3.5.5.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DeepSpeed-stage"><span class="toc-number">1.3.6.</span> <span class="toc-text">DeepSpeed stage</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-None"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">1. None</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-14"><span class="toc-number">1.3.6.1.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.3.6.1.2.</span> <span class="toc-text">适用场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Stage-2"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">2. Stage 2</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-15"><span class="toc-number">1.3.6.2.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">1.3.6.2.2.</span> <span class="toc-text">适用场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Stage-3"><span class="toc-number">1.3.6.3.</span> <span class="toc-text">3. Stage 3</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-16"><span class="toc-number">1.3.6.3.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">1.3.6.3.2.</span> <span class="toc-text">适用场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-26"><span class="toc-number">1.3.6.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DeepSpeed-offload"><span class="toc-number">1.3.7.</span> <span class="toc-text">DeepSpeed offload</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DeepSpeed-Offload-%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">DeepSpeed Offload 主要特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A"><span class="toc-number">1.3.7.2.</span> <span class="toc-text">参数解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Offload-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.3.7.3.</span> <span class="toc-text">Offload 的优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-27"><span class="toc-number">1.3.7.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Top-p-%E9%87%87%E6%A0%B7%E5%80%BC"><span class="toc-number">1.3.8.</span> <span class="toc-text">Top-p 采样值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Top-p-%E9%87%87%E6%A0%B7%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.8.1.</span> <span class="toc-text">Top-p 采样的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A-1"><span class="toc-number">1.3.8.2.</span> <span class="toc-text">参数解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">1.3.8.3.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Top-p-%E9%87%87%E6%A0%B7%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.3.8.4.</span> <span class="toc-text">Top-p 采样的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Top-p-%E9%87%87%E6%A0%B7%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">1.3.8.5.</span> <span class="toc-text">Top-p 采样的缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Top-p-%E9%87%87%E6%A0%B7%E4%B8%8E-Top-k-%E9%87%87%E6%A0%B7%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.3.8.6.</span> <span class="toc-text">Top-p 采样与 Top-k 采样的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-28"><span class="toc-number">1.3.8.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%A9%E5%BA%A6%E7%B3%BB%E6%95%B0"><span class="toc-number">1.3.9.</span> <span class="toc-text">温度系数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%A9%E5%BA%A6%E7%B3%BB%E6%95%B0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.9.1.</span> <span class="toc-text">温度系数的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%A9%E5%BA%A6%E7%B3%BB%E6%95%B0%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.3.9.2.</span> <span class="toc-text">温度系数的影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">1.3.9.3.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%8E%E6%B8%A9%E5%BA%A6%EF%BC%88T-0-5%EF%BC%89"><span class="toc-number">1.3.9.3.1.</span> <span class="toc-text">低温度（T &#x3D; 0.5）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AB%98%E6%B8%A9%E5%BA%A6%EF%BC%88T-1-5%EF%BC%89"><span class="toc-number">1.3.9.3.2.</span> <span class="toc-text">高温度（T &#x3D; 1.5）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-29"><span class="toc-number">1.3.9.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#safetensors-%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.3.10.</span> <span class="toc-text">safetensors 格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#safetensors-%E6%A0%BC%E5%BC%8F%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.3.10.1.</span> <span class="toc-text">safetensors 格式的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#safetensors-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.10.2.</span> <span class="toc-text">safetensors 的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-safetensors-%E5%BA%93"><span class="toc-number">1.3.10.2.1.</span> <span class="toc-text">安装 safetensors 库</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%9D%83%E9%87%8D%E4%B8%BA-safetensors-%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.3.10.2.2.</span> <span class="toc-text">保存模型权重为 safetensors 格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD-safetensors-%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%A8%A1%E5%9E%8B%E6%9D%83%E9%87%8D"><span class="toc-number">1.3.10.2.3.</span> <span class="toc-text">加载 safetensors 格式的模型权重</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#safetensors-%E6%A0%BC%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.3.10.3.</span> <span class="toc-text">safetensors 格式的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#safetensors-%E6%A0%BC%E5%BC%8F%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">1.3.10.4.</span> <span class="toc-text">safetensors 格式的缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-30"><span class="toc-number">1.3.10.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/22/MCP/" title="MCP"><img src="/img/mcp.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MCP"/></a><div class="content"><a class="title" href="/2025/07/22/MCP/" title="MCP">MCP</a><time datetime="2025-07-22T04:00:00.000Z" title="发表于 2025-07-22 12:00:00">2025-07-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/13/Docker-Python/" title="Docker部署python项目"><img src="/img/docker.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker部署python项目"/></a><div class="content"><a class="title" href="/2025/07/13/Docker-Python/" title="Docker部署python项目">Docker部署python项目</a><time datetime="2025-07-13T06:00:00.000Z" title="发表于 2025-07-13 14:00:00">2025-07-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/30/service_manager/" title="service_manager"><img src="/img/service_manager.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="service_manager"/></a><div class="content"><a class="title" href="/2025/06/30/service_manager/" title="service_manager">service_manager</a><time datetime="2025-06-30T04:00:00.000Z" title="发表于 2025-06-30 12:00:00">2025-06-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/" title="机器学习之集成学习"><img src="/img/jcxx.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="机器学习之集成学习"/></a><div class="content"><a class="title" href="/2025/06/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/" title="机器学习之集成学习">机器学习之集成学习</a><time datetime="2025-06-11T01:00:00.000Z" title="发表于 2025-06-11 09:00:00">2025-06-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BSVM/" title="机器学习之SVM"><img src="/img/svm.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="机器学习之SVM"/></a><div class="content"><a class="title" href="/2025/06/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BSVM/" title="机器学习之SVM">机器学习之SVM</a><time datetime="2025-06-11T01:00:00.000Z" title="发表于 2025-06-11 09:00:00">2025-06-11</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Dummy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.2.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>