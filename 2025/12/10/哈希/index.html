<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>哈希 | 廾匸</title><meta name="author" content="Dummy"><meta name="copyright" content="Dummy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="🧬 哈希哈希（Hash）是一种**把任意长度的数据，通过某种算法，变成固定长度的”指纹”**的技术。 哈希有什么特点 不可逆 输入 → 输出是容易的，但输出 → 输入几乎不可能。 固定长度 比如 SHA-256 无论输入什么内容，结果一定是 256-bit（64 个十六进制字符）。 雪崩效应（Avalanche Effect） 输入改一个字母，输出完全变样，毫无规律可循。 相同输入，一定得到相同">
<meta property="og:type" content="article">
<meta property="og:title" content="哈希">
<meta property="og:url" content="https://dummyv07.github.io/2025/12/10/%E5%93%88%E5%B8%8C/index.html">
<meta property="og:site_name" content="廾匸">
<meta property="og:description" content="🧬 哈希哈希（Hash）是一种**把任意长度的数据，通过某种算法，变成固定长度的”指纹”**的技术。 哈希有什么特点 不可逆 输入 → 输出是容易的，但输出 → 输入几乎不可能。 固定长度 比如 SHA-256 无论输入什么内容，结果一定是 256-bit（64 个十六进制字符）。 雪崩效应（Avalanche Effect） 输入改一个字母，输出完全变样，毫无规律可循。 相同输入，一定得到相同">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://dummyv07.github.io/img/hash.jpeg">
<meta property="article:published_time" content="2025-12-10T08:00:00.000Z">
<meta property="article:modified_time" content="2025-12-10T07:25:04.906Z">
<meta property="article:author" content="Dummy">
<meta property="article:tag" content="blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dummyv07.github.io/img/hash.jpeg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "哈希",
  "url": "https://dummyv07.github.io/2025/12/10/%E5%93%88%E5%B8%8C/",
  "image": "https://dummyv07.github.io/img/hash.jpeg",
  "datePublished": "2025-12-10T08:00:00.000Z",
  "dateModified": "2025-12-10T07:25:04.906Z",
  "author": [
    {
      "@type": "Person",
      "name": "Dummy",
      "url": "https://dummyv07.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://dummyv07.github.io/2025/12/10/%E5%93%88%E5%B8%8C/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '哈希',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/eyes.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/hash.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">廾匸</span></a><a class="nav-page-title" href="/"><span class="site-name">哈希</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">哈希</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-10T08:00:00.000Z" title="发表于 2025-12-10 16:00:00">2025-12-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-10T07:25:04.906Z" title="更新于 2025-12-10 15:25:04">2025-12-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="🧬-哈希"><a href="#🧬-哈希" class="headerlink" title="🧬 哈希"></a>🧬 哈希</h1><p>哈希（Hash）是一种**把任意长度的数据，通过某种算法，变成固定长度的”指纹”**的技术。</p>
<h2 id="哈希有什么特点"><a href="#哈希有什么特点" class="headerlink" title="哈希有什么特点"></a>哈希有什么特点</h2><ol>
<li><strong>不可逆</strong><br> 输入 → 输出是容易的，但输出 → 输入几乎不可能。</li>
<li><strong>固定长度</strong><br> 比如 SHA-256 无论输入什么内容，结果一定是 256-bit（64 个十六进制字符）。</li>
<li><strong>雪崩效应（Avalanche Effect）</strong><br> 输入改一个字母，输出完全变样，毫无规律可循。</li>
<li><strong>相同输入，一定得到相同输出</strong><br> 这是它能用于检测数据变化的原因。</li>
</ol>
<h2 id="哈希的常见用途"><a href="#哈希的常见用途" class="headerlink" title="哈希的常见用途"></a>哈希的常见用途</h2><ol>
<li><strong>密码存储</strong><br> 服务器不会直接保存你的明文密码，而是保存 Hash(你的密码)</li>
<li><strong>区块链</strong><br> 区块链的本质就是<br> 哈希 → 再哈希 → 再哈希<br> 哈希链条串起来谁也改不了</li>
<li><strong>文件校验</strong><br> 你下载一个游戏包，它会给你一个hash值<br> 你算一下就知道文件有没有被修改</li>
<li><strong>哈希表、字典（HashMap）</strong><br> 计算 hash → 决定数据放哪里 → 查找速度提升到 O(1)。</li>
</ol>
<hr>
<h1 id="🔬-哈希深入学习"><a href="#🔬-哈希深入学习" class="headerlink" title="🔬 哈希深入学习"></a>🔬 哈希深入学习</h1><hr>
<h2 id="①-哈希为什么不可逆？（数学基础）"><a href="#①-哈希为什么不可逆？（数学基础）" class="headerlink" title="① 哈希为什么不可逆？（数学基础）"></a>① 哈希为什么不可逆？（数学基础）</h2><h3 id="什么叫单向函数？"><a href="#什么叫单向函数？" class="headerlink" title="什么叫单向函数？"></a>什么叫单向函数？</h3><p>单向函数（One-Way Function）是密码学的核心概念之一。它满足：</p>
<ol>
<li><strong>正向计算容易</strong>：给定输入  x ，计算  f(x)  是多项式时间内可解的</li>
<li><strong>反向计算困难</strong>：给定输出  y &#x3D; f(x) ，找到  x  使得  f(x) &#x3D; y  在计算上不可行</li>
</ol>
<p>数学上，哈希函数  H: {0,1}^* \rightarrow {0,1}^n  将任意长度的输入映射到固定长度  n  的输出。</p>
<h3 id="为什么-SHA-256-反推几乎不可能？"><a href="#为什么-SHA-256-反推几乎不可能？" class="headerlink" title="为什么 SHA-256 反推几乎不可能？"></a>为什么 SHA-256 反推几乎不可能？</h3><p>SHA-256 的输出空间是  2^{256} ，这是一个<strong>天文数字</strong>：</p>
<ul>
<li>2^{256} \approx 1.16 \times 10^{77} </li>
<li>宇宙中的原子数量约为  10^{80} </li>
<li>即使每秒尝试  10^{18}  次（1 exa-hash），也需要  10^{59}  秒 ≈  10^{51}  年</li>
</ul>
<p>更重要的是，哈希函数的设计使得：</p>
<ol>
<li><strong>信息丢失</strong>：输入空间是无限的，输出空间是有限的（ 2^{256} ），必然存在碰撞</li>
<li><strong>非线性混合</strong>：通过多轮位运算、移位、异或等操作，输入和输出之间没有简单的数学关系</li>
<li><strong>雪崩效应</strong>：输入的微小变化导致输出的巨大变化，无法通过局部搜索找到原像</li>
</ol>
<h3 id="2²⁵⁶-有多大？为什么暴力破解不可行？"><a href="#2²⁵⁶-有多大？为什么暴力破解不可行？" class="headerlink" title="2²⁵⁶ 有多大？为什么暴力破解不可行？"></a>2²⁵⁶ 有多大？为什么暴力破解不可行？</h3><p>让我们用具体例子理解  2^{256}  的规模：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2^256 = 115,792,089,237,316,195,423,570,985,008,687,907,853,269,984,665,640,564,039,457,584,007,913,129,639,936</span><br></pre></td></tr></table></figure>

<p>假设：</p>
<ul>
<li>全球有  10^{10}  台计算机</li>
<li>每台计算机每秒计算  10^9  次哈希</li>
<li>总计算能力： 10^{19}  次&#x2F;秒</li>
</ul>
<p>即使这样，遍历所有  2^{256}  个可能值也需要：<br>  \frac{2^{256}}{10^{19}} \approx 10^{58} \text{ 秒} \approx 10^{50} \text{ 年}  </p>
<p>这远远超过了宇宙的年龄（约  10^{10}  年）！</p>
<h3 id="哈希输出值的均匀分布特性"><a href="#哈希输出值的均匀分布特性" class="headerlink" title="哈希输出值的均匀分布特性"></a>哈希输出值的均匀分布特性</h3><p>好的哈希函数应该将输入<strong>均匀分布</strong>到输出空间。这意味着：</p>
<ul>
<li>对于任意输入，每个可能的输出值出现的概率相等</li>
<li>输入和输出之间<strong>没有统计相关性</strong></li>
<li>即使输入有规律，输出也应该看起来<strong>随机</strong></li>
</ul>
<p>数学上，对于随机输入  x ， H(x)  应该满足：<br>  P(H(x) &#x3D; y) &#x3D; \frac{1}{2^n} \quad \forall y \in {0,1}^n  </p>
<p>这种均匀分布特性是通过精心设计的<strong>混淆（Confusion）</strong>和<strong>扩散（Diffusion）</strong>机制实现的。</p>
<hr>
<h2 id="②-雪崩效应（Avalanche-Effect）背后的原理"><a href="#②-雪崩效应（Avalanche-Effect）背后的原理" class="headerlink" title="② 雪崩效应（Avalanche Effect）背后的原理"></a>② 雪崩效应（Avalanche Effect）背后的原理</h2><h3 id="什么是雪崩效应？"><a href="#什么是雪崩效应？" class="headerlink" title="什么是雪崩效应？"></a>什么是雪崩效应？</h3><p>雪崩效应是指：<strong>输入的微小变化（改变1个比特）导致输出的巨大变化（约50%的比特改变）</strong>。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHA-256(&quot;hello&quot;) = 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824</span><br><span class="line">SHA-256(&quot;Hello&quot;) = 8b1a9953c4611296a827abf8c47804d7a5f8437a29b7a3bc9d8e8c5e5c5e5e5e</span><br></pre></td></tr></table></figure>

<p>仅仅改变一个字母的大小写，哈希值就完全不同！</p>
<h3 id="掩码（Mask）、位运算、混淆与扩散"><a href="#掩码（Mask）、位运算、混淆与扩散" class="headerlink" title="掩码（Mask）、位运算、混淆与扩散"></a>掩码（Mask）、位运算、混淆与扩散</h3><h4 id="混淆（Confusion）"><a href="#混淆（Confusion）" class="headerlink" title="混淆（Confusion）"></a>混淆（Confusion）</h4><p>混淆使得<strong>输入和输出之间的关系变得复杂</strong>，无法通过分析输出推断输入。</p>
<p>主要技术：</p>
<ul>
<li><strong>S-Box（Substitution Box）</strong>：非线性替换表</li>
<li><strong>位运算混合</strong>：AND、OR、XOR、NOT 的组合</li>
<li><strong>模运算</strong>： x \bmod p  的非线性特性</li>
</ul>
<h4 id="扩散（Diffusion）"><a href="#扩散（Diffusion）" class="headerlink" title="扩散（Diffusion）"></a>扩散（Diffusion）</h4><p>扩散使得<strong>输入的每一位都影响输出的每一位</strong>。</p>
<p>主要技术：</p>
<ul>
<li><strong>循环左移（Rotate Left）</strong>：<code>ROTL(x, n)</code> 将比特向左循环移动</li>
<li><strong>移位（Shift）</strong>：<code>x &lt;&lt; n</code> 将比特向左移动</li>
<li><strong>置换（Permutation）</strong>：重新排列比特位置</li>
</ul>
<h3 id="为什么”改一个比特-→-输出变化一半以上”？"><a href="#为什么”改一个比特-→-输出变化一半以上”？" class="headerlink" title="为什么”改一个比特 → 输出变化一半以上”？"></a>为什么”改一个比特 → 输出变化一半以上”？</h3><p>这是通过<strong>多轮迭代</strong>实现的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simple_mix</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    一个简单的模拟混合函数，不是加密安全，仅用于演示雪崩效应。</span></span><br><span class="line"><span class="string">    对64位整数进行多轮位操作与置换。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    x = (x ^ (x &gt;&gt; <span class="number">13</span>)) &amp; <span class="number">0xFFFFFFFFFFFFFFFF</span></span><br><span class="line">    x = (x * <span class="number">0x5DEECE66D</span>) &amp; <span class="number">0xFFFFFFFFFFFFFFFF</span></span><br><span class="line">    x = (x ^ (x &lt;&lt; <span class="number">17</span>)) &amp; <span class="number">0xFFFFFFFFFFFFFFFF</span></span><br><span class="line">    x = (x ^ (x &gt;&gt; <span class="number">29</span>)) &amp; <span class="number">0xFFFFFFFFFFFFFFFF</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">avalanche_effect_demo</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;演示雪崩效应&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 初始状态（64位十六进制表示）</span></span><br><span class="line">    state = <span class="number">0x1234567890ABCDEF</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 改变最低位</span></span><br><span class="line">    state_modified = state ^ <span class="number">0x1</span>  <span class="comment"># 只改变1个比特</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;初始值:            <span class="subst">&#123;state:016X&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;初始值（改1比特）: <span class="subst">&#123;state_modified:016X&#125;</span>\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="string">&#x27;轮数&#x27;</span>:&lt;<span class="number">4</span>&#125;</span><span class="subst">&#123;<span class="string">&#x27;state&#x27;</span>:&gt;<span class="number">18</span>&#125;</span><span class="subst">&#123;<span class="string">&#x27;state_modified&#x27;</span>:&gt;<span class="number">24</span>&#125;</span><span class="subst">&#123;<span class="string">&#x27;差异比特数&#x27;</span>:&gt;<span class="number">12</span>&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 统计每轮后的差异</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">round</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">65</span>):  <span class="comment"># 包括初始状态</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">round</span> &gt; <span class="number">0</span>:</span><br><span class="line">            state = simple_mix(state)</span><br><span class="line">            state_modified = simple_mix(state_modified)</span><br><span class="line">        diff = <span class="built_in">bin</span>(state ^ state_modified).count(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">round</span>:&lt;<span class="number">4</span>&#125;</span><span class="subst">&#123;state:018X&#125;</span><span class="subst">&#123;state_modified:024X&#125;</span><span class="subst">&#123;diff:<span class="number">12</span>&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n最终改变的比特数: <span class="subst">&#123;diff&#125;</span>/64 = <span class="subst">&#123;diff/<span class="number">64</span>*<span class="number">100</span>:<span class="number">.1</span>f&#125;</span>%&quot;</span>)</span><br><span class="line"></span><br><span class="line">avalanche_effect_demo()</span><br></pre></td></tr></table></figure>

<p>每一轮操作都会：</p>
<ol>
<li><strong>放大差异</strong>：通过移位和异或，单个比特差异扩散到多个位置</li>
<li><strong>非线性混合</strong>：S-Box 和模运算使得差异无法预测</li>
<li><strong>累积效应</strong>：64轮后，差异被放大到约50%的比特</li>
</ol>
<h3 id="S-Box、轮函数、逻辑混合的内部结构"><a href="#S-Box、轮函数、逻辑混合的内部结构" class="headerlink" title="S-Box、轮函数、逻辑混合的内部结构"></a>S-Box、轮函数、逻辑混合的内部结构</h3><h4 id="S-Box（Substitution-Box）"><a href="#S-Box（Substitution-Box）" class="headerlink" title="S-Box（Substitution Box）"></a>S-Box（Substitution Box）</h4><p>S-Box 是一个查找表，将输入映射到输出，提供非线性变换：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简化的S-Box示例（实际SHA-256使用更复杂的函数）</span></span><br><span class="line">SBOX = [</span><br><span class="line">    <span class="number">0x63</span>, <span class="number">0x7c</span>, <span class="number">0x77</span>, <span class="number">0x7b</span>, <span class="number">0xf2</span>, <span class="number">0x6b</span>, <span class="number">0x6f</span>, <span class="number">0xc5</span>,</span><br><span class="line">    <span class="comment"># ... 更多值</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sbox_substitute</span>(<span class="params">byte</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;S-Box替换&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> SBOX[byte]</span><br></pre></td></tr></table></figure>

<h4 id="轮函数（Round-Function）"><a href="#轮函数（Round-Function）" class="headerlink" title="轮函数（Round Function）"></a>轮函数（Round Function）</h4><p>SHA-256 的压缩函数包含64轮，每轮执行：</p>
<p>  T_1 &#x3D; h + \Sigma_1(e) + Ch(e,f,g) + K_i + W_i<br>  T_2 &#x3D; \Sigma_0(a) + Maj(a,b,c)<br>  h &#x3D; g, g &#x3D; f, f &#x3D; e, e &#x3D; d + T_1<br>  d &#x3D; c, c &#x3D; b, b &#x3D; a, a &#x3D; T_1 + T_2  </p>
<p>其中：</p>
<ul>
<li>\Sigma_0, \Sigma_1 ：循环右移和异或的组合</li>
<li>Ch ：选择函数（Choose）</li>
<li>Maj ：多数函数（Majority）</li>
</ul>
<h4 id="逻辑混合示例"><a href="#逻辑混合示例" class="headerlink" title="逻辑混合示例"></a>逻辑混合示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sha256_round_function</span>(<span class="params">a, b, c, d, e, f, g, h, w, k</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;SHA-256单轮函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 选择函数</span></span><br><span class="line">    ch = (e &amp; f) ^ (~e &amp; g)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 多数函数</span></span><br><span class="line">    maj = (a &amp; b) ^ (a &amp; c) ^ (b &amp; c)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Sigma函数</span></span><br><span class="line">    sigma0 = rotr(a, <span class="number">2</span>) ^ rotr(a, <span class="number">13</span>) ^ rotr(a, <span class="number">22</span>)</span><br><span class="line">    sigma1 = rotr(e, <span class="number">6</span>) ^ rotr(e, <span class="number">11</span>) ^ rotr(e, <span class="number">25</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算临时值</span></span><br><span class="line">    t1 = h + sigma1 + ch + k + w</span><br><span class="line">    t2 = sigma0 + maj</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (a + t1, b, c, d, e + t1, f, g, h)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="③-哈希冲突（Collision）到底是什么？"><a href="#③-哈希冲突（Collision）到底是什么？" class="headerlink" title="③ 哈希冲突（Collision）到底是什么？"></a>③ 哈希冲突（Collision）到底是什么？</h2><h3 id="鸽巢原理（Pigeonhole-Principle）"><a href="#鸽巢原理（Pigeonhole-Principle）" class="headerlink" title="鸽巢原理（Pigeonhole Principle）"></a>鸽巢原理（Pigeonhole Principle）</h3><p><strong>鸽巢原理</strong>：如果有  n+1  只鸽子要飞进  n  个鸽巢，那么至少有一个鸽巢里有两只鸽子。</p>
<p>应用到哈希函数：</p>
<ul>
<li><strong>输入空间</strong>：无限（任意长度的字符串）</li>
<li><strong>输出空间</strong>：有限（例如  2^{256}  个可能值）</li>
<li><strong>结论</strong>：必然存在多个不同的输入映射到相同的输出</li>
</ul>
<p>数学表达：<br>对于哈希函数  H: {0,1}^* \rightarrow {0,1}^n ，存在  x_1 \neq x_2  使得  H(x_1) &#x3D; H(x_2) 。</p>
<h3 id="理论上一定有冲突，为什么我们几乎见不到？"><a href="#理论上一定有冲突，为什么我们几乎见不到？" class="headerlink" title="理论上一定有冲突，为什么我们几乎见不到？"></a>理论上一定有冲突，为什么我们几乎见不到？</h3><p>虽然冲突必然存在，但找到冲突在计算上<strong>极其困难</strong>。</p>
<h4 id="生日攻击（Birthday-Attack）"><a href="#生日攻击（Birthday-Attack）" class="headerlink" title="生日攻击（Birthday Attack）"></a>生日攻击（Birthday Attack）</h4><p>生日悖论：在一个23人的房间里，两个人生日相同的概率超过50%。</p>
<p>应用到哈希冲突：<br>对于  n  位哈希，需要尝试约  \sqrt{2^n} &#x3D; 2^{n&#x2F;2}  个输入才能找到冲突。</p>
<p>对于 SHA-256（ n&#x3D;256 ）：</p>
<ul>
<li>需要尝试约  2^{128}  次</li>
<li>即使每秒  10^{18}  次，也需要  10^{22}  年</li>
</ul>
<h4 id="实际冲突概率"><a href="#实际冲突概率" class="headerlink" title="实际冲突概率"></a>实际冲突概率</h4><p>假设我们哈希  k  个不同的输入，冲突概率为：</p>
<p>  P(\text{冲突}) \approx 1 - e^{-\frac{k^2}{2^{n+1}}}  </p>
<p>对于 SHA-256，即使哈希  2^{64}  个输入，冲突概率也小于  10^{-9} 。</p>
<h3 id="坏哈希-vs-好哈希"><a href="#坏哈希-vs-好哈希" class="headerlink" title="坏哈希 vs 好哈希"></a>坏哈希 vs 好哈希</h3><h4 id="坏哈希的例子"><a href="#坏哈希的例子" class="headerlink" title="坏哈希的例子"></a>坏哈希的例子</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bad_hash</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;简单的坏哈希函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="built_in">ord</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> s) % <span class="number">256</span></span><br></pre></td></tr></table></figure>

<p>问题：</p>
<ul>
<li>容易找到冲突：<code>&quot;ab&quot;</code> 和 <code>&quot;ba&quot;</code> 哈希值相同</li>
<li>分布不均匀：常见字符组合会聚集</li>
<li>可预测：输入有规律，输出也有规律</li>
</ul>
<h4 id="好哈希的特征"><a href="#好哈希的特征" class="headerlink" title="好哈希的特征"></a>好哈希的特征</h4><ol>
<li><strong>抗碰撞性（Collision Resistance）</strong>：找到两个不同输入产生相同输出在计算上不可行</li>
<li><strong>抗原像性（Preimage Resistance）</strong>：给定输出，找到输入在计算上不可行</li>
<li><strong>抗第二原像性（Second Preimage Resistance）</strong>：给定输入，找到另一个输入产生相同输出在计算上不可行</li>
<li><strong>均匀分布</strong>：输出在输出空间中均匀分布</li>
<li><strong>雪崩效应</strong>：输入的微小变化导致输出的巨大变化</li>
</ol>
<h3 id="如何设计抗碰撞算法？"><a href="#如何设计抗碰撞算法？" class="headerlink" title="如何设计抗碰撞算法？"></a>如何设计抗碰撞算法？</h3><h4 id="Merkle–Damgard-结构"><a href="#Merkle–Damgard-结构" class="headerlink" title="Merkle–Damgård 结构"></a>Merkle–Damgård 结构</h4><p>大多数哈希函数（MD5、SHA-1、SHA-256）使用 Merkle–Damgård 结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入消息 → 填充 → 分块 → 压缩函数迭代 → 输出</span><br></pre></td></tr></table></figure>

<p>关键点：</p>
<ul>
<li><strong>填充（Padding）</strong>：确保消息长度是块大小的倍数</li>
<li><strong>压缩函数</strong>：将固定大小的输入压缩到更小的输出</li>
<li><strong>迭代</strong>：将压缩函数迭代应用到每个块</li>
</ul>
<h4 id="压缩函数的设计原则"><a href="#压缩函数的设计原则" class="headerlink" title="压缩函数的设计原则"></a>压缩函数的设计原则</h4><ol>
<li><strong>非线性性</strong>：使用 S-Box、模运算等非线性操作</li>
<li><strong>扩散性</strong>：确保输入的每一位影响输出的每一位</li>
<li><strong>混淆性</strong>：输入和输出之间的关系复杂</li>
<li><strong>轮数足够</strong>：足够的轮数确保充分混合</li>
</ol>
<hr>
<h2 id="④-常见哈希算法背后的结构"><a href="#④-常见哈希算法背后的结构" class="headerlink" title="④ 常见哈希算法背后的结构"></a>④ 常见哈希算法背后的结构</h2><h3 id="MD5-是怎么被攻破的？"><a href="#MD5-是怎么被攻破的？" class="headerlink" title="MD5 是怎么被攻破的？"></a>MD5 是怎么被攻破的？</h3><p>MD5（Message Digest 5）设计于1991年，输出128位。</p>
<h4 id="MD5-的结构"><a href="#MD5-的结构" class="headerlink" title="MD5 的结构"></a>MD5 的结构</h4><ul>
<li><strong>块大小</strong>：512位</li>
<li><strong>输出长度</strong>：128位</li>
<li><strong>轮数</strong>：4轮，每轮16步，共64步</li>
</ul>
<h4 id="被攻破的原因"><a href="#被攻破的原因" class="headerlink" title="被攻破的原因"></a>被攻破的原因</h4><ol>
<li><strong>轮数不足</strong>：64步不足以充分混合</li>
<li><strong>压缩函数弱点</strong>：存在可预测的差分路径</li>
<li><strong>碰撞攻击</strong>：2004年，王小云教授找到了MD5的碰撞攻击方法</li>
</ol>
<h4 id="实际攻击"><a href="#实际攻击" class="headerlink" title="实际攻击"></a>实际攻击</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MD5碰撞示例（仅演示，实际攻击更复杂）</span></span><br><span class="line"><span class="comment"># 这两个不同的输入产生相同的MD5值</span></span><br><span class="line">msg1 = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;d131dd02c5e6eec4693d9a0698aff95c2fcab58712467eab4004583eb8fb7f89&quot;</span>)</span><br><span class="line">msg2 = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;d131dd02c5e6eec4693d9a0698aff95c2fcab50712467eab4004583eb8fb7f89&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="built_in">print</span>(hashlib.md5(msg1).hexdigest())  <span class="comment"># 相同</span></span><br><span class="line"><span class="built_in">print</span>(hashlib.md5(msg2).hexdigest())  <span class="comment"># 相同</span></span><br></pre></td></tr></table></figure>

<p><strong>结论</strong>：MD5 已不再安全，不应用于密码学应用。</p>
<h3 id="SHA-1-为什么不安全？"><a href="#SHA-1-为什么不安全？" class="headerlink" title="SHA-1 为什么不安全？"></a>SHA-1 为什么不安全？</h3><p>SHA-1（Secure Hash Algorithm 1）设计于1995年，输出160位。</p>
<h4 id="SHA-1-的结构"><a href="#SHA-1-的结构" class="headerlink" title="SHA-1 的结构"></a>SHA-1 的结构</h4><ul>
<li><strong>块大小</strong>：512位</li>
<li><strong>输出长度</strong>：160位</li>
<li><strong>轮数</strong>：80轮</li>
</ul>
<h4 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h4><ol>
<li><strong>理论弱点</strong>：2005年发现了理论攻击，复杂度  2^{69} </li>
<li><strong>实际碰撞</strong>：2017年，Google 和 CWI 找到了实际碰撞</li>
<li><strong>长度扩展攻击</strong>：可以构造新消息，使其哈希值可预测</li>
</ol>
<h4 id="SHA-1-碰撞示例"><a href="#SHA-1-碰撞示例" class="headerlink" title="SHA-1 碰撞示例"></a>SHA-1 碰撞示例</h4><p>Google 在2017年展示了两个不同的PDF文件具有相同的SHA-1值，证明了SHA-1的不安全性。</p>
<p><strong>结论</strong>：SHA-1 已不再安全，应迁移到 SHA-256 或 SHA-3。</p>
<h3 id="SHA-256-为什么更强？"><a href="#SHA-256-为什么更强？" class="headerlink" title="SHA-256 为什么更强？"></a>SHA-256 为什么更强？</h3><p>SHA-256 是 SHA-2 家族的一员，设计于2001年。</p>
<h4 id="SHA-256-的结构"><a href="#SHA-256-的结构" class="headerlink" title="SHA-256 的结构"></a>SHA-256 的结构</h4><ul>
<li><strong>块大小</strong>：512位</li>
<li><strong>输出长度</strong>：256位</li>
<li><strong>轮数</strong>：64轮</li>
<li><strong>内部状态</strong>：8个32位字（256位）</li>
</ul>
<h4 id="安全增强"><a href="#安全增强" class="headerlink" title="安全增强"></a>安全增强</h4><ol>
<li><strong>更大的输出空间</strong>：256位 vs SHA-1的160位</li>
<li><strong>更强的压缩函数</strong>：使用更复杂的轮函数</li>
<li><strong>更好的扩散</strong>：每轮操作确保充分混合</li>
<li><strong>抗长度扩展攻击</strong>：通过填充和长度编码防止攻击</li>
</ol>
<h4 id="SHA-256-的压缩函数"><a href="#SHA-256-的压缩函数" class="headerlink" title="SHA-256 的压缩函数"></a>SHA-256 的压缩函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sha256_compress</span>(<span class="params">block, state</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;SHA-256压缩函数（简化版）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 消息调度</span></span><br><span class="line">    W = message_schedule(block)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化工作变量</span></span><br><span class="line">    a, b, c, d, e, f, g, h = state</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 64轮主循环</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):</span><br><span class="line">        a, b, c, d, e, f, g, h = sha256_round(</span><br><span class="line">            a, b, c, d, e, f, g, h, W[i], K[i]</span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 更新状态</span></span><br><span class="line">    <span class="keyword">return</span> [(x + y) &amp; <span class="number">0xFFFFFFFF</span> <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(state, [a,b,c,d,e,f,g,h])]</span><br></pre></td></tr></table></figure>

<h4 id="当前状态"><a href="#当前状态" class="headerlink" title="当前状态"></a>当前状态</h4><ul>
<li><strong>安全性</strong>：目前没有已知的实用攻击</li>
<li><strong>推荐使用</strong>：广泛用于密码学应用</li>
<li><strong>未来</strong>：SHA-3 作为备选方案</li>
</ul>
<h3 id="Merkle–Damgard-结构详解"><a href="#Merkle–Damgard-结构详解" class="headerlink" title="Merkle–Damgård 结构详解"></a>Merkle–Damgård 结构详解</h3><h4 id="结构流程"><a href="#结构流程" class="headerlink" title="结构流程"></a>结构流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入消息 M</span><br><span class="line">    ↓</span><br><span class="line">填充（Padding）：M || 1 || 0...0 || 长度</span><br><span class="line">    ↓</span><br><span class="line">分块：M = M₁ || M₂ || ... || Mₖ（每块512位）</span><br><span class="line">    ↓</span><br><span class="line">初始化：H₀ = IV（初始向量）</span><br><span class="line">    ↓</span><br><span class="line">迭代压缩：</span><br><span class="line">    H₁ = Compress(H₀, M₁)</span><br><span class="line">    H₂ = Compress(H₁, M₂)</span><br><span class="line">    ...</span><br><span class="line">    Hₖ = Compress(Hₖ₋₁, Mₖ)</span><br><span class="line">    ↓</span><br><span class="line">输出：Hₖ</span><br></pre></td></tr></table></figure>

<h4 id="填充规则（Padding）"><a href="#填充规则（Padding）" class="headerlink" title="填充规则（Padding）"></a>填充规则（Padding）</h4><p>SHA-256 的填充规则：</p>
<ol>
<li>在消息末尾添加一个 <code>1</code> 比特</li>
<li>添加  k  个 <code>0</code> 比特，使得 <code>消息长度 + 1 + k + 64 ≡ 0 (mod 512)</code></li>
<li>添加64位的消息长度（以比特为单位）</li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原始消息: &quot;abc&quot; (24 bits)</span><br><span class="line">填充后: &quot;abc&quot; || 1 || 000...000 || 000...00000011000 (64位长度)</span><br><span class="line">总长度: 512 bits (1块)</span><br></pre></td></tr></table></figure>

<h4 id="压缩函数（Compression-Function）"><a href="#压缩函数（Compression-Function）" class="headerlink" title="压缩函数（Compression Function）"></a>压缩函数（Compression Function）</h4><p>压缩函数  f: {0,1}^{256} \times {0,1}^{512} \rightarrow {0,1}^{256}  将：</p>
<ul>
<li>256位的状态（ H_{i-1} ）</li>
<li>512位的消息块（ M_i ）</li>
</ul>
<p>压缩为新的256位状态（ H_i ）。</p>
<hr>
<h2 id="⑤-哈希在密码学中的应用"><a href="#⑤-哈希在密码学中的应用" class="headerlink" title="⑤ 哈希在密码学中的应用"></a>⑤ 哈希在密码学中的应用</h2><h3 id="HMAC（带密钥的哈希）"><a href="#HMAC（带密钥的哈希）" class="headerlink" title="HMAC（带密钥的哈希）"></a>HMAC（带密钥的哈希）</h3><p>HMAC（Hash-based Message Authentication Code）使用密钥和哈希函数生成消息认证码。</p>
<h4 id="HMAC-算法"><a href="#HMAC-算法" class="headerlink" title="HMAC 算法"></a>HMAC 算法</h4><p>  HMAC(K, m) &#x3D; H((K \oplus opad) || H((K \oplus ipad) || m))  </p>
<p>其中：</p>
<ul>
<li>K ：密钥</li>
<li>m ：消息</li>
<li>opad ：外部填充（0x5c重复）</li>
<li>ipad ：内部填充（0x36重复）</li>
<li>H ：哈希函数（如 SHA-256）</li>
</ul>
<h4 id="Python-实现示例"><a href="#Python-实现示例" class="headerlink" title="Python 实现示例"></a>Python 实现示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hmac_sha256</span>(<span class="params">key, message</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;HMAC-SHA256实现&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> hmac.new(key, message, hashlib.sha256).hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">key = <span class="string">b&quot;secret_key&quot;</span></span><br><span class="line">message = <span class="string">b&quot;Hello, World!&quot;</span></span><br><span class="line">mac = hmac_sha256(key, message)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;HMAC: <span class="subst">&#123;mac&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li><strong>API认证</strong>：验证请求的完整性</li>
<li><strong>数字签名</strong>：消息认证码</li>
<li><strong>会话令牌</strong>：防止令牌被篡改</li>
</ul>
<h3 id="PBKDF2、bcrypt、scrypt、Argon2"><a href="#PBKDF2、bcrypt、scrypt、Argon2" class="headerlink" title="PBKDF2、bcrypt、scrypt、Argon2"></a>PBKDF2、bcrypt、scrypt、Argon2</h3><p>这些是<strong>密钥派生函数（KDF）</strong>，用于从密码生成密钥。</p>
<h4 id="PBKDF2（Password-Based-Key-Derivation-Function-2）"><a href="#PBKDF2（Password-Based-Key-Derivation-Function-2）" class="headerlink" title="PBKDF2（Password-Based Key Derivation Function 2）"></a>PBKDF2（Password-Based Key Derivation Function 2）</h4><p>  PBKDF2(P, S, c, dkLen) &#x3D; U_1 \oplus U_2 \oplus … \oplus U_{l}  </p>
<p>其中：</p>
<ul>
<li>P ：密码</li>
<li>S ：盐（Salt）</li>
<li>c ：迭代次数</li>
<li>dkLen ：派生密钥长度</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> cryptography.hazmat.primitives <span class="keyword">import</span> hashes</span><br><span class="line"><span class="keyword">from</span> cryptography.hazmat.primitives.kdf.pbkdf2 <span class="keyword">import</span> PBKDF2HMAC</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">derive_key</span>(<span class="params">password, salt, iterations=<span class="number">100000</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用PBKDF2派生密钥&quot;&quot;&quot;</span></span><br><span class="line">    kdf = PBKDF2HMAC(</span><br><span class="line">        algorithm=hashes.SHA256(),</span><br><span class="line">        length=<span class="number">32</span>,</span><br><span class="line">        salt=salt,</span><br><span class="line">        iterations=iterations,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> kdf.derive(password.encode())</span><br></pre></td></tr></table></figure>

<h4 id="bcrypt"><a href="#bcrypt" class="headerlink" title="bcrypt"></a>bcrypt</h4><p>bcrypt 专门设计用于密码哈希，内置盐和自适应成本因子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bcrypt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hash_password</span>(<span class="params">password</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用bcrypt哈希密码&quot;&quot;&quot;</span></span><br><span class="line">    salt = bcrypt.gensalt(rounds=<span class="number">12</span>)  <span class="comment"># 成本因子</span></span><br><span class="line">    <span class="keyword">return</span> bcrypt.hashpw(password.encode(), salt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">verify_password</span>(<span class="params">password, hashed</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;验证密码&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> bcrypt.checkpw(password.encode(), hashed)</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li><strong>自适应</strong>：可以增加成本因子以应对计算能力提升</li>
<li><strong>内置盐</strong>：自动生成和使用盐</li>
<li><strong>内存友好</strong>：不需要大量内存</li>
</ul>
<h4 id="scrypt"><a href="#scrypt" class="headerlink" title="scrypt"></a>scrypt</h4><p>scrypt 设计用于抵抗<strong>专用硬件攻击</strong>（如ASIC、FPGA）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> scrypt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hash_password_scrypt</span>(<span class="params">password, salt</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用scrypt哈希密码&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> scrypt.<span class="built_in">hash</span>(</span><br><span class="line">        password.encode(),</span><br><span class="line">        salt,</span><br><span class="line">        N=<span class="number">16384</span>,      <span class="comment"># CPU/内存成本参数</span></span><br><span class="line">        r=<span class="number">8</span>,          <span class="comment"># 块大小参数</span></span><br><span class="line">        p=<span class="number">1</span>,          <span class="comment"># 并行度参数</span></span><br><span class="line">        buflen=<span class="number">64</span>     <span class="comment"># 输出长度</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li><strong>内存硬</strong>：需要大量内存，难以用硬件加速</li>
<li><strong>可调参数</strong>：可以调整内存和CPU成本</li>
</ul>
<h4 id="Argon2"><a href="#Argon2" class="headerlink" title="Argon2"></a>Argon2</h4><p>Argon2 是2015年密码哈希竞赛的获胜者，被认为是<strong>最安全的密码哈希函数</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argon2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hash_password_argon2</span>(<span class="params">password</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用Argon2哈希密码&quot;&quot;&quot;</span></span><br><span class="line">    ph = argon2.PasswordHasher()</span><br><span class="line">    <span class="keyword">return</span> ph.<span class="built_in">hash</span>(password)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">verify_password_argon2</span>(<span class="params">password, hashed</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;验证密码&quot;&quot;&quot;</span></span><br><span class="line">    ph = argon2.PasswordHasher()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ph.verify(hashed, password)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>Argon2 变体：</p>
<ul>
<li><strong>Argon2i</strong>：抗侧信道攻击</li>
<li><strong>Argon2d</strong>：最大化抗GPU破解能力</li>
<li><strong>Argon2id</strong>：混合模式（推荐）</li>
</ul>
<h3 id="加盐（Salt）的作用和彩虹表攻击防护"><a href="#加盐（Salt）的作用和彩虹表攻击防护" class="headerlink" title="加盐（Salt）的作用和彩虹表攻击防护"></a>加盐（Salt）的作用和彩虹表攻击防护</h3><h4 id="为什么需要加盐？"><a href="#为什么需要加盐？" class="headerlink" title="为什么需要加盐？"></a>为什么需要加盐？</h4><p><strong>不加盐的问题</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">密码 &quot;123456&quot; → SHA-256 → &quot;8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92&quot;</span><br></pre></td></tr></table></figure>

<p>攻击者可以：</p>
<ol>
<li>预计算常见密码的哈希值（<strong>彩虹表</strong>）</li>
<li>直接查表找到密码</li>
</ol>
<p><strong>加盐后</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">密码 &quot;123456&quot; + 盐 &quot;random_salt_123&quot; → SHA-256 → &quot;完全不同的哈希值&quot;</span><br></pre></td></tr></table></figure>

<p>即使密码相同，不同的盐会产生不同的哈希值。</p>
<h4 id="彩虹表攻击（Rainbow-Table-Attack）"><a href="#彩虹表攻击（Rainbow-Table-Attack）" class="headerlink" title="彩虹表攻击（Rainbow Table Attack）"></a>彩虹表攻击（Rainbow Table Attack）</h4><p>彩虹表是<strong>预计算的哈希值表</strong>，包含常见密码和对应的哈希值。</p>
<p><strong>防护措施</strong>：</p>
<ol>
<li><p><strong>加盐</strong>：每个密码使用唯一的随机盐</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hash_with_salt</span>(<span class="params">password</span>):</span><br><span class="line">    salt = os.urandom(<span class="number">32</span>)  <span class="comment"># 32字节随机盐</span></span><br><span class="line">    hash_value = hashlib.pbkdf2_hmac(</span><br><span class="line">        <span class="string">&#x27;sha256&#x27;</span>,</span><br><span class="line">        password.encode(),</span><br><span class="line">        salt,</span><br><span class="line">        <span class="number">100000</span>  <span class="comment"># 迭代次数</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> salt + hash_value  <span class="comment"># 存储时包含盐</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>增加迭代次数</strong>：使用 PBKDF2、bcrypt 等慢哈希函数</p>
</li>
<li><p><strong>使用唯一盐</strong>：每个用户使用不同的盐</p>
</li>
<li><p><strong>盐的长度</strong>：至少16字节（128位）</p>
</li>
</ol>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> secrets</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">secure_password_hash</span>(<span class="params">password</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;安全的密码哈希&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 生成随机盐（至少16字节）</span></span><br><span class="line">    salt = secrets.token_bytes(<span class="number">32</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用PBKDF2派生密钥（慢哈希）</span></span><br><span class="line">    key = hashlib.pbkdf2_hmac(</span><br><span class="line">        <span class="string">&#x27;sha256&#x27;</span>,</span><br><span class="line">        password.encode(<span class="string">&#x27;utf-8&#x27;</span>),</span><br><span class="line">        salt,</span><br><span class="line">        <span class="number">100000</span>  <span class="comment"># 迭代次数，可以根据硬件调整</span></span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回：盐长度(1字节) + 盐 + 哈希值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>([<span class="built_in">len</span>(salt)]) + salt + key</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">verify_password</span>(<span class="params">password, stored_hash</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;验证密码&quot;&quot;&quot;</span></span><br><span class="line">    salt_len = stored_hash[<span class="number">0</span>]</span><br><span class="line">    salt = stored_hash[<span class="number">1</span>:<span class="number">1</span>+salt_len]</span><br><span class="line">    stored_key = stored_hash[<span class="number">1</span>+salt_len:]</span><br><span class="line">    </span><br><span class="line">    key = hashlib.pbkdf2_hmac(</span><br><span class="line">        <span class="string">&#x27;sha256&#x27;</span>,</span><br><span class="line">        password.encode(<span class="string">&#x27;utf-8&#x27;</span>),</span><br><span class="line">        salt,</span><br><span class="line">        <span class="number">100000</span></span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> secrets.compare_digest(key, stored_key)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="⑥-哈希在工程中的应用"><a href="#⑥-哈希在工程中的应用" class="headerlink" title="⑥ 哈希在工程中的应用"></a>⑥ 哈希在工程中的应用</h2><h3 id="哈希表（HashMap）底层原理"><a href="#哈希表（HashMap）底层原理" class="headerlink" title="哈希表（HashMap）底层原理"></a>哈希表（HashMap）底层原理</h3><p>哈希表是一种<strong>基于哈希函数实现的数据结构</strong>，提供平均  O(1)  的查找、插入、删除操作。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入键 → 哈希函数 → 哈希值 → 取模 → 数组索引 → 存储值</span><br></pre></td></tr></table></figure>

<h4 id="Python-实现示例-1"><a href="#Python-实现示例-1" class="headerlink" title="Python 实现示例"></a>Python 实现示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleHashMap</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity=<span class="number">16</span></span>):</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.buckets = [<span class="literal">None</span>] * capacity</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_hash</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;简单的哈希函数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(key) % self.capacity</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;插入键值对&quot;&quot;&quot;</span></span><br><span class="line">        index = self._<span class="built_in">hash</span>(key)</span><br><span class="line">        <span class="keyword">if</span> self.buckets[index] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.buckets[index] = []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 检查是否已存在</span></span><br><span class="line">        <span class="keyword">for</span> i, (k, v) <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.buckets[index]):</span><br><span class="line">            <span class="keyword">if</span> k == key:</span><br><span class="line">                self.buckets[index][i] = (key, value)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        self.buckets[index].append((key, value))</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取值&quot;&quot;&quot;</span></span><br><span class="line">        index = self._<span class="built_in">hash</span>(key)</span><br><span class="line">        <span class="keyword">if</span> self.buckets[index] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.buckets[index]:</span><br><span class="line">            <span class="keyword">if</span> k == key:</span><br><span class="line">                <span class="keyword">return</span> v</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h3 id="冲突处理：链地址法、开放定址法"><a href="#冲突处理：链地址法、开放定址法" class="headerlink" title="冲突处理：链地址法、开放定址法"></a>冲突处理：链地址法、开放定址法</h3><h4 id="链地址法（Chaining）"><a href="#链地址法（Chaining）" class="headerlink" title="链地址法（Chaining）"></a>链地址法（Chaining）</h4><p>每个桶存储一个<strong>链表</strong>，冲突的元素追加到链表中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChainedHashMap</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity=<span class="number">16</span></span>):</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(capacity)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_hash</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(key) % self.capacity</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        index = self._<span class="built_in">hash</span>(key)</span><br><span class="line">        bucket = self.buckets[index]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 查找是否已存在</span></span><br><span class="line">        <span class="keyword">for</span> i, (k, v) <span class="keyword">in</span> <span class="built_in">enumerate</span>(bucket):</span><br><span class="line">            <span class="keyword">if</span> k == key:</span><br><span class="line">                bucket[i] = (key, value)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        bucket.append((key, value))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key</span>):</span><br><span class="line">        index = self._<span class="built_in">hash</span>(key)</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.buckets[index]:</span><br><span class="line">            <span class="keyword">if</span> k == key:</span><br><span class="line">                <span class="keyword">return</span> v</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>：</p>
<ul>
<li>实现简单</li>
<li>可以存储超过容量的元素</li>
<li>删除操作简单</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>需要额外的指针空间</li>
<li>缓存不友好</li>
</ul>
<h4 id="开放定址法（Open-Addressing）"><a href="#开放定址法（Open-Addressing）" class="headerlink" title="开放定址法（Open Addressing）"></a>开放定址法（Open Addressing）</h4><p>冲突时，在数组中寻找下一个空位置。</p>
<p><strong>线性探测（Linear Probing）</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinearProbingHashMap</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity=<span class="number">16</span></span>):</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.keys = [<span class="literal">None</span>] * capacity</span><br><span class="line">        self.values = [<span class="literal">None</span>] * capacity</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_hash</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(key) % self.capacity</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        index = self._<span class="built_in">hash</span>(key)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 线性探测</span></span><br><span class="line">        <span class="keyword">while</span> self.keys[index] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.keys[index] == key:</span><br><span class="line">                self.values[index] = value</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            index = (index + <span class="number">1</span>) % self.capacity</span><br><span class="line">        </span><br><span class="line">        self.keys[index] = key</span><br><span class="line">        self.values[index] = value</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key</span>):</span><br><span class="line">        index = self._<span class="built_in">hash</span>(key)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> self.keys[index] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.keys[index] == key:</span><br><span class="line">                <span class="keyword">return</span> self.values[index]</span><br><span class="line">            index = (index + <span class="number">1</span>) % self.capacity</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p><strong>二次探测（Quadratic Probing）</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_probe</span>(<span class="params">self, key, i</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;二次探测&quot;&quot;&quot;</span></span><br><span class="line">    index = self._<span class="built_in">hash</span>(key)</span><br><span class="line">    <span class="keyword">return</span> (index + i * i) % self.capacity</span><br></pre></td></tr></table></figure>

<p><strong>双重哈希（Double Hashing）</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_hash2</span>(<span class="params">self, key</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;第二个哈希函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">7</span> - (<span class="built_in">hash</span>(key) % <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_probe</span>(<span class="params">self, key, i</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;双重哈希探测&quot;&quot;&quot;</span></span><br><span class="line">    index = self._<span class="built_in">hash</span>(key)</span><br><span class="line">    <span class="keyword">return</span> (index + i * self._hash2(key)) % self.capacity</span><br></pre></td></tr></table></figure>

<h3 id="负载因子如何影响性能？"><a href="#负载因子如何影响性能？" class="headerlink" title="负载因子如何影响性能？"></a>负载因子如何影响性能？</h3><p><strong>负载因子（Load Factor）</strong>：<br>  \text{负载因子} &#x3D; \frac{\text{元素数量}}{\text{桶数量}}  </p>
<h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><ul>
<li><strong>负载因子 &lt; 0.5</strong>：性能优秀，冲突少</li>
<li><strong>负载因子 0.5-0.75</strong>：性能良好，平衡空间和时间</li>
<li><strong>负载因子 &gt; 0.75</strong>：性能下降，冲突增多</li>
</ul>
<h4 id="动态扩容（Rehashing）"><a href="#动态扩容（Rehashing）" class="headerlink" title="动态扩容（Rehashing）"></a>动态扩容（Rehashing）</h4><p>当负载因子超过阈值时，扩容并重新哈希所有元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicHashMap</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, initial_capacity=<span class="number">16</span>, load_factor=<span class="number">0.75</span></span>):</span><br><span class="line">        self.capacity = initial_capacity</span><br><span class="line">        self.load_factor = load_factor</span><br><span class="line">        self.buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.capacity)]</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_should_resize</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.size &gt; self.capacity * self.load_factor</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_resize</span>(<span class="params">self</span>):</span><br><span class="line">        old_buckets = self.buckets</span><br><span class="line">        self.capacity *= <span class="number">2</span></span><br><span class="line">        self.buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.capacity)]</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 重新插入所有元素</span></span><br><span class="line">        <span class="keyword">for</span> bucket <span class="keyword">in</span> old_buckets:</span><br><span class="line">            <span class="keyword">for</span> key, value <span class="keyword">in</span> bucket:</span><br><span class="line">                self.put(key, value)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="keyword">if</span> self._should_resize():</span><br><span class="line">            self._resize()</span><br><span class="line">        </span><br><span class="line">        index = self._<span class="built_in">hash</span>(key)</span><br><span class="line">        <span class="comment"># ... 插入逻辑</span></span><br></pre></td></tr></table></figure>

<h3 id="一致性哈希（分布式系统）"><a href="#一致性哈希（分布式系统）" class="headerlink" title="一致性哈希（分布式系统）"></a>一致性哈希（分布式系统）</h3><p>一致性哈希用于<strong>分布式系统中的负载均衡</strong>，当节点增减时，最小化数据迁移。</p>
<h4 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h4><p>将哈希值空间组织成一个<strong>环形</strong>，节点和数据都映射到环上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    节点A</span><br><span class="line">      |</span><br><span class="line">      v</span><br><span class="line">0 ----+----&gt; 数据1 (哈希值: 100)</span><br><span class="line">      |</span><br><span class="line">    节点B</span><br><span class="line">      |</span><br><span class="line">      v</span><br><span class="line">180 --+----&gt; 数据2 (哈希值: 200)</span><br><span class="line">      |</span><br><span class="line">    节点C</span><br></pre></td></tr></table></figure>

<p>数据存储在<strong>顺时针方向最近的节点</strong>上。</p>
<h4 id="Python-实现"><a href="#Python-实现" class="headerlink" title="Python 实现"></a>Python 实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConsistentHash</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nodes=<span class="literal">None</span>, replicas=<span class="number">3</span></span>):</span><br><span class="line">        self.replicas = replicas  <span class="comment"># 虚拟节点数量</span></span><br><span class="line">        self.ring = &#123;&#125;</span><br><span class="line">        self.sorted_keys = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> nodes:</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">                self.add_node(node)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_hash</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;计算哈希值&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(hashlib.md5(key.encode()).hexdigest(), <span class="number">16</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_node</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;添加节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.replicas):</span><br><span class="line">            key = self._<span class="built_in">hash</span>(<span class="string">f&quot;<span class="subst">&#123;node&#125;</span>:<span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">            self.ring[key] = node</span><br><span class="line">            bisect.insort(self.sorted_keys, key)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_node</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;移除节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.replicas):</span><br><span class="line">            key = self._<span class="built_in">hash</span>(<span class="string">f&quot;<span class="subst">&#123;node&#125;</span>:<span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">del</span> self.ring[key]</span><br><span class="line">            self.sorted_keys.remove(key)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_node</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取数据应该存储的节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.ring:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        hash_key = self._<span class="built_in">hash</span>(key)</span><br><span class="line">        idx = bisect.bisect_right(self.sorted_keys, hash_key)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> idx == <span class="built_in">len</span>(self.sorted_keys):</span><br><span class="line">            idx = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.ring[self.sorted_keys[idx]]</span><br></pre></td></tr></table></figure>

<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li><strong>分布式缓存</strong>：Redis Cluster、Memcached</li>
<li><strong>负载均衡</strong>：请求路由到合适的服务器</li>
<li><strong>数据分片</strong>：数据库分片、文件存储</li>
</ul>
<h3 id="区块链中的哈希应用（Merkle-树）"><a href="#区块链中的哈希应用（Merkle-树）" class="headerlink" title="区块链中的哈希应用（Merkle 树）"></a>区块链中的哈希应用（Merkle 树）</h3><h4 id="Merkle-树结构"><a href="#Merkle-树结构" class="headerlink" title="Merkle 树结构"></a>Merkle 树结构</h4><p>Merkle 树是一种<strong>二叉树</strong>，叶子节点是数据的哈希值，内部节点是子节点哈希值的哈希。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      Root Hash</span><br><span class="line">       /    \</span><br><span class="line">  Hash(AB)  Hash(CD)</span><br><span class="line">   /  \      /  \</span><br><span class="line"> HashA HashB HashC HashD</span><br><span class="line">  |     |     |     |</span><br><span class="line">Data1 Data2 Data3 Data4</span><br></pre></td></tr></table></figure>

<h4 id="Python-实现-1"><a href="#Python-实现-1" class="headerlink" title="Python 实现"></a>Python 实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MerkleTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.tree = self._build_tree()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_hash</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;计算哈希值&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(data, <span class="built_in">str</span>):</span><br><span class="line">            data = data.encode()</span><br><span class="line">        <span class="keyword">return</span> hashlib.sha256(data).hexdigest()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_build_tree</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;构建Merkle树&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.data) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 叶子节点：数据的哈希值</span></span><br><span class="line">        leaves = [self._<span class="built_in">hash</span>(item) <span class="keyword">for</span> item <span class="keyword">in</span> self.data]</span><br><span class="line">        tree = [leaves]</span><br><span class="line">        </span><br><span class="line">        current_level = leaves</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(current_level) &gt; <span class="number">1</span>:</span><br><span class="line">            next_level = []</span><br><span class="line">            <span class="comment"># 两两配对</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(current_level), <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> i + <span class="number">1</span> &lt; <span class="built_in">len</span>(current_level):</span><br><span class="line">                    combined = current_level[i] + current_level[i + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    combined = current_level[i] + current_level[i]</span><br><span class="line">                next_level.append(self._<span class="built_in">hash</span>(combined))</span><br><span class="line">            tree.append(next_level)</span><br><span class="line">            current_level = next_level</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tree</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_root</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取根哈希&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.tree[-<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">if</span> self.tree <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_proof</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取指定数据的证明路径&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> index &gt;= <span class="built_in">len</span>(self.data):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        proof = []</span><br><span class="line">        current_index = index</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> level <span class="keyword">in</span> self.tree[:-<span class="number">1</span>]:</span><br><span class="line">            sibling_index = current_index ^ <span class="number">1</span>  <span class="comment"># 异或得到兄弟节点索引</span></span><br><span class="line">            <span class="keyword">if</span> sibling_index &lt; <span class="built_in">len</span>(level):</span><br><span class="line">                proof.append(level[sibling_index])</span><br><span class="line">            current_index //= <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> proof</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">self, data, proof, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;验证数据是否在树中&quot;&quot;&quot;</span></span><br><span class="line">        current_hash = self._<span class="built_in">hash</span>(data)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> sibling_hash <span class="keyword">in</span> proof:</span><br><span class="line">            <span class="keyword">if</span> current_hash &lt; sibling_hash:</span><br><span class="line">                combined = current_hash + sibling_hash</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                combined = sibling_hash + current_hash</span><br><span class="line">            current_hash = self._<span class="built_in">hash</span>(combined)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> current_hash == root</span><br></pre></td></tr></table></figure>

<h4 id="区块链中的应用"><a href="#区块链中的应用" class="headerlink" title="区块链中的应用"></a>区块链中的应用</h4><ol>
<li><p><strong>区块结构</strong>：</p>
<ul>
<li>每个区块包含多个交易</li>
<li>所有交易的哈希值构成 Merkle 树的叶子节点</li>
<li>根哈希存储在区块头中</li>
<li>修改任何交易都会导致根哈希变化</li>
</ul>
</li>
<li><p><strong>快速验证</strong>：</p>
<ul>
<li>不需要下载整个区块链，只需验证 Merkle 证明</li>
<li>SPV（Simplified Payment Verification）节点使用 Merkle 证明验证交易</li>
</ul>
</li>
<li><p><strong>数据完整性</strong>：</p>
<ul>
<li>任何数据的修改都会导致根哈希变化</li>
<li>保证区块链的不可篡改性</li>
</ul>
</li>
</ol>
<hr>
<h2 id="⑦-感知哈希（Perceptual-Hash）"><a href="#⑦-感知哈希（Perceptual-Hash）" class="headerlink" title="⑦ 感知哈希（Perceptual Hash）"></a>⑦ 感知哈希（Perceptual Hash）</h2><h3 id="感知哈希与密码学哈希的根本区别"><a href="#感知哈希与密码学哈希的根本区别" class="headerlink" title="感知哈希与密码学哈希的根本区别"></a>感知哈希与密码学哈希的根本区别</h3><p><strong>密码学哈希</strong>（如 SHA-256）：</p>
<ul>
<li>✅ <strong>雪崩效应</strong>：输入微小变化 → 输出完全不同</li>
<li>✅ <strong>不可逆性</strong>：无法从哈希值反推原始数据</li>
<li>✅ <strong>抗碰撞性</strong>：难以找到两个不同输入产生相同输出</li>
</ul>
<p><strong>感知哈希</strong>（Perceptual Hash）：</p>
<ul>
<li>✅ <strong>相似性保持</strong>：相似输入 → 相似输出</li>
<li>✅ <strong>抗变换性</strong>：对缩放、旋转、压缩等变换不敏感</li>
<li>✅ <strong>快速计算</strong>：比密码学哈希快得多</li>
</ul>
<h3 id="pHash（Perceptual-Hash）算法原理"><a href="#pHash（Perceptual-Hash）算法原理" class="headerlink" title="pHash（Perceptual Hash）算法原理"></a>pHash（Perceptual Hash）算法原理</h3><p>pHash 使用<strong>离散余弦变换（DCT）</strong>提取图像的频率特征。</p>
<h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol>
<li><strong>缩小图像</strong>：将图像缩小到 32×32 像素</li>
<li><strong>转换为灰度图</strong>：RGB → 灰度</li>
<li><strong>DCT 变换</strong>：计算离散余弦变换</li>
<li><strong>提取低频分量</strong>：取左上角 8×8 的低频系数</li>
<li><strong>计算平均值</strong>：计算这64个系数的平均值</li>
<li><strong>生成哈希</strong>：大于平均值的为1，否则为0</li>
</ol>
<h4 id="Python-实现-2"><a href="#Python-实现-2" class="headerlink" title="Python 实现"></a>Python 实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.fftpack <span class="keyword">import</span> dct</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">phash</span>(<span class="params">image_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算图像的感知哈希值&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 读取并缩小图像</span></span><br><span class="line">    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    img = cv2.resize(img, (<span class="number">32</span>, <span class="number">32</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. DCT变换</span></span><br><span class="line">    dct_coeffs = dct(dct(img, axis=<span class="number">0</span>), axis=<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 提取左上角8x8的低频系数</span></span><br><span class="line">    low_freq = dct_coeffs[:<span class="number">8</span>, :<span class="number">8</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 4. 计算平均值</span></span><br><span class="line">    avg = np.mean(low_freq)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 5. 生成哈希（大于平均值为1，否则为0）</span></span><br><span class="line">    hash_bits = (low_freq &gt; avg).flatten()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 6. 转换为64位整数</span></span><br><span class="line">    hash_value = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> bit <span class="keyword">in</span> hash_bits:</span><br><span class="line">        hash_value = (hash_value &lt;&lt; <span class="number">1</span>) | <span class="built_in">int</span>(bit)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> hash_value</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hamming_distance</span>(<span class="params">hash1, hash2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算两个哈希值的汉明距离&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bin</span>(hash1 ^ hash2).count(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">hash1 = phash(<span class="string">&#x27;image1.jpg&#x27;</span>)</span><br><span class="line">hash2 = phash(<span class="string">&#x27;image2.jpg&#x27;</span>)</span><br><span class="line">distance = hamming_distance(hash1, hash2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;汉明距离: <span class="subst">&#123;distance&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 距离越小，图像越相似（通常 &lt; 10 表示相似）</span></span><br></pre></td></tr></table></figure>

<h3 id="dHash（Difference-Hash）算法"><a href="#dHash（Difference-Hash）算法" class="headerlink" title="dHash（Difference Hash）算法"></a>dHash（Difference Hash）算法</h3><p>dHash 通过比较相邻像素的差异来生成哈希。</p>
<h4 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol>
<li><strong>缩小图像</strong>：缩小到 9×8 像素（宽度9，高度8）</li>
<li><strong>转换为灰度图</strong></li>
<li><strong>计算差异</strong>：比较每一行相邻像素</li>
<li><strong>生成哈希</strong>：左边像素 &gt; 右边像素为1，否则为0</li>
</ol>
<h4 id="Python-实现-3"><a href="#Python-实现-3" class="headerlink" title="Python 实现"></a>Python 实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dhash</span>(<span class="params">image_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算图像的差异哈希值&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 读取并缩小图像（9x8，宽度9用于计算8个差异）</span></span><br><span class="line">    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    img = cv2.resize(img, (<span class="number">9</span>, <span class="number">8</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 计算每行相邻像素的差异</span></span><br><span class="line">    hash_bits = []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> img:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            hash_bits.append(row[i] &gt; row[i + <span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 转换为64位整数</span></span><br><span class="line">    hash_value = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> bit <span class="keyword">in</span> hash_bits:</span><br><span class="line">        hash_value = (hash_value &lt;&lt; <span class="number">1</span>) | <span class="built_in">int</span>(bit)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> hash_value</span><br></pre></td></tr></table></figure>

<h3 id="aHash（Average-Hash）算法"><a href="#aHash（Average-Hash）算法" class="headerlink" title="aHash（Average Hash）算法"></a>aHash（Average Hash）算法</h3><p>aHash 是最简单的感知哈希算法，基于像素平均值。</p>
<h4 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol>
<li><strong>缩小图像</strong>：缩小到 8×8 像素</li>
<li><strong>转换为灰度图</strong></li>
<li><strong>计算平均值</strong>：计算所有64个像素的平均值</li>
<li><strong>生成哈希</strong>：大于平均值的为1，否则为0</li>
</ol>
<h4 id="Python-实现-4"><a href="#Python-实现-4" class="headerlink" title="Python 实现"></a>Python 实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ahash</span>(<span class="params">image_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算图像的平均哈希值&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 读取并缩小图像</span></span><br><span class="line">    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    img = cv2.resize(img, (<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 计算平均值</span></span><br><span class="line">    avg = np.mean(img)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 生成哈希</span></span><br><span class="line">    hash_bits = (img &gt; avg).flatten()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 4. 转换为64位整数</span></span><br><span class="line">    hash_value = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> bit <span class="keyword">in</span> hash_bits:</span><br><span class="line">        hash_value = (hash_value &lt;&lt; <span class="number">1</span>) | <span class="built_in">int</span>(bit)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> hash_value</span><br></pre></td></tr></table></figure>

<h3 id="wHash（Wavelet-Hash）算法"><a href="#wHash（Wavelet-Hash）算法" class="headerlink" title="wHash（Wavelet Hash）算法"></a>wHash（Wavelet Hash）算法</h3><p>wHash 使用<strong>小波变换</strong>提取图像特征，对旋转和缩放更鲁棒。</p>
<h4 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol>
<li><strong>小波变换</strong>：对图像进行小波分解</li>
<li><strong>提取低频分量</strong>：使用低频子带</li>
<li><strong>生成哈希</strong>：基于低频系数生成哈希值</li>
</ol>
<h3 id="算法对比"><a href="#算法对比" class="headerlink" title="算法对比"></a>算法对比</h3><table>
<thead>
<tr>
<th>算法</th>
<th>速度</th>
<th>精度</th>
<th>抗旋转</th>
<th>抗缩放</th>
<th>抗压缩</th>
</tr>
</thead>
<tbody><tr>
<td>aHash</td>
<td>⭐⭐⭐⭐⭐</td>
<td>⭐⭐⭐</td>
<td>⭐⭐</td>
<td>⭐⭐⭐</td>
<td>⭐⭐⭐</td>
</tr>
<tr>
<td>dHash</td>
<td>⭐⭐⭐⭐</td>
<td>⭐⭐⭐⭐</td>
<td>⭐⭐</td>
<td>⭐⭐⭐</td>
<td>⭐⭐⭐</td>
</tr>
<tr>
<td>pHash</td>
<td>⭐⭐⭐</td>
<td>⭐⭐⭐⭐⭐</td>
<td>⭐⭐⭐⭐</td>
<td>⭐⭐⭐⭐</td>
<td>⭐⭐⭐⭐</td>
</tr>
<tr>
<td>wHash</td>
<td>⭐⭐</td>
<td>⭐⭐⭐⭐⭐</td>
<td>⭐⭐⭐⭐⭐</td>
<td>⭐⭐⭐⭐⭐</td>
<td>⭐⭐⭐⭐</td>
</tr>
</tbody></table>
<h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li><strong>图像去重</strong>：检测重复或相似的图片</li>
<li><strong>版权保护</strong>：识别盗版或修改后的图片</li>
<li><strong>相似图片搜索</strong>：基于内容的图像检索</li>
<li><strong>内容审核</strong>：检测相似的不当内容</li>
</ol>
<hr>
<h2 id="⑧-其他特殊用途哈希"><a href="#⑧-其他特殊用途哈希" class="headerlink" title="⑧ 其他特殊用途哈希"></a>⑧ 其他特殊用途哈希</h2><h3 id="局部敏感哈希（LSH-Locality-Sensitive-Hashing）"><a href="#局部敏感哈希（LSH-Locality-Sensitive-Hashing）" class="headerlink" title="局部敏感哈希（LSH - Locality Sensitive Hashing）"></a>局部敏感哈希（LSH - Locality Sensitive Hashing）</h3><p>LSH 是一种<strong>相似性保持哈希</strong>，用于高维数据的快速相似性搜索。</p>
<h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p><strong>传统哈希</strong>：相似输入 → 不同输出（雪崩效应）<br><strong>LSH</strong>：相似输入 → 相同或相似输出（以高概率）</p>
<h4 id="数学定义"><a href="#数学定义" class="headerlink" title="数学定义"></a>数学定义</h4><p>对于距离度量  d ，哈希函数族  \mathcal{H}  是  (r_1, r_2, p_1, p_2) -敏感的，如果：</p>
<ul>
<li>如果  d(x, y) \leq r_1 ，则  P[h(x) &#x3D; h(y)] \geq p_1 </li>
<li>如果  d(x, y) \geq r_2 ，则  P[h(x) &#x3D; h(y)] \leq p_2</li>
</ul>
<p>其中  p_1 &gt; p_2 ， r_1 &lt; r_2 。</p>
<h4 id="MinHash-算法（用于集合相似性）"><a href="#MinHash-算法（用于集合相似性）" class="headerlink" title="MinHash 算法（用于集合相似性）"></a>MinHash 算法（用于集合相似性）</h4><p>MinHash 用于计算<strong>Jaccard 相似度</strong>。</p>
<p>  J(A, B) &#x3D; \frac{|A \cap B|}{|A \cup B|}  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinHash</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_perm=<span class="number">128</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化MinHash</span></span><br><span class="line"><span class="string">        num_perm: 排列函数的数量</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.num_perm = num_perm</span><br><span class="line">        <span class="comment"># 生成随机排列函数</span></span><br><span class="line">        self.permutations = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_perm):</span><br><span class="line">            random.seed(i)</span><br><span class="line">            self.permutations.append(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10000</span>)))</span><br><span class="line">            random.shuffle(self.permutations[-<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash_set</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;计算集合的MinHash签名&quot;&quot;&quot;</span></span><br><span class="line">        signature = []</span><br><span class="line">        <span class="keyword">for</span> perm <span class="keyword">in</span> self.permutations:</span><br><span class="line">            min_hash = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> element <span class="keyword">in</span> s:</span><br><span class="line">                <span class="comment"># 使用排列函数计算哈希值</span></span><br><span class="line">                hash_val = perm[<span class="built_in">hash</span>(element) % <span class="built_in">len</span>(perm)]</span><br><span class="line">                min_hash = <span class="built_in">min</span>(min_hash, hash_val)</span><br><span class="line">            signature.append(min_hash)</span><br><span class="line">        <span class="keyword">return</span> signature</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">similarity</span>(<span class="params">self, sig1, sig2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;计算两个签名的相似度&quot;&quot;&quot;</span></span><br><span class="line">        matches = <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(sig1, sig2) <span class="keyword">if</span> a == b)</span><br><span class="line">        <span class="keyword">return</span> matches / self.num_perm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">mh = MinHash()</span><br><span class="line">set1 = &#123;<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>&#125;</span><br><span class="line">set2 = &#123;<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;grape&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">sig1 = mh.hash_set(set1)</span><br><span class="line">sig2 = mh.hash_set(set2)</span><br><span class="line">similarity = mh.similarity(sig1, sig2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;集合相似度: <span class="subst">&#123;similarity:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li><strong>向量数据库</strong>：Milvus、Pinecone 等使用 LSH 加速相似性搜索</li>
<li><strong>推荐系统</strong>：快速找到相似用户或物品</li>
<li><strong>文档去重</strong>：检测相似的文档</li>
</ul>
<h3 id="滚动哈希（Rolling-Hash）在字符串匹配中的应用"><a href="#滚动哈希（Rolling-Hash）在字符串匹配中的应用" class="headerlink" title="滚动哈希（Rolling Hash）在字符串匹配中的应用"></a>滚动哈希（Rolling Hash）在字符串匹配中的应用</h3><p>滚动哈希允许在**O(1)**时间内更新哈希值，当窗口滑动时。</p>
<h4 id="Rabin-Karp-算法"><a href="#Rabin-Karp-算法" class="headerlink" title="Rabin-Karp 算法"></a>Rabin-Karp 算法</h4><p>用于在文本中查找模式字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RollingHash</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, base=<span class="number">256</span>, mod=<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化滚动哈希</span></span><br><span class="line"><span class="string">        base: 基数（通常选择256，因为ASCII字符范围）</span></span><br><span class="line"><span class="string">        mod: 模数（大质数）</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.base = base</span><br><span class="line">        self.mod = mod</span><br><span class="line">        self.power = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash_string</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;计算字符串的哈希值&quot;&quot;&quot;</span></span><br><span class="line">        hash_val = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">            hash_val = (hash_val * self.base + <span class="built_in">ord</span>(char)) % self.mod</span><br><span class="line">        <span class="keyword">return</span> hash_val</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">roll_hash</span>(<span class="params">self, old_hash, old_char, new_char, length</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;滚动更新哈希值</span></span><br><span class="line"><span class="string">        old_hash: 旧哈希值</span></span><br><span class="line"><span class="string">        old_char: 移出的字符</span></span><br><span class="line"><span class="string">        new_char: 新加入的字符</span></span><br><span class="line"><span class="string">        length: 窗口长度</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 计算 base^(length-1) mod mod</span></span><br><span class="line">        power = <span class="built_in">pow</span>(self.base, length - <span class="number">1</span>, self.mod)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 移除旧字符的贡献</span></span><br><span class="line">        hash_val = (old_hash - <span class="built_in">ord</span>(old_char) * power) % self.mod</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 添加新字符</span></span><br><span class="line">        hash_val = (hash_val * self.base + <span class="built_in">ord</span>(new_char)) % self.mod</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> hash_val</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rabin_karp</span>(<span class="params">text, pattern</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用Rabin-Karp算法查找模式&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pattern) &gt; <span class="built_in">len</span>(text):</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    rh = RollingHash()</span><br><span class="line">    pattern_hash = rh.hash_string(pattern)</span><br><span class="line">    text_hash = rh.hash_string(text[:<span class="built_in">len</span>(pattern)])</span><br><span class="line">    </span><br><span class="line">    results = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查第一个窗口</span></span><br><span class="line">    <span class="keyword">if</span> text_hash == pattern_hash <span class="keyword">and</span> text[:<span class="built_in">len</span>(pattern)] == pattern:</span><br><span class="line">        results.append(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 滚动窗口</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(pattern), <span class="built_in">len</span>(text)):</span><br><span class="line">        text_hash = rh.roll_hash(</span><br><span class="line">            text_hash, </span><br><span class="line">            text[i - <span class="built_in">len</span>(pattern)], </span><br><span class="line">            text[i], </span><br><span class="line">            <span class="built_in">len</span>(pattern)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> text_hash == pattern_hash:</span><br><span class="line">            <span class="comment"># 哈希匹配，需要验证（避免哈希冲突）</span></span><br><span class="line">            <span class="keyword">if</span> text[i - <span class="built_in">len</span>(pattern) + <span class="number">1</span>:i + <span class="number">1</span>] == pattern:</span><br><span class="line">                results.append(i - <span class="built_in">len</span>(pattern) + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">text = <span class="string">&quot;abracadabra&quot;</span></span><br><span class="line">pattern = <span class="string">&quot;abra&quot;</span></span><br><span class="line">matches = rabin_karp(text, pattern)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;匹配位置: <span class="subst">&#123;matches&#125;</span>&quot;</span>)  <span class="comment"># [0, 7]</span></span><br></pre></td></tr></table></figure>

<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li><strong>预处理</strong>：O(m)，m 为模式长度</li>
<li><strong>搜索</strong>：平均 O(n + m)，最坏 O(nm)，n 为文本长度</li>
<li><strong>空间复杂度</strong>：O(1)</li>
</ul>
<h3 id="校验和（Checksum）算法"><a href="#校验和（Checksum）算法" class="headerlink" title="校验和（Checksum）算法"></a>校验和（Checksum）算法</h3><p>校验和用于检测数据传输或存储中的错误。</p>
<h4 id="简单校验和"><a href="#简单校验和" class="headerlink" title="简单校验和"></a>简单校验和</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">simple_checksum</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;简单校验和：所有字节相加&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(data, <span class="built_in">str</span>):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(data) % <span class="number">256</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">data = <span class="string">b&quot;Hello, World!&quot;</span></span><br><span class="line">checksum = simple_checksum(data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;校验和: <span class="subst">&#123;checksum&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Fletcher-校验和"><a href="#Fletcher-校验和" class="headerlink" title="Fletcher 校验和"></a>Fletcher 校验和</h4><p>Fletcher 校验和使用两个累加器，提供更好的错误检测能力。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fletcher_checksum</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Fletcher校验和算法&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(data, <span class="built_in">str</span>):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    </span><br><span class="line">    sum1 = <span class="number">0</span></span><br><span class="line">    sum2 = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> byte <span class="keyword">in</span> data:</span><br><span class="line">        sum1 = (sum1 + byte) % <span class="number">255</span></span><br><span class="line">        sum2 = (sum2 + sum1) % <span class="number">255</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (sum2 &lt;&lt; <span class="number">8</span>) | sum1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">data = <span class="string">b&quot;Hello, World!&quot;</span></span><br><span class="line">checksum = fletcher_checksum(data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Fletcher校验和: <span class="subst">&#123;<span class="built_in">hex</span>(checksum)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="循环冗余校验（CRC）"><a href="#循环冗余校验（CRC）" class="headerlink" title="循环冗余校验（CRC）"></a>循环冗余校验（CRC）</h3><p>CRC 使用<strong>多项式除法</strong>计算校验值，广泛用于网络通信和存储系统。</p>
<h4 id="CRC-32-算法"><a href="#CRC-32-算法" class="headerlink" title="CRC-32 算法"></a>CRC-32 算法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">crc32</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算CRC-32校验值&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">import</span> zlib</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(data, <span class="built_in">str</span>):</span><br><span class="line">        data = data.encode()</span><br><span class="line">    <span class="keyword">return</span> zlib.crc32(data) &amp; <span class="number">0xffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">data = <span class="string">b&quot;Hello, World!&quot;</span></span><br><span class="line">crc = crc32(data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;CRC-32: <span class="subst">&#123;<span class="built_in">hex</span>(crc)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="CRC-多项式"><a href="#CRC-多项式" class="headerlink" title="CRC 多项式"></a>CRC 多项式</h4><p>常见的 CRC 多项式：</p>
<ul>
<li><strong>CRC-8</strong>： x^8 + x^2 + x + 1 </li>
<li><strong>CRC-16</strong>： x^{16} + x^{15} + x^2 + 1 </li>
<li><strong>CRC-32</strong>： x^{32} + x^{26} + x^{23} + x^{22} + x^{16} + x^{12} + x^{11} + x^{10} + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1</li>
</ul>
<h3 id="布隆过滤器（Bloom-Filter）中的多哈希函数"><a href="#布隆过滤器（Bloom-Filter）中的多哈希函数" class="headerlink" title="布隆过滤器（Bloom Filter）中的多哈希函数"></a>布隆过滤器（Bloom Filter）中的多哈希函数</h3><p>布隆过滤器使用<strong>多个哈希函数</strong>来减少误判率。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ol>
<li>使用  k  个不同的哈希函数</li>
<li>每个元素映射到  k  个位置</li>
<li>查询时检查所有  k  个位置是否都为1</li>
</ol>
<h4 id="误判率计算"><a href="#误判率计算" class="headerlink" title="误判率计算"></a>误判率计算</h4><p>  P_{false} &#x3D; \left(1 - \left(1 - \frac{1}{m}\right)^{kn}\right)^k \approx \left(1 - e^{-\frac{kn}{m}}\right)^k  </p>
<p>其中：</p>
<ul>
<li>m ：位数组大小</li>
<li>k ：哈希函数数量</li>
<li>n ：元素数量</li>
</ul>
<p>最优哈希函数数量：</p>
<p>  k &#x3D; \frac{m}{n} \ln 2  </p>
<h4 id="Python-实现-5"><a href="#Python-实现-5" class="headerlink" title="Python 实现"></a>Python 实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> mmh3  <span class="comment"># MurmurHash3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BloomFilter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity, error_rate=<span class="number">0.01</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化布隆过滤器</span></span><br><span class="line"><span class="string">        capacity: 预期元素数量</span></span><br><span class="line"><span class="string">        error_rate: 目标误判率</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">import</span> math</span><br><span class="line">        <span class="comment"># 计算最优位数组大小</span></span><br><span class="line">        self.m = <span class="built_in">int</span>(-capacity * math.log(error_rate) / (math.log(<span class="number">2</span>) ** <span class="number">2</span>))</span><br><span class="line">        <span class="comment"># 计算最优哈希函数数量</span></span><br><span class="line">        self.k = <span class="built_in">int</span>(self.m * math.log(<span class="number">2</span>) / capacity)</span><br><span class="line">        </span><br><span class="line">        self.bit_array = [<span class="number">0</span>] * self.m</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_hash</span>(<span class="params">self, item, seed</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;使用不同种子计算哈希值&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(item, <span class="built_in">str</span>):</span><br><span class="line">            item = item.encode()</span><br><span class="line">        <span class="comment"># 使用MurmurHash3</span></span><br><span class="line">        <span class="keyword">return</span> mmh3.<span class="built_in">hash</span>(item, seed) % self.m</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;添加元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.k):</span><br><span class="line">            index = self._<span class="built_in">hash</span>(item, i)</span><br><span class="line">            self.bit_array[index] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">contains</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;检查元素是否存在&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.k):</span><br><span class="line">            index = self._<span class="built_in">hash</span>(item, i)</span><br><span class="line">            <span class="keyword">if</span> self.bit_array[index] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 肯定不存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 可能存在（可能有误判）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">bf = BloomFilter(capacity=<span class="number">1000</span>, error_rate=<span class="number">0.01</span>)</span><br><span class="line">bf.add(<span class="string">&quot;apple&quot;</span>)</span><br><span class="line">bf.add(<span class="string">&quot;banana&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bf.contains(<span class="string">&quot;apple&quot;</span>))    <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(bf.contains(<span class="string">&quot;orange&quot;</span>))   <span class="comment"># False（可能误判）</span></span><br></pre></td></tr></table></figure>

<h3 id="特征哈希（Feature-Hashing）在机器学习中的应用"><a href="#特征哈希（Feature-Hashing）在机器学习中的应用" class="headerlink" title="特征哈希（Feature Hashing）在机器学习中的应用"></a>特征哈希（Feature Hashing）在机器学习中的应用</h3><p>特征哈希用于将<strong>高维稀疏特征</strong>映射到固定维度的向量空间。</p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol>
<li><strong>内存效率</strong>：不需要存储特征字典</li>
<li><strong>在线学习</strong>：可以处理新特征</li>
<li><strong>维度固定</strong>：输出维度预先确定</li>
</ol>
<h4 id="Python-实现-6"><a href="#Python-实现-6" class="headerlink" title="Python 实现"></a>Python 实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FeatureHasher</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n_features=<span class="number">1000</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化特征哈希器</span></span><br><span class="line"><span class="string">        n_features: 输出特征维度</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.n_features = n_features</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transform</span>(<span class="params">self, features</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;将特征字典转换为固定维度向量&quot;&quot;&quot;</span></span><br><span class="line">        vector = [<span class="number">0.0</span>] * self.n_features</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> feature_name, value <span class="keyword">in</span> features.items():</span><br><span class="line">            <span class="comment"># 计算特征名的哈希值</span></span><br><span class="line">            hash_val = <span class="built_in">int</span>(hashlib.md5(</span><br><span class="line">                <span class="built_in">str</span>(feature_name).encode()</span><br><span class="line">            ).hexdigest(), <span class="number">16</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 映射到特征空间</span></span><br><span class="line">            index = hash_val % self.n_features</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 累加特征值</span></span><br><span class="line">            vector[index] += value</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> vector</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">hasher = FeatureHasher(n_features=<span class="number">10</span>)</span><br><span class="line">features = &#123;</span><br><span class="line">    <span class="string">&#x27;user_age&#x27;</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="string">&#x27;user_city_beijing&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;item_category_electronics&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;item_price&#x27;</span>: <span class="number">99.99</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector = hasher.transform(features)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;特征向量: <span class="subst">&#123;vector&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="哈希冲突处理"><a href="#哈希冲突处理" class="headerlink" title="哈希冲突处理"></a>哈希冲突处理</h4><p>特征哈希可能发生冲突（不同特征映射到同一位置），但通常影响不大：</p>
<ul>
<li><strong>冲突概率</strong>：当  n_{features} \gg n_{distinct_features}  时，冲突概率很低</li>
<li><strong>影响</strong>：冲突会导致特征值累加，但通常不会显著影响模型性能</li>
</ul>
<hr>
<h2 id="⑨-动手实现简化版哈希算法"><a href="#⑨-动手实现简化版哈希算法" class="headerlink" title="⑨ 动手实现简化版哈希算法"></a>⑨ 动手实现简化版哈希算法</h2><p>让我们实现一个<strong>教育用途</strong>的简化哈希函数，帮助你理解哈希算法的核心原理。</p>
<h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><p>我们的简化哈希函数应该具备：</p>
<ol>
<li>✅ <strong>固定长度输出</strong>：输出固定位数的哈希值</li>
<li>✅ <strong>雪崩效应</strong>：输入微小变化导致输出大幅变化</li>
<li>✅ <strong>快速计算</strong>：简单高效</li>
<li>⚠️ <strong>不用于生产</strong>：仅用于教育，不提供密码学安全性</li>
</ol>
<h3 id="位运算基础"><a href="#位运算基础" class="headerlink" title="位运算基础"></a>位运算基础</h3><p>在实现之前，我们需要掌握基本的位运算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 位运算操作</span></span><br><span class="line">a = <span class="number">0b1010</span>  <span class="comment"># 10</span></span><br><span class="line">b = <span class="number">0b1100</span>  <span class="comment"># 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按位与</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(a &amp; b))  <span class="comment"># 0b1000 (8)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按位或</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(a | b))  <span class="comment"># 0b1110 (14)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按位异或</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(a ^ b))  <span class="comment"># 0b0110 (6)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 左移</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(a &lt;&lt; <span class="number">2</span>))  <span class="comment"># 0b101000 (40)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 右移</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(a &gt;&gt; <span class="number">1</span>))  <span class="comment"># 0b0101 (5)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环左移</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rotl</span>(<span class="params">x, n, bits=<span class="number">32</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;循环左移&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> ((x &lt;&lt; n) | (x &gt;&gt; (bits - n))) &amp; ((<span class="number">1</span> &lt;&lt; bits) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="简化哈希函数实现"><a href="#简化哈希函数实现" class="headerlink" title="简化哈希函数实现"></a>简化哈希函数实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleHash</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;简化版哈希函数（教育用途）&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, output_bits=<span class="number">32</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化</span></span><br><span class="line"><span class="string">        output_bits: 输出位数（32或64）</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.output_bits = output_bits</span><br><span class="line">        self.output_bytes = output_bits // <span class="number">8</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_mix</span>(<span class="params">self, a, b, c</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;混合函数：使用位运算混合三个值&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 使用类似MD5的混合操作</span></span><br><span class="line">        a ^= b</span><br><span class="line">        a = ((a &lt;&lt; <span class="number">16</span>) | (a &gt;&gt; <span class="number">16</span>)) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">        a += c</span><br><span class="line">        a &amp;= <span class="number">0xFFFFFFFF</span></span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_process_block</span>(<span class="params">self, block, state</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;处理一个数据块&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 将块分成4个32位字</span></span><br><span class="line">        words = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(block), <span class="number">4</span>):</span><br><span class="line">            word = <span class="built_in">int</span>.from_bytes(</span><br><span class="line">                block[i:i+<span class="number">4</span>] + <span class="string">b&#x27;\x00&#x27;</span> * (<span class="number">4</span> - <span class="built_in">len</span>(block[i:i+<span class="number">4</span>])), </span><br><span class="line">                <span class="string">&#x27;little&#x27;</span></span><br><span class="line">            )</span><br><span class="line">            words.append(word &amp; <span class="number">0xFFFFFFFF</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 确保有4个字</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(words) &lt; <span class="number">4</span>:</span><br><span class="line">            words.append(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 多轮混合</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):  <span class="comment"># 4轮</span></span><br><span class="line">            state[<span class="number">0</span>] = self._mix(state[<span class="number">0</span>], words[<span class="number">0</span>], state[<span class="number">1</span>])</span><br><span class="line">            state[<span class="number">1</span>] = self._mix(state[<span class="number">1</span>], words[<span class="number">1</span>], state[<span class="number">2</span>])</span><br><span class="line">            state[<span class="number">2</span>] = self._mix(state[<span class="number">2</span>], words[<span class="number">2</span>], state[<span class="number">3</span>])</span><br><span class="line">            state[<span class="number">3</span>] = self._mix(state[<span class="number">3</span>], words[<span class="number">3</span>], state[<span class="number">0</span>])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 循环移位增加扩散</span></span><br><span class="line">            words[<span class="number">0</span>] = ((words[<span class="number">0</span>] &lt;&lt; <span class="number">1</span>) | (words[<span class="number">0</span>] &gt;&gt; <span class="number">31</span>)) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;计算哈希值&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(data, <span class="built_in">str</span>):</span><br><span class="line">            data = data.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 初始化状态（类似MD5的初始值）</span></span><br><span class="line">        state = [<span class="number">0x67452301</span>, <span class="number">0xEFCDAB89</span>, <span class="number">0x98BADCFE</span>, <span class="number">0x10325476</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 填充数据（简化版：填充到64字节的倍数）</span></span><br><span class="line">        original_length = <span class="built_in">len</span>(data)</span><br><span class="line">        padding_length = (<span class="number">64</span> - (original_length % <span class="number">64</span>)) % <span class="number">64</span></span><br><span class="line">        <span class="keyword">if</span> padding_length == <span class="number">0</span>:</span><br><span class="line">            padding_length = <span class="number">64</span></span><br><span class="line">        </span><br><span class="line">        padded_data = data + <span class="string">b&#x27;\x80&#x27;</span> + <span class="string">b&#x27;\x00&#x27;</span> * (padding_length - <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 添加长度信息（最后8字节）</span></span><br><span class="line">        length_bytes = original_length.to_bytes(<span class="number">8</span>, <span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">        padded_data = padded_data[:-<span class="number">8</span>] + length_bytes</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 处理每个64字节块</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(padded_data), <span class="number">64</span>):</span><br><span class="line">            block = padded_data[i:i+<span class="number">64</span>]</span><br><span class="line">            state = self._process_block(block, state)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 组合最终哈希值</span></span><br><span class="line">        <span class="keyword">if</span> self.output_bits == <span class="number">32</span>:</span><br><span class="line">            result = state[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 64位</span></span><br><span class="line">            result = (state[<span class="number">0</span>] &lt;&lt; <span class="number">32</span>) | state[<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">format</span>(result, <span class="string">f&#x27;0<span class="subst">&#123;self.output_bytes * <span class="number">2</span>&#125;</span>x&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">hasher = SimpleHash(output_bits=<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试雪崩效应</span></span><br><span class="line">data1 = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">data2 = <span class="string">&quot;Hello, World?&quot;</span>  <span class="comment"># 只改了一个字符</span></span><br><span class="line"></span><br><span class="line">hash1 = hasher.<span class="built_in">hash</span>(data1)</span><br><span class="line">hash2 = hasher.<span class="built_in">hash</span>(data2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;输入1: <span class="subst">&#123;data1&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;哈希1: <span class="subst">&#123;hash1&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;输入2: <span class="subst">&#123;data2&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;哈希2: <span class="subst">&#123;hash2&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;差异: <span class="subst">&#123;<span class="built_in">bin</span>(<span class="built_in">int</span>(hash1, <span class="number">16</span>) ^ <span class="built_in">int</span>(hash2, <span class="number">16</span>)).count(<span class="string">&#x27;1&#x27;</span>)&#125;</span> 位不同&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="增强扩散性的技巧"><a href="#增强扩散性的技巧" class="headerlink" title="增强扩散性的技巧"></a>增强扩散性的技巧</h3><h4 id="1-使用S-Box（替换盒）"><a href="#1-使用S-Box（替换盒）" class="headerlink" title="1. 使用S-Box（替换盒）"></a>1. 使用S-Box（替换盒）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简化的S-Box（实际算法使用更复杂的查找表）</span></span><br><span class="line">S_BOX = [</span><br><span class="line">    <span class="number">0x63</span>, <span class="number">0x7c</span>, <span class="number">0x77</span>, <span class="number">0x7b</span>, <span class="number">0xf2</span>, <span class="number">0x6b</span>, <span class="number">0x6f</span>, <span class="number">0xc5</span>,</span><br><span class="line">    <span class="number">0x30</span>, <span class="number">0x01</span>, <span class="number">0x67</span>, <span class="number">0x2b</span>, <span class="number">0xfe</span>, <span class="number">0xd7</span>, <span class="number">0xab</span>, <span class="number">0x76</span>,</span><br><span class="line">    <span class="comment"># ... 更多值</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">apply_sbox</span>(<span class="params">value</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;应用S-Box替换&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> S_BOX[value &amp; <span class="number">0xFF</span>]</span><br></pre></td></tr></table></figure>

<h4 id="2-非线性函数"><a href="#2-非线性函数" class="headerlink" title="2. 非线性函数"></a>2. 非线性函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">non_linear_mix</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;非线性混合函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># F(x, y, z) = (x &amp; y) | (~x &amp; z)  (类似MD5的F函数)</span></span><br><span class="line">    <span class="keyword">return</span> (a &amp; b) | ((~a) &amp; c) &amp; <span class="number">0xFFFFFFFF</span></span><br></pre></td></tr></table></figure>

<h4 id="3-轮函数设计"><a href="#3-轮函数设计" class="headerlink" title="3. 轮函数设计"></a>3. 轮函数设计</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">round_function</span>(<span class="params">state, round_key</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;轮函数：每轮处理&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 替换（S-Box）</span></span><br><span class="line">    state = [apply_sbox(x) <span class="keyword">for</span> x <span class="keyword">in</span> state]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 置换（行移位）</span></span><br><span class="line">    state[<span class="number">1</span>] = ((state[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>) | (state[<span class="number">1</span>] &gt;&gt; <span class="number">24</span>)) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 混合（列混合）</span></span><br><span class="line">    state[<span class="number">0</span>] ^= state[<span class="number">1</span>]</span><br><span class="line">    state[<span class="number">2</span>] ^= state[<span class="number">3</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 4. 轮密钥加</span></span><br><span class="line">    state[<span class="number">0</span>] ^= round_key</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> state</span><br></pre></td></tr></table></figure>

<h3 id="为什么好的哈希设计这么复杂？"><a href="#为什么好的哈希设计这么复杂？" class="headerlink" title="为什么好的哈希设计这么复杂？"></a>为什么好的哈希设计这么复杂？</h3><ol>
<li><p><strong>安全性要求</strong>：</p>
<ul>
<li>需要抵抗各种攻击（碰撞攻击、原像攻击等）</li>
<li>需要经过密码学分析</li>
</ul>
</li>
<li><p><strong>扩散性要求</strong>：</p>
<ul>
<li>每个输入位都应该影响所有输出位</li>
<li>需要多轮混合操作</li>
</ul>
</li>
<li><p><strong>性能要求</strong>：</p>
<ul>
<li>需要在安全性和速度之间平衡</li>
<li>需要优化位运算操作</li>
</ul>
</li>
<li><p><strong>标准化</strong>：</p>
<ul>
<li>需要经过国际标准组织认证</li>
<li>需要公开接受密码学社区审查</li>
</ul>
</li>
</ol>
<h3 id="实际生产环境建议"><a href="#实际生产环境建议" class="headerlink" title="实际生产环境建议"></a>实际生产环境建议</h3><p>⚠️ <strong>永远不要在生产环境中使用自己实现的哈希函数！</strong></p>
<p>应该使用经过验证的库：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 密码学哈希</span></span><br><span class="line">hashlib.sha256(<span class="string">b&quot;data&quot;</span>).hexdigest()</span><br><span class="line">hashlib.sha512(<span class="string">b&quot;data&quot;</span>).hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 快速哈希（非密码学）</span></span><br><span class="line"><span class="keyword">import</span> xxhash</span><br><span class="line">xxhash.xxh64(<span class="string">b&quot;data&quot;</span>).hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 感知哈希</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> imagehash</span><br><span class="line"><span class="built_in">hash</span> = imagehash.phash(Image.<span class="built_in">open</span>(<span class="string">&#x27;image.jpg&#x27;</span>))</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这9个章节的学习，我们从<strong>数学基础</strong>到<strong>工程应用</strong>，从<strong>密码学哈希</strong>到<strong>感知哈希</strong>，全面深入地理解了哈希技术的本质。</p>
<h3 id="核心要点回顾"><a href="#核心要点回顾" class="headerlink" title="核心要点回顾"></a>核心要点回顾</h3><ol>
<li><strong>哈希不可逆性</strong>：基于单向函数的数学困难性</li>
<li><strong>雪崩效应</strong>：通过混淆和扩散实现</li>
<li><strong>冲突处理</strong>：鸽巢原理决定了冲突的必然性</li>
<li><strong>算法结构</strong>：Merkle-Damgård 结构是经典设计</li>
<li><strong>密码学应用</strong>：加盐、HMAC、密钥派生</li>
<li><strong>工程应用</strong>：哈希表、一致性哈希、Merkle树</li>
<li><strong>感知哈希</strong>：相似性保持的特殊哈希</li>
<li><strong>特殊哈希</strong>：LSH、滚动哈希、校验和等</li>
<li><strong>实践实现</strong>：理解哈希设计的复杂性</li>
</ol>
<h3 id="学习路径建议"><a href="#学习路径建议" class="headerlink" title="学习路径建议"></a>学习路径建议</h3><ul>
<li><strong>初学者</strong>：从第①、②、③章开始，理解基本概念</li>
<li><strong>进阶者</strong>：深入学习第④、⑤、⑥章，掌握应用</li>
<li><strong>专家级</strong>：研究第⑦、⑧、⑨章，探索前沿应用</li>
</ul>
<p>哈希技术是现代计算机科学的基础，掌握它将帮助你：</p>
<ul>
<li>🔐 理解密码学和安全系统</li>
<li>⚡ 优化数据结构和算法</li>
<li>🌐 设计分布式系统</li>
<li>🖼️ 实现图像处理和检索</li>
<li>📊 构建高效的数据库系统</li>
</ul>
<p>继续深入学习，探索哈希技术的无限可能！✨</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://dummyv07.github.io">Dummy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://dummyv07.github.io/2025/12/10/%E5%93%88%E5%B8%8C/">https://dummyv07.github.io/2025/12/10/%E5%93%88%E5%B8%8C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://dummyv07.github.io" target="_blank">廾匸</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/hash.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/08/07/Nginx/" title="Nginx详解"><img class="cover" src="/img/nginx.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Nginx详解</div></div><div class="info-2"><div class="info-item-1">Nginx详解与部署流程在项目初期，如果并发量较小，用户数量有限，通常只需通过一个jar包启动应用，内部由自带的Tomcat处理请求即可满足需求。但随着用户量和并发量的提升，单一应用实例可能无法承载全部流量，这时就需要引入Nginx进行负载均衡和反向代理，提升系统的可用性和扩展性。 为什么选择NginxNginx（engine...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/eyes.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Dummy</div><div class="author-info-description">山与山不见面 再见容易再见难</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/DummyV07" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:dummy.v07@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Wechat:---NoOneIsComing （注明来意）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%A7%AC-%E5%93%88%E5%B8%8C"><span class="toc-number">1.</span> <span class="toc-text">🧬 哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">哈希有什么特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E9%80%94"><span class="toc-number">1.2.</span> <span class="toc-text">哈希的常见用途</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%94%AC-%E5%93%88%E5%B8%8C%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0"><span class="toc-number">2.</span> <span class="toc-text">🔬 哈希深入学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%91%A0-%E5%93%88%E5%B8%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8F%AF%E9%80%86%EF%BC%9F%EF%BC%88%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">① 哈希为什么不可逆？（数学基础）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E5%8F%AB%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">2.1.1.</span> <span class="toc-text">什么叫单向函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-SHA-256-%E5%8F%8D%E6%8E%A8%E5%87%A0%E4%B9%8E%E4%B8%8D%E5%8F%AF%E8%83%BD%EF%BC%9F"><span class="toc-number">2.1.2.</span> <span class="toc-text">为什么 SHA-256 反推几乎不可能？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%C2%B2%E2%81%B5%E2%81%B6-%E6%9C%89%E5%A4%9A%E5%A4%A7%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E4%B8%8D%E5%8F%AF%E8%A1%8C%EF%BC%9F"><span class="toc-number">2.1.3.</span> <span class="toc-text">2²⁵⁶ 有多大？为什么暴力破解不可行？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%BE%93%E5%87%BA%E5%80%BC%E7%9A%84%E5%9D%87%E5%8C%80%E5%88%86%E5%B8%83%E7%89%B9%E6%80%A7"><span class="toc-number">2.1.4.</span> <span class="toc-text">哈希输出值的均匀分布特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%91%A1-%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94%EF%BC%88Avalanche-Effect%EF%BC%89%E8%83%8C%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">② 雪崩效应（Avalanche Effect）背后的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94%EF%BC%9F"><span class="toc-number">2.2.1.</span> <span class="toc-text">什么是雪崩效应？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A9%E7%A0%81%EF%BC%88Mask%EF%BC%89%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%81%E6%B7%B7%E6%B7%86%E4%B8%8E%E6%89%A9%E6%95%A3"><span class="toc-number">2.2.2.</span> <span class="toc-text">掩码（Mask）、位运算、混淆与扩散</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E6%B7%86%EF%BC%88Confusion%EF%BC%89"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">混淆（Confusion）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E6%95%A3%EF%BC%88Diffusion%EF%BC%89"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">扩散（Diffusion）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E2%80%9D%E6%94%B9%E4%B8%80%E4%B8%AA%E6%AF%94%E7%89%B9-%E2%86%92-%E8%BE%93%E5%87%BA%E5%8F%98%E5%8C%96%E4%B8%80%E5%8D%8A%E4%BB%A5%E4%B8%8A%E2%80%9D%EF%BC%9F"><span class="toc-number">2.2.3.</span> <span class="toc-text">为什么”改一个比特 → 输出变化一半以上”？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#S-Box%E3%80%81%E8%BD%AE%E5%87%BD%E6%95%B0%E3%80%81%E9%80%BB%E8%BE%91%E6%B7%B7%E5%90%88%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.4.</span> <span class="toc-text">S-Box、轮函数、逻辑混合的内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#S-Box%EF%BC%88Substitution-Box%EF%BC%89"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">S-Box（Substitution Box）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AE%E5%87%BD%E6%95%B0%EF%BC%88Round-Function%EF%BC%89"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">轮函数（Round Function）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%B7%B7%E5%90%88%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">逻辑混合示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%91%A2-%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%EF%BC%88Collision%EF%BC%89%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">③ 哈希冲突（Collision）到底是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86%EF%BC%88Pigeonhole-Principle%EF%BC%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">鸽巢原理（Pigeonhole Principle）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E4%B8%8A%E4%B8%80%E5%AE%9A%E6%9C%89%E5%86%B2%E7%AA%81%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E5%87%A0%E4%B9%8E%E8%A7%81%E4%B8%8D%E5%88%B0%EF%BC%9F"><span class="toc-number">2.3.2.</span> <span class="toc-text">理论上一定有冲突，为什么我们几乎见不到？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%97%A5%E6%94%BB%E5%87%BB%EF%BC%88Birthday-Attack%EF%BC%89"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">生日攻击（Birthday Attack）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%86%B2%E7%AA%81%E6%A6%82%E7%8E%87"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">实际冲突概率</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%8F%E5%93%88%E5%B8%8C-vs-%E5%A5%BD%E5%93%88%E5%B8%8C"><span class="toc-number">2.3.3.</span> <span class="toc-text">坏哈希 vs 好哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%8F%E5%93%88%E5%B8%8C%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">坏哈希的例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%BD%E5%93%88%E5%B8%8C%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">好哈希的特征</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%8A%97%E7%A2%B0%E6%92%9E%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-number">2.3.4.</span> <span class="toc-text">如何设计抗碰撞算法？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Merkle%E2%80%93Damgard-%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">Merkle–Damgård 结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">压缩函数的设计原则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%91%A3-%E5%B8%B8%E8%A7%81%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E8%83%8C%E5%90%8E%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.</span> <span class="toc-text">④ 常见哈希算法背后的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MD5-%E6%98%AF%E6%80%8E%E4%B9%88%E8%A2%AB%E6%94%BB%E7%A0%B4%E7%9A%84%EF%BC%9F"><span class="toc-number">2.4.1.</span> <span class="toc-text">MD5 是怎么被攻破的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MD5-%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">MD5 的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A2%AB%E6%94%BB%E7%A0%B4%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">被攻破的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E6%94%BB%E5%87%BB"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">实际攻击</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SHA-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">2.4.2.</span> <span class="toc-text">SHA-1 为什么不安全？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SHA-1-%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">SHA-1 的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">安全问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SHA-1-%E7%A2%B0%E6%92%9E%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">SHA-1 碰撞示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SHA-256-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9B%B4%E5%BC%BA%EF%BC%9F"><span class="toc-number">2.4.3.</span> <span class="toc-text">SHA-256 为什么更强？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SHA-256-%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">SHA-256 的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%A2%9E%E5%BC%BA"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">安全增强</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SHA-256-%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.3.3.</span> <span class="toc-text">SHA-256 的压缩函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E7%8A%B6%E6%80%81"><span class="toc-number">2.4.3.4.</span> <span class="toc-text">当前状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Merkle%E2%80%93Damgard-%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.4.4.</span> <span class="toc-text">Merkle–Damgård 结构详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E6%B5%81%E7%A8%8B"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">结构流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E8%A7%84%E5%88%99%EF%BC%88Padding%EF%BC%89"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">填充规则（Padding）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%87%BD%E6%95%B0%EF%BC%88Compression-Function%EF%BC%89"><span class="toc-number">2.4.4.3.</span> <span class="toc-text">压缩函数（Compression Function）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%91%A4-%E5%93%88%E5%B8%8C%E5%9C%A8%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">2.5.</span> <span class="toc-text">⑤ 哈希在密码学中的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HMAC%EF%BC%88%E5%B8%A6%E5%AF%86%E9%92%A5%E7%9A%84%E5%93%88%E5%B8%8C%EF%BC%89"><span class="toc-number">2.5.1.</span> <span class="toc-text">HMAC（带密钥的哈希）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HMAC-%E7%AE%97%E6%B3%95"><span class="toc-number">2.5.1.1.</span> <span class="toc-text">HMAC 算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-%E5%AE%9E%E7%8E%B0%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.5.1.2.</span> <span class="toc-text">Python 实现示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.5.1.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PBKDF2%E3%80%81bcrypt%E3%80%81scrypt%E3%80%81Argon2"><span class="toc-number">2.5.2.</span> <span class="toc-text">PBKDF2、bcrypt、scrypt、Argon2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PBKDF2%EF%BC%88Password-Based-Key-Derivation-Function-2%EF%BC%89"><span class="toc-number">2.5.2.1.</span> <span class="toc-text">PBKDF2（Password-Based Key Derivation Function 2）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bcrypt"><span class="toc-number">2.5.2.2.</span> <span class="toc-text">bcrypt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#scrypt"><span class="toc-number">2.5.2.3.</span> <span class="toc-text">scrypt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Argon2"><span class="toc-number">2.5.2.4.</span> <span class="toc-text">Argon2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E7%9B%90%EF%BC%88Salt%EF%BC%89%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%BD%A9%E8%99%B9%E8%A1%A8%E6%94%BB%E5%87%BB%E9%98%B2%E6%8A%A4"><span class="toc-number">2.5.3.</span> <span class="toc-text">加盐（Salt）的作用和彩虹表攻击防护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8A%A0%E7%9B%90%EF%BC%9F"><span class="toc-number">2.5.3.1.</span> <span class="toc-text">为什么需要加盐？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%A9%E8%99%B9%E8%A1%A8%E6%94%BB%E5%87%BB%EF%BC%88Rainbow-Table-Attack%EF%BC%89"><span class="toc-number">2.5.3.2.</span> <span class="toc-text">彩虹表攻击（Rainbow Table Attack）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">2.5.3.3.</span> <span class="toc-text">最佳实践</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%91%A5-%E5%93%88%E5%B8%8C%E5%9C%A8%E5%B7%A5%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">2.6.</span> <span class="toc-text">⑥ 哈希在工程中的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88HashMap%EF%BC%89%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">2.6.1.</span> <span class="toc-text">哈希表（HashMap）底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">2.6.1.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-%E5%AE%9E%E7%8E%B0%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">2.6.1.2.</span> <span class="toc-text">Python 实现示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86%EF%BC%9A%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95%E3%80%81%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95"><span class="toc-number">2.6.2.</span> <span class="toc-text">冲突处理：链地址法、开放定址法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95%EF%BC%88Chaining%EF%BC%89"><span class="toc-number">2.6.2.1.</span> <span class="toc-text">链地址法（Chaining）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95%EF%BC%88Open-Addressing%EF%BC%89"><span class="toc-number">2.6.2.2.</span> <span class="toc-text">开放定址法（Open Addressing）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E6%80%A7%E8%83%BD%EF%BC%9F"><span class="toc-number">2.6.3.</span> <span class="toc-text">负载因子如何影响性能？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">2.6.3.1.</span> <span class="toc-text">性能分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%EF%BC%88Rehashing%EF%BC%89"><span class="toc-number">2.6.3.2.</span> <span class="toc-text">动态扩容（Rehashing）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%EF%BC%88%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%89"><span class="toc-number">2.6.4.</span> <span class="toc-text">一致性哈希（分布式系统）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-1"><span class="toc-number">2.6.4.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.6.4.2.</span> <span class="toc-text">Python 实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">2.6.4.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%93%88%E5%B8%8C%E5%BA%94%E7%94%A8%EF%BC%88Merkle-%E6%A0%91%EF%BC%89"><span class="toc-number">2.6.5.</span> <span class="toc-text">区块链中的哈希应用（Merkle 树）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Merkle-%E6%A0%91%E7%BB%93%E6%9E%84"><span class="toc-number">2.6.5.1.</span> <span class="toc-text">Merkle 树结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">2.6.5.2.</span> <span class="toc-text">Python 实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">2.6.5.3.</span> <span class="toc-text">区块链中的应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%91%A6-%E6%84%9F%E7%9F%A5%E5%93%88%E5%B8%8C%EF%BC%88Perceptual-Hash%EF%BC%89"><span class="toc-number">2.7.</span> <span class="toc-text">⑦ 感知哈希（Perceptual Hash）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%9F%E7%9F%A5%E5%93%88%E5%B8%8C%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6%E5%93%88%E5%B8%8C%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%8C%BA%E5%88%AB"><span class="toc-number">2.7.1.</span> <span class="toc-text">感知哈希与密码学哈希的根本区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pHash%EF%BC%88Perceptual-Hash%EF%BC%89%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-number">2.7.2.</span> <span class="toc-text">pHash（Perceptual Hash）算法原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.7.2.1.</span> <span class="toc-text">算法步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">2.7.2.2.</span> <span class="toc-text">Python 实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dHash%EF%BC%88Difference-Hash%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-number">2.7.3.</span> <span class="toc-text">dHash（Difference Hash）算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">2.7.3.1.</span> <span class="toc-text">算法步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">2.7.3.2.</span> <span class="toc-text">Python 实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aHash%EF%BC%88Average-Hash%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-number">2.7.4.</span> <span class="toc-text">aHash（Average Hash）算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-2"><span class="toc-number">2.7.4.1.</span> <span class="toc-text">算法步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">2.7.4.2.</span> <span class="toc-text">Python 实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wHash%EF%BC%88Wavelet-Hash%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-number">2.7.5.</span> <span class="toc-text">wHash（Wavelet Hash）算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-3"><span class="toc-number">2.7.5.1.</span> <span class="toc-text">算法步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="toc-number">2.7.6.</span> <span class="toc-text">算法对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">2.7.7.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%91%A7-%E5%85%B6%E4%BB%96%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94%E5%93%88%E5%B8%8C"><span class="toc-number">2.8.</span> <span class="toc-text">⑧ 其他特殊用途哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%95%8F%E6%84%9F%E5%93%88%E5%B8%8C%EF%BC%88LSH-Locality-Sensitive-Hashing%EF%BC%89"><span class="toc-number">2.8.1.</span> <span class="toc-text">局部敏感哈希（LSH - Locality Sensitive Hashing）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">2.8.1.1.</span> <span class="toc-text">核心思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%AE%9A%E4%B9%89"><span class="toc-number">2.8.1.2.</span> <span class="toc-text">数学定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MinHash-%E7%AE%97%E6%B3%95%EF%BC%88%E7%94%A8%E4%BA%8E%E9%9B%86%E5%90%88%E7%9B%B8%E4%BC%BC%E6%80%A7%EF%BC%89"><span class="toc-number">2.8.1.3.</span> <span class="toc-text">MinHash 算法（用于集合相似性）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="toc-number">2.8.1.4.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8%E5%93%88%E5%B8%8C%EF%BC%88Rolling-Hash%EF%BC%89%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">2.8.2.</span> <span class="toc-text">滚动哈希（Rolling Hash）在字符串匹配中的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Rabin-Karp-%E7%AE%97%E6%B3%95"><span class="toc-number">2.8.2.1.</span> <span class="toc-text">Rabin-Karp 算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.8.2.2.</span> <span class="toc-text">时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C%E5%92%8C%EF%BC%88Checksum%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-number">2.8.3.</span> <span class="toc-text">校验和（Checksum）算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%A0%A1%E9%AA%8C%E5%92%8C"><span class="toc-number">2.8.3.1.</span> <span class="toc-text">简单校验和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fletcher-%E6%A0%A1%E9%AA%8C%E5%92%8C"><span class="toc-number">2.8.3.2.</span> <span class="toc-text">Fletcher 校验和</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C%EF%BC%88CRC%EF%BC%89"><span class="toc-number">2.8.4.</span> <span class="toc-text">循环冗余校验（CRC）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CRC-32-%E7%AE%97%E6%B3%95"><span class="toc-number">2.8.4.1.</span> <span class="toc-text">CRC-32 算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CRC-%E5%A4%9A%E9%A1%B9%E5%BC%8F"><span class="toc-number">2.8.4.2.</span> <span class="toc-text">CRC 多项式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%88Bloom-Filter%EF%BC%89%E4%B8%AD%E7%9A%84%E5%A4%9A%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-number">2.8.5.</span> <span class="toc-text">布隆过滤器（Bloom Filter）中的多哈希函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">2.8.5.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AF%E5%88%A4%E7%8E%87%E8%AE%A1%E7%AE%97"><span class="toc-number">2.8.5.2.</span> <span class="toc-text">误判率计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-%E5%AE%9E%E7%8E%B0-5"><span class="toc-number">2.8.5.3.</span> <span class="toc-text">Python 实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E5%93%88%E5%B8%8C%EF%BC%88Feature-Hashing%EF%BC%89%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">2.8.6.</span> <span class="toc-text">特征哈希（Feature Hashing）在机器学习中的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">2.8.6.1.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-%E5%AE%9E%E7%8E%B0-6"><span class="toc-number">2.8.6.2.</span> <span class="toc-text">Python 实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86"><span class="toc-number">2.8.6.3.</span> <span class="toc-text">哈希冲突处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%91%A8-%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8C%96%E7%89%88%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="toc-number">2.9.</span> <span class="toc-text">⑨ 动手实现简化版哈希算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87"><span class="toc-number">2.9.1.</span> <span class="toc-text">设计目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E5%9F%BA%E7%A1%80"><span class="toc-number">2.9.2.</span> <span class="toc-text">位运算基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.9.3.</span> <span class="toc-text">简化哈希函数实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BA%E6%89%A9%E6%95%A3%E6%80%A7%E7%9A%84%E6%8A%80%E5%B7%A7"><span class="toc-number">2.9.4.</span> <span class="toc-text">增强扩散性的技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8S-Box%EF%BC%88%E6%9B%BF%E6%8D%A2%E7%9B%92%EF%BC%89"><span class="toc-number">2.9.4.1.</span> <span class="toc-text">1. 使用S-Box（替换盒）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%87%BD%E6%95%B0"><span class="toc-number">2.9.4.2.</span> <span class="toc-text">2. 非线性函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BD%AE%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.9.4.3.</span> <span class="toc-text">3. 轮函数设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A5%BD%E7%9A%84%E5%93%88%E5%B8%8C%E8%AE%BE%E8%AE%A1%E8%BF%99%E4%B9%88%E5%A4%8D%E6%9D%82%EF%BC%9F"><span class="toc-number">2.9.5.</span> <span class="toc-text">为什么好的哈希设计这么复杂？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%BB%BA%E8%AE%AE"><span class="toc-number">2.9.6.</span> <span class="toc-text">实际生产环境建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.10.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9%E5%9B%9E%E9%A1%BE"><span class="toc-number">2.10.1.</span> <span class="toc-text">核心要点回顾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84%E5%BB%BA%E8%AE%AE"><span class="toc-number">2.10.2.</span> <span class="toc-text">学习路径建议</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/10/%E5%93%88%E5%B8%8C/" title="哈希"><img src="/img/hash.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="哈希"/></a><div class="content"><a class="title" href="/2025/12/10/%E5%93%88%E5%B8%8C/" title="哈希">哈希</a><time datetime="2025-12-10T08:00:00.000Z" title="发表于 2025-12-10 16:00:00">2025-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/07/Nginx/" title="Nginx详解"><img src="/img/nginx.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nginx详解"/></a><div class="content"><a class="title" href="/2025/08/07/Nginx/" title="Nginx详解">Nginx详解</a><time datetime="2025-08-07T10:00:00.000Z" title="发表于 2025-08-07 18:00:00">2025-08-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/22/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E4%B9%8BMCP/" title="大模型学习之MCP"><img src="/img/mcp.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="大模型学习之MCP"/></a><div class="content"><a class="title" href="/2025/07/22/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E4%B9%8BMCP/" title="大模型学习之MCP">大模型学习之MCP</a><time datetime="2025-07-22T04:00:00.000Z" title="发表于 2025-07-22 12:00:00">2025-07-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/13/Docker-Python/" title="Docker部署python项目"><img src="/img/docker.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker部署python项目"/></a><div class="content"><a class="title" href="/2025/07/13/Docker-Python/" title="Docker部署python项目">Docker部署python项目</a><time datetime="2025-07-13T06:00:00.000Z" title="发表于 2025-07-13 14:00:00">2025-07-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/30/service_manager/" title="service_manager"><img src="/img/service_manager.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="service_manager"/></a><div class="content"><a class="title" href="/2025/06/30/service_manager/" title="service_manager">service_manager</a><time datetime="2025-06-30T04:00:00.000Z" title="发表于 2025-06-30 12:00:00">2025-06-30</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Dummy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.2.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>